<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>greykite.algo.reconcile.convex.reconcile_forecasts &mdash; Greykite Library  documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../../index.html" class="icon icon-home"> Greykite Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/overview/100_forecast_intro.html">The Greykite Forecast model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/overview/200_ad_intro.html">The Greykite Anomaly Detection model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quick Start</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gallery/quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gallery/tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gallery/templates/index.html">Model Templates</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Step by Step</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0000_stepbystep.html">Forecasting Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0100_choose_model.html">Choose a Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0200_choose_template.html">Choose a Model Template</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0300_input.html">Examine Input Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0400_configuration.html">Configure a Forecast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0500_output.html">Check Forecast Result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0600_debug.html">Debugging</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tuning the Model Components</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0100_introduction.html">Greykite models and components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0200_growth.html">Growth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0300_seasonality.html">Seasonality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0400_events.html">Holidays and Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0500_changepoints.html">Changepoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0600_custom.html">Custom Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0700_regressors.html">Regressors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0800_autoregression.html">Auto-regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0900_uncertainty.html">Uncertainty Intervals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/1000_override.html">Pre-processing, Selective Grid Search</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Benchmarking</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/benchmarking/benchmarking.html">Benchmarking</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/miscellaneous/reconcile_forecasts.html">Reconcile Forecasts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/miscellaneous/store_model.html">Model store and load</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Changelog</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html">1.0.0 (2024-01-07)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id2">0.5.1 (2023-06-01)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id3">0.5.0 (2023-04-03)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id4">0.4.0 (2022-07-15)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id5">0.3.0 (2021-12-14)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id6">0.2.0 (2021-06-30)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id7">0.1.1 (2021-05-12)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/autodoc/doc.html">Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Greykite Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">greykite.algo.reconcile.convex.reconcile_forecasts</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for greykite.algo.reconcile.convex.reconcile_forecasts</h1><div class="highlight"><pre>
<span></span><span class="c1"># BSD 2-CLAUSE LICENSE</span>

<span class="c1"># Redistribution and use in source and binary forms, with or without modification,</span>
<span class="c1"># are permitted provided that the following conditions are met:</span>

<span class="c1"># Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1"># list of conditions and the following disclaimer.</span>
<span class="c1"># Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1"># this list of conditions and the following disclaimer in the documentation</span>
<span class="c1"># and/or other materials provided with the distribution.</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="c1"># ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="c1"># DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR</span>
<span class="c1"># #ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="c1"># (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="c1"># LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="c1"># ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="c1"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="c1"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># original author: Albert Chen</span>
<span class="sd">&quot;&quot;&quot;Convex optimization approach to forecast reconciliation.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">plotly</span>
<span class="kn">import</span> <span class="nn">plotly.express</span> <span class="k">as</span> <span class="nn">px</span>
<span class="kn">from</span> <span class="nn">plotly</span> <span class="kn">import</span> <span class="n">graph_objects</span> <span class="k">as</span> <span class="n">go</span>
<span class="kn">from</span> <span class="nn">plotly.subplots</span> <span class="kn">import</span> <span class="n">make_subplots</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span>
<span class="kn">from</span> <span class="nn">sklearn.exceptions</span> <span class="kn">import</span> <span class="n">NotFittedError</span>

<span class="kn">from</span> <span class="nn">greykite.algo.reconcile.hierarchical_relationship</span> <span class="kn">import</span> <span class="n">HierarchicalRelationship</span>
<span class="kn">from</span> <span class="nn">greykite.common.python_utils</span> <span class="kn">import</span> <span class="n">reorder_columns</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">IPython.core</span> <span class="kn">import</span> <span class="n">display</span> <span class="k">as</span> <span class="n">ICD</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c1"># ipython is an optional dependency, by default only enabled for development</span>


<span class="n">DEFAULT_METHOD</span> <span class="o">=</span> <span class="s2">&quot;custom&quot;</span>
<span class="sd">&quot;&quot;&quot;Default method to use in `fit`.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">get_weight_matrix</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">n_forecasts</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default_weights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a diagonal weight matrix with shape (``n_forecasts``, ``n_forecasts``)</span>
<span class="sd">    and Frobenius norm sqrt(`n_forecasts`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weights : `list` [`float`] or `str` or None</span>
<span class="sd">        What weights to use.</span>

<span class="sd">            - If a list, returns a diagonal matrix with the list values on the diagonal.</span>
<span class="sd">              These values specify the weight for each timeseries.</span>
<span class="sd">              In ``ReconcileAdditiveForecasts``, weights are applied to the matrix</span>
<span class="sd">              whose rows are reordered to canonical form (transposed output of ``reorder_columns``)</span>
<span class="sd">            - If a string, determined by ``default_weights``.</span>
<span class="sd">            - If None, the identity matrix (equal weights).</span>

<span class="sd">        The specified weights are normalized in the output.</span>

<span class="sd">    n_forecasts : `int`</span>
<span class="sd">        The number of forecasts (shape of the output).</span>
<span class="sd">    name : `str`</span>
<span class="sd">        The name of the weight matrix.</span>
<span class="sd">    default_weights : `dict` [`str`, `numpy.array`]</span>
<span class="sd">        Default weights to use if ``weights`` is a string.</span>
<span class="sd">        Values should be square matrices with shape (``n_forecasts``, ``n_forecasts``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weight_matrix : `numpy.array`</span>
<span class="sd">        Weights to apply to the errors.</span>
<span class="sd">        Diagonal matrix with shape (``n_forecasts``, ``n_forecasts``)</span>
<span class="sd">        and Frobenius norm sqrt(`n_forecasts`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_forecasts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">in</span> <span class="n">default_weights</span><span class="p">:</span>
            <span class="n">weight_matrix</span> <span class="o">=</span> <span class="n">default_weights</span><span class="p">[</span><span class="n">weights</span><span class="p">]</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;weight for </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is </span><span class="si">{</span><span class="n">weight_matrix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The requested weight &#39;</span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s2">&#39; for `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">` is not found. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Must be one of </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">default_weights</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weight_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">weight_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_forecasts</span><span class="p">,</span> <span class="n">n_forecasts</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected square matrix with size </span><span class="si">{</span><span class="n">n_forecasts</span><span class="si">}</span><span class="s2">, but `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">` has &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;weight matrix with shape </span><span class="si">{</span><span class="n">weight_matrix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">target_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_forecasts</span><span class="p">))</span>
    <span class="n">weight_matrix</span> <span class="o">=</span> <span class="n">weight_matrix</span> <span class="o">*</span> <span class="n">target_norm</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">weight_matrix</span>


<span class="k">def</span> <span class="nf">get_fit_params</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">DEFAULT_METHOD</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns parameters for</span>
<span class="sd">    `greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit`</span>
<span class="sd">    corresponding to recognized hierarchical reconciliation method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method : `str`, default `~greykite.algo.reconcile.convex.reconcile_forecasts.DEFAULT_METHOD`</span>
<span class="sd">        Which reconciliation method to use.</span>
<span class="sd">        Valid values are &quot;bottom_up&quot;, &quot;ols&quot;, &quot;mint_sample&quot;, &quot;custom&quot;:</span>

<span class="sd">            - &quot;bottom_up&quot;   : Sums leaf nodes. Unbiased transform that uses only the values of the leaf nodes</span>
<span class="sd">                              to propagate up the tree. Each node&#39;s value is the sum of its</span>
<span class="sd">                              corresponding leaf nodes&#39; values (a leaf node corresponds to a node T if it is</span>
<span class="sd">                              a leaf node of the subtree with T as its root, i.e. a descendant of T or T itself).</span>
<span class="sd">                              See Dangerfield and Morris 1992 &quot;Top-down or bottom-up: Aggregate versus disaggregate</span>
<span class="sd">                              extrapolations&quot; for one discussion of this method.</span>
<span class="sd">                              Depends only on the structure of the hierarchy, not on the data itself.</span>
<span class="sd">            - &quot;ols&quot;         : OLS estimate proposed by https://robjhyndman.com/papers/Hierarchical6.pdf</span>
<span class="sd">                              (Hyndman et al. 2010, &quot;Optimal combination forecasts for hierarchical time series&quot;)</span>
<span class="sd">                              Also see https://robjhyndman.com/papers/mint.pdf section 2.4.1.</span>
<span class="sd">                              (Wickramasuriya et al. 2019 &quot;Optimal forecast reconciliation for</span>
<span class="sd">                              hierarchical and grouped time series through trace minimization&quot;.)</span>
<span class="sd">                              Unbiased transform that minimizes variance of adjusted residuals,</span>
<span class="sd">                              using &quot;identity&quot; estimate of original residual variance.</span>
<span class="sd">                              Optimal if original forecast errors are uncorrelated with equal variance (unlikely).</span>
<span class="sd">                              Depends only on the structure of the hierarchy, not on the data itself.</span>
<span class="sd">            - &quot;mint_sample&quot; : Unbiased transform that minimizes variance of adjusted residuals,</span>
<span class="sd">                              using &quot;sample&quot; estimate of original residual variance.</span>
<span class="sd">                              Assumes base forecasts are unbiased.</span>
<span class="sd">                              See Wickramasuriya et al. 2019 section 2.4.4.</span>
<span class="sd">                              Depends on the structure of the hierarchy and forecast error covariances.</span>
<span class="sd">            - &quot;custom&quot;      : Optimization parameters can be set by the user. See</span>
<span class="sd">                              `greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit`</span>
<span class="sd">                              method for parameters and their default values.</span>
<span class="sd">                              Depends on the structure of the hierarchy, base forecasts, and actuals, if all terms</span>
<span class="sd">                              are included in the objective.</span>

<span class="sd">        If &quot;custom&quot;, uses the parameters passed to</span>
<span class="sd">        `greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit`</span>
<span class="sd">        to formulate the convex optimization problem.</span>

<span class="sd">        If &quot;bottom_up&quot;, &quot;ols&quot;, or &quot;mint_sample&quot;, the other fit parameters are ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    estimator_fit_params : `dict` [`str`, Any]</span>
<span class="sd">        Parameters to use when calling ``ReconcileAdditiveForecasts.fit()``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;custom&quot;</span><span class="p">:</span>
        <span class="n">estimator_fit_params</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># uses default values of ``fit`` and those passed by user</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bottom_up&quot;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using bottom_up estimator&quot;</span><span class="p">)</span>
        <span class="n">estimator_fit_params</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># already passed to ``fit`` via ``method``</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;ols&quot;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using ols estimator&quot;</span><span class="p">)</span>
        <span class="n">estimator_fit_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">lower_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">upper_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>          <span class="c1"># unbiased</span>
            <span class="n">lam_adj</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">lam_bias</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">lam_train</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">lam_var</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>            <span class="c1"># minimizes variance</span>
            <span class="n">covariance</span><span class="o">=</span><span class="s2">&quot;identity&quot;</span><span class="p">,</span>  <span class="c1"># assumes equal uncorrelated variance</span>
            <span class="n">weight_adj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_train</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_var</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mint_sample&quot;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using mint_sample estimator&quot;</span><span class="p">)</span>
        <span class="n">estimator_fit_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">lower_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">upper_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>        <span class="c1"># unbiased</span>
            <span class="n">lam_adj</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">lam_bias</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">lam_train</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">lam_var</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>          <span class="c1"># minimizes variance</span>
            <span class="n">covariance</span><span class="o">=</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span>  <span class="c1"># in-sample variance estimate</span>
            <span class="n">weight_adj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_train</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_var</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`method` &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not recognized. &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;Must be one of &#39;bottom_up&#39;, &#39;ols&#39;, &#39;mint_sample&#39;, &#39;custom&#39;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">estimator_fit_params</span>


<span class="k">def</span> <span class="nf">apply_method_defaults</span><span class="p">(</span><span class="n">fit_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator for `greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit`.</span>
<span class="sd">    Fetches parameters based on ``method`` and calls ``fit_func`` with the result.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fit_func : `callable`</span>
<span class="sd">        Should be `greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    apply_defaults_and_fit : callable</span>
<span class="sd">        Function that overwrites ``fit_params`` with those specified by ``method``</span>
<span class="sd">        and calls ``fit_func`` with those params.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fit_func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">apply_defaults_and_fit</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">forecasts</span><span class="p">,</span>
            <span class="n">actuals</span><span class="p">,</span>
            <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrites ``fit_params`` with those specified by ``fit_params[&quot;method&quot;]``.</span>
<span class="sd">        Calls ``fit_func`` with those params.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : `ReconcileAdditiveForecasts`</span>
<span class="sd">            Self. Decorator should be applied to ``ReconcileAdditiveForecasts.fit()``.</span>
<span class="sd">        forecasts : `pandas.DataFrame`</span>
<span class="sd">            Forecasted values to pass to ``fit_func``.</span>
<span class="sd">        actuals : `pandas.DataFrame`</span>
<span class="sd">            Actual values to pass to ``fit_func``.</span>
<span class="sd">        fit_params : `dict`</span>
<span class="sd">            Original parameters used to call ``fit_func``.</span>
<span class="sd">            These are overridden by the ones corresponding to ``method``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : Any</span>
<span class="sd">            Same as the output of ``fit_func``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">fit_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="n">DEFAULT_METHOD</span><span class="p">)</span>
        <span class="n">method_fit_params</span> <span class="o">=</span> <span class="n">get_fit_params</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fit_params</span><span class="p">,</span> <span class="o">**</span><span class="n">method_fit_params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fit_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">forecasts</span><span class="p">,</span>
            <span class="n">actuals</span><span class="p">,</span>
            <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">apply_defaults_and_fit</span>


<div class="viewcode-block" id="TraceInfo"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.TraceInfo">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">TraceInfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Contains y-values for related lines to plot,</span>
<span class="sd">    such as forecasts or actuals.</span>

<span class="sd">    The lines share the same color,</span>
<span class="sd">    name, and legend group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data to plot. Each column contains the y-values for a line.&quot;&quot;&quot;</span>
    <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Line color.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;String to include in the line name for the legend.&quot;&quot;&quot;</span>
    <span class="n">legendgroup</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Group name to group lines in the legend.&quot;&quot;&quot;</span></div>


<span class="k">def</span> <span class="nf">evaluation_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">traces</span><span class="p">,</span> <span class="n">num_cols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hline</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to create evaluation plots from traces.</span>

<span class="sd">    Creates a figure with subplots.</span>
<span class="sd">    Every dataframe in ``traces`` has the same columns.</span>
<span class="sd">    There is one subplot for each column, plotting the values of</span>
<span class="sd">    that column from all the traces against ``x``.</span>

<span class="sd">    For example, there can be two traces, forecasts and actuals,</span>
<span class="sd">    each containing timeseries for multiple variables (nodes),</span>
<span class="sd">    represented as columns in ``df``. ``x`` can be the time</span>
<span class="sd">    index of the timeseries. This function returns a figure with</span>
<span class="sd">    a subplot for each variable, plotting forecasts against actuals.</span>

<span class="sd">    x : `numpy.array`</span>
<span class="sd">        x-axis values for the lines to plot.</span>
<span class="sd">    traces : `list` [`greykite.algo.reconcile.convex.reconcile_forecasts.TraceInfo`]</span>
<span class="sd">        y-axis values for the lines to plot, along with styling info.</span>
<span class="sd">        The columns for each dataframe in ``traces`` must be identical.</span>
<span class="sd">        The number of rows in each dataframe must match the length of ``x``.</span>
<span class="sd">    num_cols : `int`, default 3</span>
<span class="sd">        Number of columns in the plot.</span>
<span class="sd">        Controls the number of subplots to show in each row,</span>
<span class="sd">        before wrapping to the next row.</span>

<span class="sd">        Rows are filled in the order of the columns</span>
<span class="sd">        in the dataframes, from left to right.</span>
<span class="sd">    ylabel : `str` or None, default None</span>
<span class="sd">        y-axis label for each subplot.</span>
<span class="sd">        If None, no y-axis label is shown.</span>
<span class="sd">    title : `str` or None, default None</span>
<span class="sd">        Title for the entire plot.</span>
<span class="sd">        If None, no title is shown.</span>
<span class="sd">    hline : `bool`, default False</span>
<span class="sd">        Whether to show a horizontal line at y=0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fig : `plotly.graph_objects.Figure`</span>
<span class="sd">        The plot object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must be at least one trace to plot.&quot;</span><span class="p">)</span>
    <span class="n">df_col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">traces</span><span class="p">]</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="n">df_col_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">cols</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">cols</span> <span class="ow">in</span> <span class="n">df_col_names</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Column names must be identical in all traces.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">trace</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">traces</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;``x`` length must match ``df`` length for all traces.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_cols</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">num_cols</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`num_cols` should be between 1 and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;(the number of columns), found </span><span class="si">{</span><span class="n">num_cols</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># The number of rows depends on the number of</span>
    <span class="c1"># subplots and the subplots per row.</span>
    <span class="n">num_rows</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">num_cols</span><span class="p">)</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">make_subplots</span><span class="p">(</span>
        <span class="n">rows</span><span class="o">=</span><span class="n">num_rows</span><span class="p">,</span>
        <span class="n">cols</span><span class="o">=</span><span class="n">num_cols</span><span class="p">,</span>
        <span class="n">start_cell</span><span class="o">=</span><span class="s2">&quot;top-left&quot;</span><span class="p">,</span>
        <span class="n">subplot_titles</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">col_names</span><span class="p">))</span>
    <span class="c1"># Creates a subplot for each column</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
        <span class="c1"># Subplot position (1-indexed)</span>
        <span class="c1"># Fills rows from left to right,</span>
        <span class="c1"># top to bottom.</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">i</span><span class="o">//</span><span class="n">num_cols</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">num_cols</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Adds y=0 line</span>
        <span class="k">if</span> <span class="n">hline</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span>
                <span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;zero&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="n">legendgroup</span><span class="o">=</span><span class="s2">&quot;zero&quot;</span><span class="p">,</span>
                    <span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">),</span>
                <span class="n">row</span><span class="o">=</span><span class="n">row</span><span class="p">,</span>
                <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># Adds each trace&#39;s column</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">traces</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">trace</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">node</span>
            <span class="n">opacity</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.8</span>  <span class="c1"># adds opacity to traces after the first one</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span>
                <span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">node</span><span class="p">]),</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">legendgroup</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">legendgroup</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">color</span><span class="p">),</span>
                    <span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">row</span><span class="o">=</span><span class="n">row</span><span class="p">,</span>
                <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># Adds y-axis titles</span>
        <span class="n">ytitle</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">Title</span><span class="p">(</span><span class="n">font</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span> <span class="n">text</span><span class="o">=</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_yaxes</span><span class="p">(</span><span class="n">row</span><span class="o">=</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">ytitle</span><span class="p">)</span>
    <span class="c1"># Adds title for the entire plot</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">title_text</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">title_x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">title_font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fig</span>


<div class="viewcode-block" id="ReconcileAdditiveForecasts"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts">[docs]</a><span class="k">class</span> <span class="nc">ReconcileAdditiveForecasts</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconciles forecasts to satisfy additive constraints.</span>

<span class="sd">    Constraints can be encoded by the tree structure via ``levels``.</span>
<span class="sd">    In the tree formulation, a parent&#39;s value must be the sum of its children&#39;s values.</span>

<span class="sd">    Or, constraints can be encoded as a matrix via ``constraint_matrix``,</span>
<span class="sd">    specifying additive expressions that must equal 0. The constraints need not have a</span>
<span class="sd">    tree representation.</span>

<span class="sd">    Provides standard methods such as bottom up, ols, MinT. Also supports a custom method</span>
<span class="sd">    that minimizes user-specified types of error. The solution is derived by convex optimization.</span>
<span class="sd">    If desired, a constraint is added to require the transformation to be unbiased.</span>

<span class="sd">    If not using method=&quot;ols&quot; or method=&quot;bottom_up&quot;, which don&#39;t depend on the data,</span>
<span class="sd">    forecast reconciliation should be trained once per horizon</span>
<span class="sd">    (# periods between forecasted date and train_end_date),</span>
<span class="sd">    because the optimal adjustment may differ.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    forecasts : `pandas.DataFrame`, shape (n, m)</span>
<span class="sd">        Original forecasted values, used to train the method.</span>
<span class="sd">        Also known as &quot;base&quot; forecasts.</span>
<span class="sd">        Long format where each column is a time series.</span>
<span class="sd">        and each row is a time step.</span>
<span class="sd">        For proper variance estimates for the variance penalty,</span>
<span class="sd">        values should be at a fixed-horizon (e.g. always 7-step ahead).</span>
<span class="sd">    actuals : `pandas.DataFrame`, shape (n, m)</span>
<span class="sd">        Actual values to train the method, corresponding to ``forecasts``.</span>
<span class="sd">        Must have the same shape and column names as ``forecasts``.</span>
<span class="sd">    constraint_matrix : `numpy.array`, shape (c, m), or None</span>
<span class="sd">        Constraints. ``c x m`` array encoding ``c`` constraints of ``m`` variables.</span>
<span class="sd">        We require ``constraint_matrix @ transform_matrix = 0``.</span>
<span class="sd">        For example, to encode ``-x1 + x2 + x3 == 0 and -x2 + x4 + x5 == 0``::</span>

<span class="sd">            constraint_matrix = np.array([</span>
<span class="sd">                [-1, 1, 1, 0, 0],</span>
<span class="sd">                [0, -1, 0, 1, 1]])</span>

<span class="sd">        Entries are typically in [-1, 0, 1], but this is not required.</span>
<span class="sd">        Either ``constraint_matrix`` or ``levels`` must be provided.</span>

<span class="sd">    levels : `list` [`list` [`int`]] or None</span>
<span class="sd">        A simpler way to encode tree constraints. Overrides ``constraint_matrix`` if provided.</span>
<span class="sd">        Specifies the number of children of each parent (internal) node in the tree.</span>
<span class="sd">        The number of inner lists is the height of the tree. The ith inner list provides the number</span>
<span class="sd">        of children of each node at depth i. For example::</span>

<span class="sd">            # root node with 3 children</span>
<span class="sd">            levels = [[3]]</span>
<span class="sd">            # root node with 3 children, who have 2, 3, 3 children respectively</span>
<span class="sd">            levels = [[3], [2, 3, 3]]</span>

<span class="sd">        All leaf nodes must have the same depth. Thus, the first sublist must have one</span>
<span class="sd">        integer, the length of a sublist must equal the sum of the previous sublist,</span>
<span class="sd">        and all integers in ``levels`` must be positive.</span>

<span class="sd">        Either ``constraint_matrix`` or ``levels`` must be provided.</span>

<span class="sd">    order_dict : `dict` [`str`, `float`] or None</span>
<span class="sd">        How to order the columns before fitting.</span>
<span class="sd">        The key is the column name, the value is its position.</span>
<span class="sd">        When ``levels`` is used, map each column name to the</span>
<span class="sd">        order of its corresponding node in a BFS traversal of the tree.</span>
<span class="sd">        When ``constraint_matrix`` is used, this shuffles the order</span>
<span class="sd">        of the columns before the constraints are applied (thus, columns</span>
<span class="sd">        in ``constraint_matrix`` refer to the columns after reordering).</span>

<span class="sd">        If None, no reordering is done.</span>

<span class="sd">    method : `str`</span>
<span class="sd">        Which reconciliation method to use.</span>
<span class="sd">        Valid values are &quot;bottom_up&quot;, &quot;ols&quot;, &quot;mint_sample&quot;, &quot;custom&quot;:</span>

<span class="sd">            - &quot;bottom_up&quot;   : Sums leaf nodes. Unbiased transform that uses only the values of the leaf nodes</span>
<span class="sd">                              to propagate up the tree. Each node&#39;s value is the sum of its</span>
<span class="sd">                              corresponding leaf nodes&#39; values (a leaf node corresponds to a node T if it is</span>
<span class="sd">                              a leaf node of the subtree with T as its root, i.e. a descendant of T or T itself).</span>
<span class="sd">                              See Dangerfield and Morris 1992 &quot;Top-down or bottom-up: Aggregate versus disaggregate</span>
<span class="sd">                              extrapolations&quot; for one discussion of this method.</span>
<span class="sd">                              Depends only on the structure of the hierarchy, not on the data itself.</span>
<span class="sd">            - &quot;ols&quot;         : OLS estimate proposed by https://robjhyndman.com/papers/Hierarchical6.pdf</span>
<span class="sd">                              (Hyndman et al. 2010, &quot;Optimal combination forecasts for hierarchical time series&quot;)</span>
<span class="sd">                              Also see https://robjhyndman.com/papers/mint.pdf section 2.4.1.</span>
<span class="sd">                              (Wickramasuriya et al. 2019 &quot;Optimal forecast reconciliation for</span>
<span class="sd">                              hierarchical and grouped time series through trace minimization&quot;.)</span>
<span class="sd">                              Unbiased transform that minimizes variance of adjusted residuals,</span>
<span class="sd">                              using &quot;identity&quot; estimate of original residual variance.</span>
<span class="sd">                              Optimal if original forecast errors are uncorrelated with equal variance (unlikely).</span>
<span class="sd">                              Depends only on the structure of the hierarchy, not on the data itself.</span>
<span class="sd">            - &quot;mint_sample&quot; : Unbiased transform that minimizes variance of adjusted residuals,</span>
<span class="sd">                              using &quot;sample&quot; estimate of original residual variance.</span>
<span class="sd">                              Assumes base forecasts are unbiased.</span>
<span class="sd">                              See Wickramasuriya et al. 2019 section 2.4.4.</span>
<span class="sd">                              Depends on the structure of the hierarchy and forecast error covariances.</span>
<span class="sd">            - &quot;custom&quot;      : Optimization parameters can be set by the user. See</span>
<span class="sd">                              `greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit`</span>
<span class="sd">                              method for parameters and their default values.</span>
<span class="sd">                              Depends on the structure of the hierarchy, base forecasts, and actuals, if all terms</span>
<span class="sd">                              are included in the objective.</span>

<span class="sd">        If &quot;custom&quot;, uses the parameters passed to</span>
<span class="sd">        `greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit`</span>
<span class="sd">        to formulate the convex optimization problem.</span>

<span class="sd">        If &quot;bottom_up&quot;, &quot;ols&quot;, or &quot;mint_sample&quot;, the other fit parameters are ignored.</span>

<span class="sd">    lower_bound : `float` or None</span>
<span class="sd">        Lower bound on each entry of ``transform_matrix``.</span>
<span class="sd">        If None, no lower bound is applied.</span>
<span class="sd">    upper_bound : `float` or None</span>
<span class="sd">        Upper bound on each entry of ``transform_matrix``.</span>
<span class="sd">        If None, no upper bound is applied.</span>
<span class="sd">    unbiased : `bool`</span>
<span class="sd">        Whether the resulting transformation must be unbiased.</span>
<span class="sd">    lam_adj : `float`</span>
<span class="sd">        Weight for the adjustment penalty.</span>
<span class="sd">        The adjustment penalty is the mean squared difference</span>
<span class="sd">        between adjusted forecasts and base forecasts.</span>
<span class="sd">    lam_bias : `float`</span>
<span class="sd">        Weight for the bias penalty.</span>
<span class="sd">        The bias penalty is the mean squared difference</span>
<span class="sd">        between adjusted actuals and actuals.</span>
<span class="sd">        For an unbiased transformation (``unbiased=True``),</span>
<span class="sd">        the bias penalty is 0 so this has no effect.</span>
<span class="sd">    lam_train : `float`</span>
<span class="sd">        Weight for the training MSE penalty.</span>
<span class="sd">        The train MSE penalty measures the mean squared difference</span>
<span class="sd">        between adjusted forecasts and actuals.</span>
<span class="sd">    lam_var : `float`</span>
<span class="sd">        Weight for the variance penalty.</span>
<span class="sd">        The variance penalty measures the variance of</span>
<span class="sd">        adjusted forecast errors for an unbiased transformation.</span>
<span class="sd">        It is reported as the average of the variances across timeseries.</span>
<span class="sd">        It is based on the variance of the base forecast error</span>
<span class="sd">        variance, ``covariance``. For biased transforms,</span>
<span class="sd">        this is an underestimate of the true variance.</span>
<span class="sd">    covariance : `numpy.array` of shape (m, m), or &quot;sample&quot; or &quot;identity&quot;</span>
<span class="sd">        Variance-covariance matrix of base forecast errors. Used to</span>
<span class="sd">        compute the variance penalty.</span>

<span class="sd">            - If a `numpy.array`, row/column i corresponds to the</span>
<span class="sd">              ith column after reordering by ``order_dict``. Should</span>
<span class="sd">              be reported on the original scale of the data.</span>
<span class="sd">            - If &quot;sample&quot;, the sample covariance of residuals</span>
<span class="sd">              assuming base forecasts are unbiased.</span>
<span class="sd">              Unlike `numpy.cov`, does not mean center the residuals,</span>
<span class="sd">              and divides by ``n`` instead of ``n-1``.</span>
<span class="sd">            - If &quot;identity&quot;, the identity matrix.</span>

<span class="sd">    weight_adj : `numpy.array` or `list` [`float`] of length m or &quot;MedAPE&quot; or &quot;InverseMedAPE&quot; or None</span>
<span class="sd">        Weight for the adjustment penalty that allows a different</span>
<span class="sd">        weight per-timeseries.</span>

<span class="sd">            - If a numpy array/list, values specify the weight for each forecast</span>
<span class="sd">              after reordering by ``order_dict``.</span>
<span class="sd">            - If &quot;MedAPE&quot;, proportional to the MedAPE of the forecast.</span>
<span class="sd">            - If &quot;InverseMedAPE&quot;, proportional to 1 / MedAPE of the forecast. This can be useful</span>
<span class="sd">              to penalize adjustment to base forecasts that are already accurate.</span>
<span class="sd">            - If None, the identity matrix (equal weights).</span>

<span class="sd">    weight_bias : `numpy.array` or `list` [`float`] of length m or &quot;MedAPE&quot; or &quot;InverseMedAPE&quot; or None</span>
<span class="sd">        Weight for the bias penalty that allows a different</span>
<span class="sd">        weight per-timeseries.</span>

<span class="sd">            - If a numpy array/list, values specify the weight for each forecast</span>
<span class="sd">              after reordering by ``order_dict``.</span>
<span class="sd">            - If &quot;MedAPE&quot;, proportional to the MedAPE of the forecast. This can be useful</span>
<span class="sd">              to focus more on improving the base forecasts with high error.</span>
<span class="sd">            - If &quot;InverseMedAPE&quot;, proportional to 1 / MedAPE of the forecast.</span>
<span class="sd">            - If None, the identity matrix (equal weights).</span>

<span class="sd">        For an unbiased transformation (``unbiased=True``),</span>
<span class="sd">        the bias penalty is 0 so this has no effect.</span>

<span class="sd">    weight_train : `numpy.array` or `list` [`float`] of length m or &quot;MedAPE&quot; or &quot;InverseMedAPE&quot; or None</span>
<span class="sd">        Weight for the train MSE penalty that allows a different</span>
<span class="sd">        weight per-timeseries.</span>

<span class="sd">            - If a numpy array/list, values specify the weight for each forecast</span>
<span class="sd">              after reordering by ``order_dict``.</span>
<span class="sd">            - If &quot;MedAPE&quot;, proportional to the MedAPE of the forecast. This can be useful</span>
<span class="sd">              to focus more on improving the base forecasts with high error.</span>
<span class="sd">            - If &quot;InverseMedAPE&quot;, proportional to 1 / MedAPE of the forecast.</span>
<span class="sd">            - If None, the identity matrix (equal weights).</span>

<span class="sd">    weight_var : `numpy.array` or `list` [`float`] of length m or &quot;MedAPE&quot; or &quot;InverseMedAPE&quot; or None</span>
<span class="sd">        Weight for the variance penalty that allows a different</span>
<span class="sd">        weight per-timeseries.</span>

<span class="sd">            - If a numpy array/list, values specify the weight for each forecast</span>
<span class="sd">              after reordering by ``order_dict``.</span>
<span class="sd">            - If &quot;MedAPE&quot;, proportional to the MedAPE of the forecast. This can be useful</span>
<span class="sd">              to focus more on improving the base forecasts with high error.</span>
<span class="sd">            - If &quot;InverseMedAPE&quot;, proportional to 1 / MedAPE of the forecast.</span>
<span class="sd">            - If None, the identity matrix (equal weights).</span>

<span class="sd">    names : `pandas.Index`</span>
<span class="sd">        Names of ``forecast`` columns after reordering by ``order_dict``.</span>
<span class="sd">    tree : `greykite.algo.reconcile.hierarchical_relationship.HierarchicalRelationship` or None</span>
<span class="sd">        If ``levels`` is provided, represents the tree structure encoded by the levels.</span>
<span class="sd">        Else None.</span>
<span class="sd">    transform_variable : `cvxpy.Variable`, shape (m, m) or None</span>
<span class="sd">        Optimization variable to learn the transform matrix.</span>
<span class="sd">        None if a rule-based method is used, e.g. ``method == bottom_up``</span>
<span class="sd">    transform_matrix : `numpy.array`, shape (m, m)</span>
<span class="sd">        Transformation matrix. Same as ``transform_variable.value``, unless</span>
<span class="sd">        the solver failed the find a solution, and a backup value is used.</span>
<span class="sd">        Adjusted forecasts are computed by applying the transform from the left</span>
<span class="sd">        to reordered and transposed ``forecasts``. See ``transform`` in this class.</span>
<span class="sd">    prob : `cvxpy.Problem`</span>
<span class="sd">        Convex optimization problem.</span>
<span class="sd">    is_optimization_solution : `bool`</span>
<span class="sd">        Whether ``transform_matrix`` is a solution found by convex optimization solution.</span>
<span class="sd">        If False, then ``transform_matrix`` may be set to a backup value (bottom up transform).</span>
<span class="sd">        Check ``prob.status`` for more details about solver status.</span>
<span class="sd">    objective_fn : `callable`</span>
<span class="sd">        Evaluates the objective function for a given transform matrix and dataset.</span>
<span class="sd">        Takes ``transform_matrix, forecast_matrix (optional), actual_matrix (optional)``.</span>
<span class="sd">        Return value has same format as ``objective_fn_val``.</span>
<span class="sd">        If forecast_matrix/actual_matrix are not provided, uses the fitting datasets.</span>
<span class="sd">    objective_fn_val : `dict` [`str`, `float`]</span>
<span class="sd">        Dictionary containing the objective value, and its components,</span>
<span class="sd">        as evaluated on the training set for the identified optimal solution</span>
<span class="sd">        from convex optimization.</span>
<span class="sd">        Keys are:</span>

<span class="sd">            ``&quot;adj&quot;``    : adjustment size</span>
<span class="sd">            ``&quot;bias&quot;``   : bias of estimator</span>
<span class="sd">            ``&quot;train&quot;``  : train set MSE</span>
<span class="sd">            ``&quot;var&quot;``    : variance of unbiased estimator</span>
<span class="sd">            ``&quot;total&quot;``  : sum of the above</span>

<span class="sd">    objective_weights : `dict` [`str`, `np.array` of shape (m, m)]</span>
<span class="sd">        Weights used in the objective function, derived from</span>
<span class="sd">        ``covariance``, ``weight_*``, ``forecasts``, ``actuals``.</span>
<span class="sd">        Keys are:</span>

<span class="sd">            - weight_adj</span>
<span class="sd">            - weight_bias</span>
<span class="sd">            - weight_train</span>
<span class="sd">            - weight_var</span>
<span class="sd">            - covariance</span>

<span class="sd">    adjusted_forecasts : `pandas.DataFrame`, shape (n, m)</span>
<span class="sd">        Adjusted ``forecasts`` that satisfy the constraints.</span>
<span class="sd">    constraint_violation : `dict` [`str`, `float`]</span>
<span class="sd">        The normalized constraint violations on training set.</span>
<span class="sd">        Keys are &quot;actual&quot;, &quot;forecast&quot;, and &quot;adjusted&quot;.</span>
<span class="sd">        Root mean squared constraint violation is divided by root mean squared actual value.</span>
<span class="sd">    evaluation_df : `pandas.DataFrame`, shape (m, # metrics)</span>
<span class="sd">        DataFrame of evaluation results on training set. Rows are timeseries,</span>
<span class="sd">        columns are metrics. See ``evaluate`` in this class.</span>
<span class="sd">    figures : `dict` [`str`, `plotly.graph_objects.Figure`] or None</span>
<span class="sd">        Plotly figures to visualize evaluation results on training set.</span>
<span class="sd">        Keys are: &quot;base_adj&quot; (base vs adjusted forecast),</span>
<span class="sd">        &quot;adj_size&quot; (adjustment size %), &quot;error&quot; (% error).</span>
<span class="sd">        Each figure contains multiple subplots, one for each timeseries.</span>
<span class="sd">    forecasts_test : `pandas.DataFrame`, shape (q, m)</span>
<span class="sd">        Forecasted values to test the method.</span>
<span class="sd">        Long format where each column is a time series</span>
<span class="sd">        and each row is a time step.</span>
<span class="sd">        Must have the same column names as ``forecasts``.</span>
<span class="sd">        Can have a different number of rows (observations).</span>
<span class="sd">    actuals_test : `pandas.DataFrame`, shape (q, m)</span>
<span class="sd">        Actual values to test the method.</span>
<span class="sd">        Must have the same shape and column names as ``forecasts_test``.</span>
<span class="sd">    adjusted_forecasts_test : `pandas.DataFrame`, shape (q, m)</span>
<span class="sd">        Adjusted ``forecasts_test`` that satisfy the constraints.</span>
<span class="sd">    constraint_violation_test : `dict` [`str`, `float`]</span>
<span class="sd">        The normalized constraint violations on test set.</span>
<span class="sd">        Keys are &quot;actual&quot;, &quot;forecast&quot;, and &quot;adjusted&quot;.</span>
<span class="sd">        Root mean squared constraint violation is divided by root mean squared actual value</span>
<span class="sd">        on test set.</span>
<span class="sd">    evaluation_df_test : `pandas.DataFrame`, shape (m, # metrics)</span>
<span class="sd">        DataFrame of evaluation results on test set. Rows are timeseries,</span>
<span class="sd">        columns are metrics. See ``evaluate()`` in this class.</span>
<span class="sd">    figures_test : `dict` [`str`, `plotly.graph_objects.Figure`] or None</span>
<span class="sd">        Plotly figures to visualize evaluation results on test set.</span>
<span class="sd">        Keys are: &quot;base_adj&quot; (base vs adjusted forecast),</span>
<span class="sd">        &quot;adj_size&quot; (adjustment size %), &quot;error&quot; (% error).</span>
<span class="sd">        Each figure contains multiple subplots, one for each timeseries.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    fit : callable</span>
<span class="sd">        Fits the ``transform_matrix`` from training data.</span>
<span class="sd">    transform : callable</span>
<span class="sd">        Adjusts a forecast to satisfy additive constraints using the ``transform_matrix``.</span>
<span class="sd">    evaluate : callable</span>
<span class="sd">        Evaluates the adjustment quality by its impact to MAPE, MedAPE, and RMSE.</span>
<span class="sd">    fit_transform : callable</span>
<span class="sd">        Fits and transforms the training data.</span>
<span class="sd">    fit_transform_evaluate : callable</span>
<span class="sd">        Fits, transforms, and evaluates on training data.</span>
<span class="sd">    transform_evaluate : calllable</span>
<span class="sd">        Transforms and evaluates on a new test set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># training data and input params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actuals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># updated by `fit` if `levels` is provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_bound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_bound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unbiased</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_adj</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_bias</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_train</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_var</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_adj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_bias</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_train</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_var</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># set by `fit`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_variable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_optimization_solution</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_fn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_fn_val</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_weights</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># training data transformed result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_violation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">figures</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># test data transformed result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_test</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actuals_test</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_forecasts_test</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_violation_test</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_df_test</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">figures_test</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_form_constraints</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">transform_variable</span><span class="p">,</span>
            <span class="n">Ya</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forms the constraints for convex optimization.</span>
<span class="sd">        The following attributes should be set before calling this method:</span>

<span class="sd">            - constraint_matrix or tree (required)</span>
<span class="sd">            - unbiased                  (optional)</span>
<span class="sd">            - lower_bound               (optional)</span>
<span class="sd">            - upper_bound               (optional)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transform_variable : `cvxpy.Variable`, shape (m, m)</span>
<span class="sd">            Optimization variable to learn the transform matrix.</span>
<span class="sd">        Ya : `numpy.array`, shape (m, n) or None</span>
<span class="sd">            Actuals in wide format. Rows are timeseries, columns are timestamps.</span>
<span class="sd">            Must have the same shape as ``Yf``.</span>

<span class="sd">            Created in ``fit`` by reordering the columns of ``self.actuals``</span>
<span class="sd">            according to ``self.order_dict``, taking the transpose,</span>
<span class="sd">            and scaling to mean 1.0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constraints : `list` [`cvxpy.constraints.constraint.Constraint`]</span>
<span class="sd">            Constraints for the convex optimization problem.</span>
<span class="sd">            Requires additive consistency as specified by ``self.constraint_matrix``.</span>
<span class="sd">            If ``self.unbiased``, requires unbiasedness.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">transform_variable</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">transform_variable</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Uses tree&#39;s constraints if `tree` is provided</span>
            <span class="n">constraint_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">constraint_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">constraint_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span>

        <span class="c1"># If this holds, then the constraints are satisfied for any Yf, i.e.</span>
        <span class="c1"># constraint_matrix @ Y_{adjusted} = constraint_matrix @ transform_variable @ Yf == 0.</span>
        <span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">constraint_matrix</span> <span class="o">@</span> <span class="n">transform_variable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unbiased</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Ya</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`Ya` must be provided if `unbiased` and `tree` is None.&quot;</span><span class="p">)</span>
                <span class="c1"># Since we don&#39;t know the structure, we use an</span>
                <span class="c1"># empirical check for unbiasedness.</span>
                <span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">transform_variable</span> <span class="o">@</span> <span class="n">Ya</span> <span class="o">==</span> <span class="n">Ya</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Let there be `ell` leaf forecasts.</span>
                <span class="c1"># S is m x ell, summing matrix against leaf nodes. Y_{actual} = S @ Y_{leaf}</span>
                <span class="c1"># See sec. 2.1, Wickramasuriya et al. 2019 &quot;Optimal forecast reconciliation</span>
                <span class="c1"># for hierarchical and grouped time series through trace minimization&quot;.</span>
                <span class="c1"># transform_variable T is defined as S @ P. T is unbiased if T @ S = S @ P @ S = S.</span>
                <span class="c1"># (i.e. Forecasts that satisfy hierarchical constraints remain consistent)</span>
                <span class="n">sum_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">sum_matrix</span>
                <span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">transform_variable</span> <span class="o">@</span> <span class="n">sum_matrix</span> <span class="o">==</span> <span class="n">sum_matrix</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">Ya</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">violation_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">constraint_matrix</span> <span class="o">@</span> <span class="n">Ya</span><span class="p">)))</span>
            <span class="n">observation_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">Ya</span><span class="p">)))</span>
            <span class="n">relative_error</span> <span class="o">=</span> <span class="n">violation_magnitude</span> <span class="o">/</span> <span class="n">observation_magnitude</span>
            <span class="k">if</span> <span class="n">relative_error</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Actuals do not satisfy the constraints! Relative error is </span><span class="si">{</span><span class="n">relative_error</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constraints</span>

    <span class="k">def</span> <span class="nf">_form_objective</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">Yf</span><span class="p">,</span>
            <span class="n">Ya</span><span class="p">,</span>
            <span class="n">transform_variable</span><span class="p">,</span>
            <span class="n">covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forms the objective for convex optimization.</span>

<span class="sd">        The objective is a sum of four types of errors::</span>

<span class="sd">            obj = adj + bias + train + var</span>

<span class="sd">        Where</span>

<span class="sd">            ``&quot;adj&quot;`` : MSE of adjusted forecasts vs base forecasts (adjustment size)</span>
<span class="sd">            ``&quot;bias&quot;`` : MSE of adjusted actuals vs actuals (squared bias)</span>
<span class="sd">            ``&quot;train&quot;`` : MSE of adjusted forecasts vs actuals (training error)</span>
<span class="sd">            ``&quot;var&quot;`` : estimated variance of adjusted forecast residuals (variance)</span>

<span class="sd">        Relative importance of these errors is specified by ``lam_*``.</span>
<span class="sd">        Relative importance of forecasts is specified by ``weight_*``.</span>

<span class="sd">        The following attributes should be set before calling this method:</span>

<span class="sd">            - lam_adj       (optional)</span>
<span class="sd">            - lam_bias      (optional)</span>
<span class="sd">            - lam_train     (optional)</span>
<span class="sd">            - lam_var       (optional)</span>
<span class="sd">            - weight_adj    (optional)</span>
<span class="sd">            - weight_bias   (optional)</span>
<span class="sd">            - weight_train  (optional)</span>
<span class="sd">            - weight_var    (optional)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Yf : `numpy.array`, shape (m, n)</span>
<span class="sd">             Forecasts in wide format. Rows are timeseries, columns are timestamps.</span>
<span class="sd">             The goal is to adjust these values to satisfy the constraints.</span>

<span class="sd">             Created in ``fit`` by reordering the columns of ``self.forecasts``</span>
<span class="sd">             according to ``self.order_dict`` and taking the transpose,</span>
<span class="sd">             and scaling down by the mean of the actuals.</span>
<span class="sd">        Ya : `numpy.array`, shape (m, n)</span>
<span class="sd">             Actuals in wide format. Rows are timeseries, columns are timestamps.</span>
<span class="sd">             Must have the same shape as ``Yf``.</span>

<span class="sd">             Created in ``fit`` by reordering the columns of ``self.actuals``</span>
<span class="sd">             according to ``self.order_dict``, taking the transpose,</span>
<span class="sd">             and scaling to mean 1.0.</span>
<span class="sd">        transform_variable : `cvxpy.Variable`, shape (m, m)</span>
<span class="sd">            Optimization variable. Square matrix with size matching the rows in ``Yf``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : `cvxpy.problems.objective.Minimize`</span>
<span class="sd">            Objective function to minimize.</span>

<span class="sd">        Updates ``self.objective_weights`` to contain the</span>
<span class="sd">        matrices used in the objective.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_forecasts</span> <span class="o">=</span> <span class="n">Yf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Computes default weights proportional to MedAPE and inverse MedAPE of the timeseries</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Ya</span> <span class="o">-</span> <span class="n">Yf</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Ya</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># MedAPE</span>
        <span class="n">weight_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="c1"># Inverse of MedAPE</span>
        <span class="n">inv_err</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">inv_err</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inv_err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">inv_err</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inv_err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)])</span>  <span class="c1"># Sets zeros to minimum value above zero</span>
        <span class="n">inv_err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">inv_err</span>
        <span class="n">weight_inverr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_err</span><span class="p">)</span>

        <span class="n">default_weights</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;MedAPE&quot;</span><span class="p">:</span> <span class="n">weight_err</span><span class="p">,</span>
            <span class="s2">&quot;InverseMedAPE&quot;</span><span class="p">:</span> <span class="n">weight_inverr</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">weight_adj</span> <span class="o">=</span> <span class="n">get_weight_matrix</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_adj</span><span class="p">,</span> <span class="n">n_forecasts</span><span class="o">=</span><span class="n">n_forecasts</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight_adj&quot;</span><span class="p">,</span> <span class="n">default_weights</span><span class="o">=</span><span class="n">default_weights</span><span class="p">)</span>
        <span class="n">weight_bias</span> <span class="o">=</span> <span class="n">get_weight_matrix</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_bias</span><span class="p">,</span> <span class="n">n_forecasts</span><span class="o">=</span><span class="n">n_forecasts</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight_bias&quot;</span><span class="p">,</span> <span class="n">default_weights</span><span class="o">=</span><span class="n">default_weights</span><span class="p">)</span>
        <span class="n">weight_train</span> <span class="o">=</span> <span class="n">get_weight_matrix</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_train</span><span class="p">,</span> <span class="n">n_forecasts</span><span class="o">=</span><span class="n">n_forecasts</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight_train&quot;</span><span class="p">,</span> <span class="n">default_weights</span><span class="o">=</span><span class="n">default_weights</span><span class="p">)</span>
        <span class="n">weight_var</span> <span class="o">=</span> <span class="n">get_weight_matrix</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_var</span><span class="p">,</span> <span class="n">n_forecasts</span><span class="o">=</span><span class="n">n_forecasts</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight_var&quot;</span><span class="p">,</span> <span class="n">default_weights</span><span class="o">=</span><span class="n">default_weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covariance</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">covariance</span> <span class="o">==</span> <span class="s2">&quot;identity&quot;</span><span class="p">:</span>
                <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_forecasts</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">covariance</span> <span class="o">==</span> <span class="s2">&quot;sample&quot;</span><span class="p">:</span>
                <span class="c1"># The sample covariance matrix estimate of h-step ahead forecast errors.</span>
                <span class="c1"># Assumes the base forecasts are unbiased and the forecast horizon (h) is fixed.</span>
                <span class="c1"># Pass `covariance` to `fit` if a better estimate is available.</span>
                <span class="n">residuals</span> <span class="o">=</span> <span class="n">Ya</span> <span class="o">-</span> <span class="n">Yf</span>
                <span class="n">covariance</span> <span class="o">=</span> <span class="n">residuals</span> <span class="o">@</span> <span class="n">residuals</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">residuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`covariance` not recognized. Provide a valid string in [&#39;identity&#39;, &#39;sample&#39;] or a matrix.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">objective_weights</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;weight_adj&quot;</span><span class="p">:</span> <span class="n">weight_adj</span><span class="p">,</span>
            <span class="s2">&quot;weight_bias&quot;</span><span class="p">:</span> <span class="n">weight_bias</span><span class="p">,</span>
            <span class="s2">&quot;weight_train&quot;</span><span class="p">:</span> <span class="n">weight_train</span><span class="p">,</span>
            <span class="s2">&quot;weight_var&quot;</span><span class="p">:</span> <span class="n">weight_var</span><span class="p">,</span>
            <span class="s2">&quot;covariance&quot;</span><span class="p">:</span> <span class="n">covariance</span>
        <span class="p">}</span>

        <span class="c1"># Mean squared adjustment size (on observed forecasts distribution, weighted by ``weight_adj``)</span>
        <span class="n">err_adj</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum_squares</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_adj</span> <span class="o">@</span> <span class="p">(</span><span class="n">transform_variable</span> <span class="o">@</span> <span class="n">Yf</span> <span class="o">-</span> <span class="n">Yf</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">Yf</span><span class="p">)</span>
        <span class="c1"># Mean squared bias (on observed actuals distribution, weighted by ``weight_bias``)</span>
        <span class="n">err_bias</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum_squares</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_bias</span> <span class="o">@</span> <span class="p">(</span><span class="n">transform_variable</span> <span class="o">@</span> <span class="n">Ya</span> <span class="o">-</span> <span class="n">Ya</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">Ya</span><span class="p">)</span>
        <span class="c1"># Mean squared train error (proxy for bias^2 + variance) (on observed distribution, weighted by ``weight_train``)</span>
        <span class="n">err_train</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum_squares</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_train</span> <span class="o">@</span> <span class="p">(</span><span class="n">transform_variable</span> <span class="o">@</span> <span class="n">Yf</span> <span class="o">-</span> <span class="n">Ya</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">Yf</span><span class="p">)</span>
        <span class="c1"># Variance of an unbiased estimator.</span>
        <span class="c1"># We can&#39;t optimize the trace directly, as specified by Wickramasuriya et al. 2019.</span>
        <span class="c1">#   err_var = cp.trace(weight_var @ transform_variable @ covariance @ transform_variable.T) / n_forecasts if covariance is not None else 0.0</span>
        <span class="c1">#   &quot;Problem does not follow DCP rules. Specifically:&quot;</span>
        <span class="c1">#   &quot;The objective is not DCP.&quot;</span>
        <span class="c1"># Because `covariance` is symmetric and PSD, we can rewrite the trace as a squared Frobenius norm.</span>
        <span class="c1">#   tr(T covariance T&#39;) = ||T sqrt(covariance)||_{F]^{2}</span>
        <span class="c1"># Note that `weight_var` has a different interpretation than when</span>
        <span class="c1"># inside the trace. It matches the interpretation of the other weights.</span>
        <span class="c1"># Divides by `n_forecasts` for mean adjusted forecast error variance for a timeseries</span>
        <span class="c1">#   (the trace is the sum across timeseries).</span>
        <span class="n">err_var</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum_squares</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_var</span> <span class="o">@</span> <span class="n">transform_variable</span> <span class="o">@</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">covariance</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_forecasts</span> <span class="k">if</span> <span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.0</span>

        <span class="n">lams</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lam_adj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_var</span><span class="p">]</span>
        <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">err_adj</span><span class="p">,</span> <span class="n">err_bias</span><span class="p">,</span> <span class="n">err_train</span><span class="p">,</span> <span class="n">err_var</span><span class="p">]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">scalar_product</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">errs</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">objective_fn</span><span class="p">(</span><span class="n">transform_matrix</span><span class="p">,</span> <span class="n">forecast_matrix</span><span class="o">=</span><span class="n">Yf</span><span class="p">,</span> <span class="n">actual_matrix</span><span class="o">=</span><span class="n">Ya</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Evaluates the objective function for a given transform matrix and dataset.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            transform_matrix : `numpy.array`, shape (m, m)</span>
<span class="sd">                Applied to forecast and actual matrices from the left to get the transformed result.</span>
<span class="sd">            forecast_matrix : `numpy.array`, shape (m, n), optional</span>
<span class="sd">                The forecasts in wide array format.</span>
<span class="sd">                Must have the same shape as ``actual_matrix``.</span>
<span class="sd">                If not provided, uses the forecasts for fitting.</span>
<span class="sd">            actual_matrix : `numpy.array`, shape (m, n), optional</span>
<span class="sd">                The actuals in wide array format.</span>
<span class="sd">                Must have the same number of rows as ``transform_matrix``.</span>
<span class="sd">                If not provided, uses the actuals for fitting.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            objective_value : `dict` [`str`, `float`] or None</span>
<span class="sd">                Dictionary containing the objective value, and its components.</span>
<span class="sd">                Keys are:</span>

<span class="sd">                    ``&quot;adj&quot;``    : adjustment size</span>
<span class="sd">                    ``&quot;bias&quot;``   : bias of estimator</span>
<span class="sd">                    ``&quot;train&quot;``  : train set MSE</span>
<span class="sd">                    ``&quot;var&quot;``    : variance of unbiased estimator</span>
<span class="sd">                    ``&quot;total&quot;``  : sum of the above</span>

<span class="sd">                Returns None if ``transform_matrix`` is None.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">transform_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># NB: Frobenius norm is the default norm</span>
            <span class="n">np_err_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_adj</span> <span class="o">@</span> <span class="p">(</span><span class="n">transform_matrix</span> <span class="o">@</span> <span class="n">forecast_matrix</span> <span class="o">-</span> <span class="n">forecast_matrix</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">forecast_matrix</span><span class="p">)</span>
            <span class="n">np_err_bias</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_bias</span> <span class="o">@</span> <span class="p">(</span><span class="n">transform_matrix</span> <span class="o">@</span> <span class="n">actual_matrix</span> <span class="o">-</span> <span class="n">actual_matrix</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">actual_matrix</span><span class="p">)</span>
            <span class="n">np_err_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_train</span> <span class="o">@</span> <span class="p">(</span><span class="n">transform_matrix</span> <span class="o">@</span> <span class="n">forecast_matrix</span> <span class="o">-</span> <span class="n">actual_matrix</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">actual_matrix</span><span class="p">)</span>
            <span class="n">np_err_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">weight_var</span> <span class="o">@</span> <span class="n">transform_matrix</span> <span class="o">@</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">covariance</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">n_forecasts</span> <span class="k">if</span> <span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="n">np_errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np_err_adj</span><span class="p">,</span> <span class="n">np_err_bias</span><span class="p">,</span> <span class="n">np_err_train</span><span class="p">,</span> <span class="n">np_err_var</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;adj&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_adj</span> <span class="o">*</span> <span class="n">np_err_adj</span><span class="p">,</span>        <span class="c1"># adjustment size</span>
                <span class="s2">&quot;bias&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_bias</span> <span class="o">*</span> <span class="n">np_err_bias</span><span class="p">,</span>     <span class="c1"># bias^2 of estimator</span>
                <span class="s2">&quot;train&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_train</span> <span class="o">*</span> <span class="n">np_err_train</span><span class="p">,</span>  <span class="c1"># train error (bias^2 + variance)</span>
                <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_var</span> <span class="o">*</span> <span class="n">np_err_var</span><span class="p">,</span>        <span class="c1"># variance of an *unbiased* estimator</span>
                <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">np_errs</span><span class="p">)</span>           <span class="c1"># Sum of the above</span>
            <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_fn</span> <span class="o">=</span> <span class="n">objective_fn</span>

        <span class="k">return</span> <span class="n">obj</span>

<div class="viewcode-block" id="ReconcileAdditiveForecasts.fit"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit">[docs]</a>    <span class="nd">@apply_method_defaults</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">forecasts</span><span class="p">,</span>
            <span class="n">actuals</span><span class="p">,</span>
            <span class="n">order_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">DEFAULT_METHOD</span><span class="p">,</span>
            <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">constraint_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">lower_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">upper_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">lam_adj</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">lam_bias</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">lam_train</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">lam_var</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">covariance</span><span class="o">=</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span>
            <span class="n">weight_adj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_train</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_var</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">solver_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fits the ``transform_matrix`` based on input data, constraint, and objective function.</span>

<span class="sd">        Sets the attributes between ``forecasts`` and ``objective_weights`` as noted</span>
<span class="sd">        in the class description, inclusive, including ``transform_matrix``, ``transform_variable``,</span>
<span class="sd">        ``prob``, ``objective_fn_val``.</span>

<span class="sd">        If method != &quot;bottom_up&quot; and there is no solution, gives a warning and</span>
<span class="sd">        ``self.is_optimization_solution`` is set to False. Uses &quot;bottom_up&quot; solution</span>
<span class="sd">        as fallback approach if ``levels`` is provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forecasts : `pandas.DataFrame`, shape (n, m)</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        actuals : `pandas.DataFrame`, shape (n, m)</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        order_dict : `dict` [`str`, `float`] or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        method : `str`, default `~greykite.algo.reconcile.convex.reconcile_forecasts.DEFAULT_METHOD`</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">            If provided, the parameters from ``lower_bound`` to ``weight_var`` below are ignored.</span>
<span class="sd">        levels : `list` [`list` [`int`]] or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        constraint_matrix : `numpy.array`, shape (c, m) or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        lower_bound : `float` or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        upper_bound : `float` or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        unbiased : `bool`, default True</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        lam_adj : `float`, default 1.0</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        lam_bias : `float`, default 1.0</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        lam_train : `float`, default 1.0</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        lam_var : `float`, default 1.0</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        covariance : `numpy.array` of shape (m, m), or &quot;sample&quot; or &quot;identity&quot;, default &quot;sample&quot;</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        weight_adj : `numpy.array` or `list` [`float`] of length m or &quot;MedAPE&quot; or &quot;InverseMedAPE&quot; or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        weight_bias : `numpy.array` or `list` [`float`] of length m or &quot;MedAPE&quot; or &quot;InverseMedAPE&quot; or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        weight_train : `numpy.array` or `list` [`float`] of length m or &quot;MedAPE&quot; or &quot;InverseMedAPE&quot; or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        weight_var : `numpy.array` or `list` [`float`] of length m or &quot;MedAPE&quot; or &quot;InverseMedAPE&quot; or None, default None</span>
<span class="sd">            See attributes of `~greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts`.</span>
<span class="sd">        solver_kwargs : dict</span>
<span class="sd">            Specify the CVXPY solver and parameters. E.g. dict(verbose=True).</span>
<span class="sd">            See https://www.cvxpy.org/tutorial/advanced/index.html#setting-solver-options.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transform_matrix : `numpy.array`, shape (m, m)</span>
<span class="sd">            Transformation matrix. Same as ``transform_variable.value``, unless</span>
<span class="sd">            the solver failed the find a solution, and a backup value is used.</span>
<span class="sd">            Adjusted forecasts are computed by applying the transform from the left</span>
<span class="sd">            to reordered and transposed ``forecasts``. See ``transform()`` in this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">reorder_columns</span><span class="p">(</span><span class="n">forecasts</span><span class="p">,</span> <span class="n">order_dict</span><span class="o">=</span><span class="n">order_dict</span><span class="p">)</span>  <span class="c1"># Returns a copy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actuals</span> <span class="o">=</span> <span class="n">reorder_columns</span><span class="p">(</span><span class="n">actuals</span><span class="p">,</span> <span class="n">order_dict</span><span class="o">=</span><span class="n">order_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_dict</span> <span class="o">=</span> <span class="n">order_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span> <span class="o">=</span> <span class="n">constraint_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_bound</span> <span class="o">=</span> <span class="n">lower_bound</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_bound</span> <span class="o">=</span> <span class="n">upper_bound</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unbiased</span> <span class="o">=</span> <span class="n">unbiased</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="n">covariance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_adj</span> <span class="o">=</span> <span class="n">lam_adj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_bias</span> <span class="o">=</span> <span class="n">lam_bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_train</span> <span class="o">=</span> <span class="n">lam_train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_var</span> <span class="o">=</span> <span class="n">lam_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_adj</span> <span class="o">=</span> <span class="n">weight_adj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_bias</span> <span class="o">=</span> <span class="n">weight_bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_train</span> <span class="o">=</span> <span class="n">weight_train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_var</span> <span class="o">=</span> <span class="n">weight_var</span>

        <span class="k">if</span> <span class="n">constraint_matrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either `constraint_matrix` or `levels` must be provided.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">constraint_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">levels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of `constraint_matrix` and `levels` can be provided.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bottom_up&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide `levels` if `method=&#39;bottom_up&#39;`.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lower_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lower_bound</span> <span class="o">&gt;</span> <span class="n">upper_bound</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`lower_bound` </span><span class="si">{</span><span class="n">lower_bound</span><span class="si">}</span><span class="s2"> should not be greater than `upper_bound` </span><span class="si">{</span><span class="n">upper_bound</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unbiased</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covariance</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lam_var</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variance of residuals is underestimated if the estimator is biased.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">levels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">HierarchicalRelationship</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">constraint_matrix</span>  <span class="c1"># Overwrites ``constraint_matrix`` if ``levels`` is provided</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actuals</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forecast shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match actuals shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">actuals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The number of forecasts </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> does not match &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;the number of columns in `constraint_matrix` </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Make sure `levels` or `constraint_matrix` matches the data.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bottom_up&quot;</span><span class="p">:</span>
            <span class="c1"># Uses bottom-up method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">bottom_up_transform</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Solves convex optimization problem to find transformation</span>
            <span class="c1"># Selects and reorders columns before matrix operations in constraint and objective</span>
            <span class="n">Yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># rows are forecasts (wide-format)</span>
            <span class="n">Ya</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actuals</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># For numerical stability, scale units so that actuals have mean 1 before fitting.</span>
            <span class="c1"># The solution should be scale invariant.</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">Ya</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">Yf</span> <span class="o">/=</span> <span class="n">scale</span>
            <span class="n">Ya</span> <span class="o">/=</span> <span class="n">scale</span>
            <span class="k">if</span> <span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covariance</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">covariance</span> <span class="o">=</span> <span class="n">covariance</span> <span class="o">/</span> <span class="n">scale</span><span class="o">**</span><span class="mi">2</span>

            <span class="c1"># Creates a matrix optimization variable.</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">Yf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">transform_variable</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>  <span class="c1"># Linear transform matrix. Y_{adjusted} = transform_variable @ Yf</span>

            <span class="c1"># Creates constraints.</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_constraints</span><span class="p">(</span>
                <span class="n">transform_variable</span><span class="o">=</span><span class="n">transform_variable</span><span class="p">,</span>
                <span class="n">Ya</span><span class="o">=</span><span class="n">Ya</span><span class="p">)</span>

            <span class="c1"># Forms objective.</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_objective</span><span class="p">(</span>
                <span class="n">Yf</span><span class="o">=</span><span class="n">Yf</span><span class="p">,</span>
                <span class="n">Ya</span><span class="o">=</span><span class="n">Ya</span><span class="p">,</span>
                <span class="n">transform_variable</span><span class="o">=</span><span class="n">transform_variable</span><span class="p">,</span>
                <span class="n">covariance</span><span class="o">=</span><span class="n">covariance</span><span class="p">)</span>

            <span class="c1"># Forms and solves problem.</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">**</span><span class="n">solver_kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">cp</span><span class="o">.</span><span class="n">SolverError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">transform_variable</span> <span class="o">=</span> <span class="n">transform_variable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span> <span class="o">=</span> <span class="n">transform_variable</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solver status: </span><span class="si">{</span><span class="n">prob</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solver optimal value: </span><span class="si">{</span><span class="n">prob</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adjustment matrix:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># No optimization solution is found.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_optimization_solution</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to find a solution. Falling back to bottom-up method.&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">bottom_up_transform</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to find a solution. Try setting CVXPY solver parameters, changing the &quot;</span>
                                  <span class="s2">&quot;constraints, or changing the objective weights&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_optimization_solution</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_fn_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span></div>

<div class="viewcode-block" id="ReconcileAdditiveForecasts.transform"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forecasts_test</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transforms the provided forecasts using the</span>
<span class="sd">        fitted ``self.transform_matrix``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forecasts_test : `pandas.DataFrame`, shape (r, m) or None</span>
<span class="sd">            Forecasted values to transform.</span>
<span class="sd">            Must have the same columns as ``self.forecasts``.</span>
<span class="sd">            If None, uses ``self.forecasts``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjusted_forecasts : `pandas.DataFrame`, shape (r, m)</span>
<span class="sd">            Adjusted forecasts that satisfy additive constraints.</span>
<span class="sd">            Columns are reordered according to ``self.order_dict``.</span>

<span class="sd">        If ``forecasts`` is None, results are stored to ``self.adjusted_forecasts``.</span>
<span class="sd">        Else, results are stored to ``self.adjusted_forecasts_test``, and the</span>
<span class="sd">        provided ``forecasts_test`` to ``self.forecasts_test``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFittedError</span><span class="p">(</span><span class="s2">&quot;Must call `fit` first.&quot;</span><span class="p">)</span>

        <span class="n">is_train</span> <span class="o">=</span> <span class="n">forecasts_test</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">is_train</span><span class="p">:</span>
            <span class="n">forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">forecasts</span> <span class="o">=</span> <span class="n">forecasts_test</span>

        <span class="n">forecasts</span> <span class="o">=</span> <span class="n">reorder_columns</span><span class="p">(</span><span class="n">forecasts</span><span class="p">,</span> <span class="n">order_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order_dict</span><span class="p">)</span>  <span class="c1"># Returns a copy</span>
        <span class="n">Yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">forecasts</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Converts to wide format for transform</span>
        <span class="n">adjusted_forecasts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span> <span class="o">@</span> <span class="n">Yf</span><span class="p">),</span>  <span class="c1"># Converts back to long format</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">forecasts</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">forecasts</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_train</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_forecasts</span> <span class="o">=</span> <span class="n">adjusted_forecasts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_test</span> <span class="o">=</span> <span class="n">forecasts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_forecasts_test</span> <span class="o">=</span> <span class="n">adjusted_forecasts</span>

        <span class="k">return</span> <span class="n">adjusted_forecasts</span></div>

<div class="viewcode-block" id="ReconcileAdditiveForecasts.evaluate"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_train</span><span class="p">,</span> <span class="n">actuals_test</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ipython_display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_num_cols</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluates the adjustment quality. Computes the following metrics for each</span>
<span class="sd">        of the `m` timeseries:</span>

<span class="sd">             &quot;Base MAPE&quot;        : MAPE of base forecasts</span>
<span class="sd">             &quot;Base MedAPE&quot;      : MedAPE of base forecasts</span>
<span class="sd">             &quot;Base RMSE&quot;        : RMSE of base forecasts</span>
<span class="sd">             &quot;Adjusted MAPE&quot;    : MAPE of adjusted forecasts</span>
<span class="sd">             &quot;Adjusted MedAPE&quot;  : MedAPE of adjusted forecasts</span>
<span class="sd">             &quot;Adjusted RMSE&quot;    : RMSE of adjusted forecasts</span>
<span class="sd">             &quot;RMSE % change&quot;    : (Adjusted RMSE) / (Base RMSE) - 1</span>
<span class="sd">             &quot;MAPE pp change&quot;   : (Adjusted MAPE) - (Base MAPE)</span>
<span class="sd">             &quot;MedAPE pp change&quot; : (Adjusted MedAPE) - (Base MedAPE)</span>

<span class="sd">        &quot;pp change&quot; refers to percentage point change (difference in %).</span>

<span class="sd">        Must call ``fit`` and ``transform`` before calling this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        is_train : `bool`</span>
<span class="sd">            Whether to evaluate on training set or test set.</span>
<span class="sd">            If True, evaluates training adjustment quality.</span>
<span class="sd">            Else, evaluates test adjustment quality. In this</span>
<span class="sd">            case, ``actuals_test`` must be provided.</span>
<span class="sd">        actuals_test :  `pandas.DataFrame`</span>
<span class="sd">            Actual values on test set, required if ``is_train==False``.</span>
<span class="sd">            Must have the same shape as the forecasts passed to</span>
<span class="sd">            ``transform()``, i.e. ``self.forecasts_test.shape``.</span>
<span class="sd">        ipython_display : `bool`, default False</span>
<span class="sd">            Whether to display the evaluation statistics.</span>
<span class="sd">        plot : `bool`, default False</span>
<span class="sd">            Whether to display the evaluation plots.</span>
<span class="sd">        plot_num_cols : `int`, default 3</span>
<span class="sd">            Number of columns in the plot.</span>
<span class="sd">            This is the number of timeseries to plot in each row.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        evaluation_result : `dict` [`str`, `dict`, or `pandas.DataFrame`]</span>

<span class="sd">            - ``&quot;constraint_violation&quot;`` : `dict` [`str`, `float`]</span>
<span class="sd">                The normalized constraint violations.</span>
<span class="sd">                Keys are &quot;actual&quot;, &quot;forecast&quot;, and &quot;adjusted&quot;.</span>
<span class="sd">                The value is root mean squared constraint violation divided</span>
<span class="sd">                by root mean squared actual value. Constraint violation of</span>
<span class="sd">                actuals should be close to 0.</span>
<span class="sd">            - ``&quot;evaluation_df&quot;`` : `pandas.DataFrame`, shape (m, # metrics)</span>
<span class="sd">                Evaluation results. DataFrame with one row for each timeseries,</span>
<span class="sd">                and a column for each metric listed above.</span>
<span class="sd">            - ``&quot;figures&quot;`` : `dict` [`str`, `plotly.graph_objects.Figure`]</span>
<span class="sd">                Plotly figures to visualize evaluation results.</span>
<span class="sd">                Keys are: &quot;base_adj&quot; (base vs adjusted forecast),</span>
<span class="sd">                &quot;adj_size&quot; (adjustment size %), &quot;error&quot; (% error).</span>
<span class="sd">                Each figure contains multiple subplots, one for each timeseries.</span>

<span class="sd">        If ``is_train``, results are stored to ``self.constraint_violation``,  ``self.evaluation_df``.</span>
<span class="sd">        Otherwise, they are stored to ``self.constraint_violation_test``, ``self.evaluation_df_test``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_train</span><span class="p">:</span>
            <span class="n">forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span>
            <span class="n">actuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actuals</span>
            <span class="n">adjusted_forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_forecasts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">actuals_test</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`actuals_test` must be provided to evaluate on test set&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actuals_test</span> <span class="o">=</span> <span class="n">actuals_test</span>
            <span class="n">forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_test</span>
            <span class="n">actuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actuals_test</span>
            <span class="n">adjusted_forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_forecasts_test</span>

        <span class="n">forecasts</span> <span class="o">=</span> <span class="n">reorder_columns</span><span class="p">(</span><span class="n">forecasts</span><span class="p">,</span> <span class="n">order_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order_dict</span><span class="p">)</span>
        <span class="n">actuals</span> <span class="o">=</span> <span class="n">reorder_columns</span><span class="p">(</span><span class="n">actuals</span><span class="p">,</span> <span class="n">order_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order_dict</span><span class="p">)</span>
        <span class="n">forecasts_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">forecasts</span><span class="p">)</span>  <span class="c1"># rows are dates (long-format), better for plotting</span>
        <span class="n">actuals_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">actuals</span><span class="p">)</span>
        <span class="n">adjusted_forecasts_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">adjusted_forecasts</span><span class="p">)</span>

        <span class="c1"># Constraint violation</span>
        <span class="n">observation_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">actuals_arr</span><span class="p">)))</span>
        <span class="n">constraint_violation</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;adjusted&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span> <span class="o">@</span> <span class="n">adjusted_forecasts_arr</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="o">/</span> <span class="n">observation_magnitude</span><span class="p">,</span>
            <span class="s2">&quot;forecast&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span> <span class="o">@</span> <span class="n">forecasts_arr</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="o">/</span> <span class="n">observation_magnitude</span><span class="p">,</span>
            <span class="s2">&quot;actual&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_matrix</span> <span class="o">@</span> <span class="n">actuals_arr</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="o">/</span> <span class="n">observation_magnitude</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Adjusted forecast and original forecast error</span>
        <span class="n">evaluation_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s2">&quot;Adjusted MAPE&quot;</span><span class="p">:</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">adjusted_forecasts_arr</span> <span class="o">-</span> <span class="n">actuals_arr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">actuals_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;Base MAPE&quot;</span><span class="p">:</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">forecasts_arr</span> <span class="o">-</span> <span class="n">actuals_arr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">actuals_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;Adjusted MedAPE&quot;</span><span class="p">:</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">adjusted_forecasts_arr</span> <span class="o">-</span> <span class="n">actuals_arr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">actuals_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;Base MedAPE&quot;</span><span class="p">:</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">forecasts_arr</span> <span class="o">-</span> <span class="n">actuals_arr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">actuals_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;Adjusted RMSE&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">actuals_arr</span> <span class="o">-</span> <span class="n">adjusted_forecasts_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
            <span class="s2">&quot;Base RMSE&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">actuals_arr</span> <span class="o">-</span> <span class="n">forecasts_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="n">actuals</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;RMSE </span><span class="si">% c</span><span class="s2">hange&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;Adjusted RMSE&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;Base RMSE&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;MAPE pp change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;Adjusted MAPE&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;Base MAPE&quot;</span><span class="p">]</span>
        <span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;MedAPE pp change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;Adjusted MedAPE&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">evaluation_df</span><span class="p">[</span><span class="s2">&quot;Base MedAPE&quot;</span><span class="p">]</span>
        <span class="n">column_order</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;MAPE pp change&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MedAPE pp change&quot;</span><span class="p">,</span>
            <span class="s2">&quot;RMSE </span><span class="si">% c</span><span class="s2">hange&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Base MAPE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Adjusted MAPE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Base MedAPE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Adjusted MedAPE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Base RMSE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Adjusted RMSE&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">evaluation_df</span> <span class="o">=</span> <span class="n">evaluation_df</span><span class="p">[</span><span class="n">column_order</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ipython_display</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;IPython.core&quot;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
                <span class="n">ICD</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">evaluation_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">evaluation_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Diagnostic plots to see the adjustment.</span>
        <span class="n">figures</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">forecasts</span><span class="o">.</span><span class="n">index</span>
        <span class="n">blue</span> <span class="o">=</span> <span class="s2">&quot;#007bd2&quot;</span>  <span class="c1"># blue for base forecasts</span>
        <span class="n">orange</span> <span class="o">=</span> <span class="s2">&quot;#ff893a&quot;</span>  <span class="c1"># orange for adjusted forecasts</span>

        <span class="c1"># Plots the adjusted vs base forecasts on original scale</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">TraceInfo</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">forecasts</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">blue</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">,</span> <span class="n">legendgroup</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">),</span>
            <span class="n">TraceInfo</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">adjusted_forecasts</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">orange</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;adjusted&quot;</span><span class="p">,</span> <span class="n">legendgroup</span><span class="o">=</span><span class="s2">&quot;adjusted&quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">evaluation_plot</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">traces</span><span class="o">=</span><span class="n">traces</span><span class="p">,</span>
            <span class="n">num_cols</span><span class="o">=</span><span class="n">plot_num_cols</span><span class="p">,</span>
            <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Base vs Adjusted Forecast&quot;</span><span class="p">,</span>
            <span class="n">hline</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">figures</span><span class="p">[</span><span class="s2">&quot;base_adj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>

        <span class="c1"># Plots the adjustment size</span>
        <span class="n">adjustment_size</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">adjusted_forecasts</span> <span class="o">/</span> <span class="n">forecasts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">TraceInfo</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">adjustment_size</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;sandybrown&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">legendgroup</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">evaluation_plot</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">traces</span><span class="o">=</span><span class="n">traces</span><span class="p">,</span>
            <span class="n">num_cols</span><span class="o">=</span><span class="n">plot_num_cols</span><span class="p">,</span>
            <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">% a</span><span class="s2">dj.&quot;</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Adjustment Size (%)&quot;</span><span class="p">,</span>
            <span class="n">hline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># includes a reference line for 0% adjustment</span>
        <span class="n">figures</span><span class="p">[</span><span class="s2">&quot;adj_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>

        <span class="c1"># Plots the change in % error</span>
        <span class="n">error_adj</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">adjusted_forecasts</span> <span class="o">/</span> <span class="n">actuals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">error_base</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">forecasts</span> <span class="o">/</span> <span class="n">actuals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">TraceInfo</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">error_base</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">blue</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">,</span> <span class="n">legendgroup</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">),</span>
            <span class="n">TraceInfo</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">error_adj</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">orange</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;adjusted&quot;</span><span class="p">,</span> <span class="n">legendgroup</span><span class="o">=</span><span class="s2">&quot;adjusted&quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">evaluation_plot</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">traces</span><span class="o">=</span><span class="n">traces</span><span class="p">,</span>
            <span class="n">num_cols</span><span class="o">=</span><span class="n">plot_num_cols</span><span class="p">,</span>
            <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">% e</span><span class="s2">rror&quot;</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Forecast Error (%)&quot;</span><span class="p">,</span>
            <span class="n">hline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># includes a reference line for 0% error</span>
        <span class="n">figures</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plotly</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figures</span><span class="p">[</span><span class="s2">&quot;base_adj&quot;</span><span class="p">])</span>
            <span class="n">plotly</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figures</span><span class="p">[</span><span class="s2">&quot;adj_size&quot;</span><span class="p">])</span>
            <span class="n">plotly</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figures</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">is_train</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constraint_violation</span> <span class="o">=</span> <span class="n">constraint_violation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_df</span> <span class="o">=</span> <span class="n">evaluation_df</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">figures</span> <span class="o">=</span> <span class="n">figures</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constraint_violation_test</span> <span class="o">=</span> <span class="n">constraint_violation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_df_test</span> <span class="o">=</span> <span class="n">evaluation_df</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">figures_test</span> <span class="o">=</span> <span class="n">figures</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;constraint_violation&quot;</span><span class="p">:</span> <span class="n">constraint_violation</span><span class="p">,</span>
            <span class="s2">&quot;evaluation_df&quot;</span><span class="p">:</span> <span class="n">evaluation_df</span><span class="p">,</span>
            <span class="s2">&quot;figures&quot;</span><span class="p">:</span> <span class="n">figures</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="ReconcileAdditiveForecasts.fit_transform"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forecasts</span><span class="p">,</span> <span class="n">actuals</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fits and transforms training data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forecasts : `pandas.DataFrame`</span>
<span class="sd">            Forecasts to fit the adjustment. See ``fit``.</span>
<span class="sd">        actuals : `pandas.DataFrame`</span>
<span class="sd">            Actuals to fit the adjustment. See ``fit``.</span>
<span class="sd">        fit_kwargs : `dict`, optional</span>
<span class="sd">            Additional parameters to pass to ``fit``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjusted_forecasts : `pandas.DataFrame`</span>
<span class="sd">            Adjusted forecasts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">forecasts</span><span class="p">,</span> <span class="n">actuals</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_forecasts</span></div>

<div class="viewcode-block" id="ReconcileAdditiveForecasts.fit_transform_evaluate"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.fit_transform_evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forecasts</span><span class="p">,</span> <span class="n">actuals</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evaluate_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fits, transforms, and evaluates on training data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forecasts : `pandas.DataFrame`</span>
<span class="sd">            Forecasts to fit the adjustment. See ``fit``.</span>
<span class="sd">        actuals : `pandas.DataFrame`</span>
<span class="sd">            Actuals to fit the adjustment. See ``fit``.</span>
<span class="sd">        fit_kwargs : `dict`, optional, default None</span>
<span class="sd">            Additional parameters to pass to ``fit``.</span>
<span class="sd">        evaluate_kwargs : `dict`, optional, default None</span>
<span class="sd">            Additional parameters to pass to ``evaluate``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        evaluation_df : `pandas.DataFrame`</span>
<span class="sd">            Evaluation results on provided ``forecasts``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fit_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fit_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">evaluate_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">evaluate_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">forecasts</span><span class="p">,</span> <span class="n">actuals</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">is_train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">evaluate_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_df</span></div>

<div class="viewcode-block" id="ReconcileAdditiveForecasts.transform_evaluate"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.transform_evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">transform_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forecasts_test</span><span class="p">,</span> <span class="n">actuals_test</span><span class="p">,</span> <span class="o">**</span><span class="n">evaluate_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transforms and evaluates on test data.</span>

<span class="sd">        Must call ``fit`` before calling this method.</span>

<span class="sd">        forecasts_test : `pandas.DataFrame`</span>
<span class="sd">            Forecasts to make consistent. Should be different from the training data.</span>
<span class="sd">        actuals_test : `pandas.DataFrame`</span>
<span class="sd">            Actuals to check quality of the adjustment.</span>
<span class="sd">        evaluate_kwargs : `dict`, optional, default None</span>
<span class="sd">            Additional parameters to pass to ``evaluate``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        evaluation_df_test : `pandas.DataFrame`</span>
<span class="sd">            Evaluation results on provided ``forecasts_test``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">forecasts_test</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">is_train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">actuals_test</span><span class="o">=</span><span class="n">actuals_test</span><span class="p">,</span> <span class="o">**</span><span class="n">evaluate_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_df_test</span></div>

<div class="viewcode-block" id="ReconcileAdditiveForecasts.plot_transform_matrix"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.reconcile.convex.reconcile_forecasts.ReconcileAdditiveForecasts.plot_transform_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">plot_transform_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color_continuous_scale</span><span class="o">=</span><span class="s2">&quot;RdBu&quot;</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=-</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">zmax</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the transform matrix visually, as a grid.</span>
<span class="sd">        By default, negative values are red and positive values are blue.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        color_continuous_scale : `str` or `list` [`str`], default &quot;RdBu&quot;</span>
<span class="sd">            Colormap used to map scalar data to colors. See `plotly.express.imshow`.</span>
<span class="sd">        zmin : scalar or iterable, default -1.5</span>
<span class="sd">            The minimum value covered by the colormap.</span>
<span class="sd">            See `plotly.express.imshow`.</span>
<span class="sd">        zmax : scalar or iterable, default 1.5</span>
<span class="sd">            The maximum value covered by the colormap.</span>
<span class="sd">            See `plotly.express.imshow`.</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            Additional keyword arguments for `plotly.express.imshow`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : `plotly.graph_objects.Figure`</span>
<span class="sd">            The transform matrix plot object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFittedError</span><span class="p">(</span><span class="s2">&quot;Must call `fit` first.&quot;</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span><span class="p">,</span>
            <span class="n">color_continuous_scale</span><span class="o">=</span><span class="n">color_continuous_scale</span><span class="p">,</span>
            <span class="n">zmin</span><span class="o">=</span><span class="n">zmin</span><span class="p">,</span>
            <span class="n">zmax</span><span class="o">=</span><span class="n">zmax</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">),</span>
            <span class="n">x</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
            <span class="n">y</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
            <span class="n">title_text</span><span class="o">=</span><span class="s2">&quot;Transform Matrix&quot;</span><span class="p">,</span>
            <span class="n">title_x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">title_font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">xaxis_type</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span>
            <span class="n">yaxis_type</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, LinkedIn.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>