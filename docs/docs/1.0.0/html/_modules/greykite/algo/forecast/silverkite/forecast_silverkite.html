<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>greykite.algo.forecast.silverkite.forecast_silverkite &mdash; Greykite Library  documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../../index.html" class="icon icon-home"> Greykite Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/overview/100_forecast_intro.html">The Greykite Forecast model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/overview/200_ad_intro.html">The Greykite Anomaly Detection model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quick Start</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gallery/quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gallery/tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gallery/templates/index.html">Model Templates</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Step by Step</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0000_stepbystep.html">Forecasting Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0100_choose_model.html">Choose a Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0200_choose_template.html">Choose a Model Template</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0300_input.html">Examine Input Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0400_configuration.html">Configure a Forecast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0500_output.html">Check Forecast Result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0600_debug.html">Debugging</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tuning the Model Components</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0100_introduction.html">Greykite models and components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0200_growth.html">Growth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0300_seasonality.html">Seasonality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0400_events.html">Holidays and Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0500_changepoints.html">Changepoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0600_custom.html">Custom Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0700_regressors.html">Regressors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0800_autoregression.html">Auto-regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0900_uncertainty.html">Uncertainty Intervals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/1000_override.html">Pre-processing, Selective Grid Search</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Benchmarking</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/benchmarking/benchmarking.html">Benchmarking</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/miscellaneous/reconcile_forecasts.html">Reconcile Forecasts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/miscellaneous/store_model.html">Model store and load</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Changelog</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html">1.0.0 (2024-01-07)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id2">0.5.1 (2023-06-01)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id3">0.5.0 (2023-04-03)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id4">0.4.0 (2022-07-15)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id5">0.3.0 (2021-12-14)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id6">0.2.0 (2021-06-30)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html#id7">0.1.1 (2021-05-12)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/autodoc/doc.html">Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Greykite Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">greykite.algo.forecast.silverkite.forecast_silverkite</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for greykite.algo.forecast.silverkite.forecast_silverkite</h1><div class="highlight"><pre>
<span></span><span class="c1"># BSD 2-CLAUSE LICENSE</span>

<span class="c1"># Redistribution and use in source and binary forms, with or without modification,</span>
<span class="c1"># are permitted provided that the following conditions are met:</span>

<span class="c1"># Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1"># list of conditions and the following disclaimer.</span>
<span class="c1"># Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1"># this list of conditions and the following disclaimer in the documentation</span>
<span class="c1"># and/or other materials provided with the distribution.</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="c1"># ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="c1"># DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR</span>
<span class="c1"># #ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="c1"># (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="c1"># LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="c1"># ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="c1"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="c1"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># original author: Reza Hosseini</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Type</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pandas.plotting</span> <span class="kn">import</span> <span class="n">register_matplotlib_converters</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="kn">import</span> <span class="n">to_offset</span>

<span class="kn">from</span> <span class="nn">greykite.algo.changepoint.adalasso.changepoint_detector</span> <span class="kn">import</span> <span class="n">get_changepoints_dict</span>
<span class="kn">from</span> <span class="nn">greykite.algo.changepoint.adalasso.changepoint_detector</span> <span class="kn">import</span> <span class="n">get_seasonality_changepoints</span>
<span class="kn">from</span> <span class="nn">greykite.algo.changepoint.adalasso.changepoints_utils</span> <span class="kn">import</span> <span class="n">build_seasonality_feature_df_from_detection_result</span>
<span class="kn">from</span> <span class="nn">greykite.algo.changepoint.adalasso.changepoints_utils</span> <span class="kn">import</span> <span class="n">get_seasonality_changepoint_df_cols</span>
<span class="kn">from</span> <span class="nn">greykite.algo.common.ml_models</span> <span class="kn">import</span> <span class="n">fit_ml_model_with_evaluation</span>
<span class="kn">from</span> <span class="nn">greykite.algo.common.ml_models</span> <span class="kn">import</span> <span class="n">predict_ml</span>
<span class="kn">from</span> <span class="nn">greykite.algo.common.ml_models</span> <span class="kn">import</span> <span class="n">predict_ml_with_uncertainty</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.constants.silverkite_constant</span> <span class="kn">import</span> <span class="n">default_silverkite_constant</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.constants.silverkite_seasonality</span> <span class="kn">import</span> <span class="n">SilverkiteSeasonalityEnum</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.constants.silverkite_seasonality</span> <span class="kn">import</span> <span class="n">SilverkiteSeasonalityEnumMixin</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.forecast_silverkite_helper</span> <span class="kn">import</span> <span class="n">get_fourier_feature_col_names</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.forecast_silverkite_helper</span> <span class="kn">import</span> <span class="n">get_similar_lag</span>
<span class="kn">from</span> <span class="nn">greykite.common.constants</span> <span class="kn">import</span> <span class="n">CHANGEPOINT_COL_PREFIX</span>
<span class="kn">from</span> <span class="nn">greykite.common.constants</span> <span class="kn">import</span> <span class="n">ERR_STD_COL</span>
<span class="kn">from</span> <span class="nn">greykite.common.constants</span> <span class="kn">import</span> <span class="n">QUANTILE_SUMMARY_COL</span>
<span class="kn">from</span> <span class="nn">greykite.common.constants</span> <span class="kn">import</span> <span class="n">SEASONALITY_REGEX</span>
<span class="kn">from</span> <span class="nn">greykite.common.constants</span> <span class="kn">import</span> <span class="n">TimeFeaturesEnum</span>
<span class="kn">from</span> <span class="nn">greykite.common.enums</span> <span class="kn">import</span> <span class="n">TimeEnum</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">add_daily_events</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">add_time_features_df</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">fourier_series_multi_fcn</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">get_changepoint_dates_from_changepoints_dict</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">get_changepoint_features</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">get_changepoint_features_and_values_from_config</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">get_default_origin_for_time_vars</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_lags</span> <span class="kn">import</span> <span class="n">build_autoreg_df</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_lags</span> <span class="kn">import</span> <span class="n">build_autoreg_df_multi</span>
<span class="kn">from</span> <span class="nn">greykite.common.logging</span> <span class="kn">import</span> <span class="n">LoggingLevelEnum</span>
<span class="kn">from</span> <span class="nn">greykite.common.logging</span> <span class="kn">import</span> <span class="n">log_message</span>
<span class="kn">from</span> <span class="nn">greykite.common.python_utils</span> <span class="kn">import</span> <span class="n">get_pattern_cols</span>
<span class="kn">from</span> <span class="nn">greykite.common.python_utils</span> <span class="kn">import</span> <span class="n">unique_elements_in_list</span>
<span class="kn">from</span> <span class="nn">greykite.common.time_properties</span> <span class="kn">import</span> <span class="n">describe_timeseries</span>
<span class="kn">from</span> <span class="nn">greykite.common.time_properties</span> <span class="kn">import</span> <span class="n">fill_missing_dates</span>
<span class="kn">from</span> <span class="nn">greykite.common.time_properties</span> <span class="kn">import</span> <span class="n">min_gap_in_seconds</span>
<span class="kn">from</span> <span class="nn">greykite.common.time_properties_forecast</span> <span class="kn">import</span> <span class="n">get_default_horizon_from_period</span>


<span class="n">register_matplotlib_converters</span><span class="p">()</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines a class that provides the silverkite forecast functionality for training and prediction.</span>
<span class="sd">Currently provides the following functionality for users of the class</span>
<span class="sd">TODO : List all public functions here</span>
<span class="sd">This class can be extended and the user can customize the following functions</span>
<span class="sd">TODO : List all the protected functions here</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="SilverkiteForecast"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast">[docs]</a><span class="k">class</span> <span class="nc">SilverkiteForecast</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">constants</span><span class="p">:</span> <span class="n">SilverkiteSeasonalityEnumMixin</span> <span class="o">=</span> <span class="n">default_silverkite_constant</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">SilverkiteSeasonalityEnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">get_silverkite_seasonality_enum</span><span class="p">()</span>

<div class="viewcode-block" id="SilverkiteForecast.forecast"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.forecast">[docs]</a>    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="p">,</span>
            <span class="n">value_col</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">origin_for_time_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">extra_pred_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">drop_pred_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">explicit_pred_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">train_test_thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">training_fraction</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>  <span class="c1"># This is for internal ML models validation. The final returned model will be trained on all data.</span>
            <span class="n">fit_algorithm</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="n">fit_algorithm_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">daily_event_neighbor_impact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">daily_event_shifted_effect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fs_components_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">TimeFeaturesEnum</span><span class="o">.</span><span class="n">tod</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">TimeFeaturesEnum</span><span class="o">.</span><span class="n">tow</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">TimeFeaturesEnum</span><span class="o">.</span><span class="n">toy</span><span class="o">.</span><span class="n">value</span><span class="p">],</span>
                <span class="s2">&quot;period&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">24.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
                <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                <span class="s2">&quot;seas_names&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;daily&quot;</span><span class="p">,</span> <span class="s2">&quot;weekly&quot;</span><span class="p">,</span> <span class="s2">&quot;yearly&quot;</span><span class="p">]}),</span>
            <span class="n">autoreg_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">lagged_regressor_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">changepoints_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">seasonality_changepoints_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">changepoint_detector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">min_admissible_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_admissible_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">uncertainty_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">normalize_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">adjust_anomalous_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">impute_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">regression_weight_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">simulation_based</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">fast_simulation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">remove_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A function for forecasting.</span>
<span class="sd">        It captures growth, seasonality, holidays and other patterns.</span>
<span class="sd">        See &quot;Capturing the time-dependence in the precipitation process for</span>
<span class="sd">        weather risk assessment&quot; as a reference:</span>
<span class="sd">        https://link.springer.com/article/10.1007/s00477-016-1285-8</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : `pandas.DataFrame`</span>
<span class="sd">            A data frame which includes the timestamp column</span>
<span class="sd">            as well as the value column.</span>
<span class="sd">        time_col : `str`</span>
<span class="sd">            The column name in ``df`` representing time for the time series data.</span>
<span class="sd">            The time column can be anything that can be parsed by pandas DatetimeIndex.</span>
<span class="sd">        value_col: `str`</span>
<span class="sd">            The column name which has the value of interest to be forecasted.</span>
<span class="sd">        freq: `str`, optional, default None</span>
<span class="sd">            The intended timeseries frequency, DateOffset alias.</span>
<span class="sd">            See https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases.</span>
<span class="sd">            If None automatically inferred. This frequency will be passed through</span>
<span class="sd">            this function as a part of the trained model and used at predict time</span>
<span class="sd">            if needed.</span>
<span class="sd">            If data include missing timestamps, and frequency is monthly/annual,</span>
<span class="sd">            user should pass this parameter, as it cannot be inferred.</span>
<span class="sd">        origin_for_time_vars : `float`, optional, default None</span>
<span class="sd">            The time origin used to create continuous variables for time.</span>
<span class="sd">            If None, uses the first record in ``df``.</span>
<span class="sd">        extra_pred_cols : `list` of `str`, default None</span>
<span class="sd">            Names of the extra predictor columns.</span>

<span class="sd">            If None, uses [&quot;ct1&quot;], a simple linear growth term.</span>

<span class="sd">            It can leverage regressors included in ``df`` and those generated</span>
<span class="sd">            by the other parameters. The following effects will not be modeled</span>
<span class="sd">            unless specified in ``extra_pred_cols``:</span>

<span class="sd">                - included in ``df``: e.g. macro-economic factors, related timeseries</span>
<span class="sd">                - from `~greykite.common.features.timeseries_features.build_time_features_df`:</span>
<span class="sd">                  e.g. ct1, ct_sqrt, dow, ...</span>
<span class="sd">                - from ``daily_event_df_dict``: e.g. &quot;events_India&quot;, ...</span>

<span class="sd">            The columns corresponding to the following parameters are included</span>
<span class="sd">            in the model without specification in ``extra_pred_cols``.</span>
<span class="sd">            ``extra_pred_cols`` can be used to add interactions with these terms.</span>

<span class="sd">                changepoints_dict: e.g. changepoint0, changepoint1, ...</span>
<span class="sd">                fs_components_df: e.g. sin2_dow, cos4_dow_weekly</span>
<span class="sd">                autoreg_dict: e.g. x_lag1, x_avglag_2_3_4, y_avglag_1_to_5</span>

<span class="sd">            If a regressor is passed in ``df``, it needs to be provided to</span>
<span class="sd">            the associated predict function:</span>

<span class="sd">                ``predict_silverkite``: via ``fut_df`` or ``new_external_regressor_df``</span>
<span class="sd">                ``silverkite.predict_n(_no_sim``: via ``new_external_regressor_df``</span>
<span class="sd">        drop_pred_cols : `list` [`str`] or None, default None</span>
<span class="sd">            Names of predictor columns to be dropped from the final model.</span>
<span class="sd">            Ignored if None</span>
<span class="sd">        explicit_pred_cols : `list` [`str`] or None, default None</span>
<span class="sd">            Names of the explicit predictor columns which will be</span>
<span class="sd">            the only variables in the final model. Note that this overwrites</span>
<span class="sd">            the generated predictors in the model and may include new</span>
<span class="sd">            terms not appearing in the predictors (e.g. interaction terms).</span>
<span class="sd">            Ignored if None</span>
<span class="sd">        train_test_thresh : `datetime.datetime`, optional</span>
<span class="sd">            e.g. datetime.datetime(2019, 6, 30)</span>
<span class="sd">            The threshold for training and testing split.</span>
<span class="sd">            Note that the final returned model is trained using all data.</span>
<span class="sd">            If None, training split is based on ``training_fraction``</span>
<span class="sd">        training_fraction : `float`, optional</span>
<span class="sd">            The fraction of data used for training (0.0 to 1.0)</span>
<span class="sd">            Used only if ``train_test_thresh`` is None.</span>
<span class="sd">            If this is also None or 1.0, then we skip testing</span>
<span class="sd">            and train on the entire dataset.</span>
<span class="sd">        fit_algorithm : `str`, optional, default &quot;linear&quot;</span>
<span class="sd">            The type of predictive model used in fitting.</span>

<span class="sd">            See `~greykite.algo.common.ml_models.fit_model_via_design_matrix`</span>
<span class="sd">            for available options and their parameters.</span>
<span class="sd">        fit_algorithm_params : `dict` or None, optional, default None</span>
<span class="sd">            Parameters passed to the requested fit_algorithm.</span>
<span class="sd">            If None, uses the defaults in `~greykite.algo.common.ml_models.fit_model_via_design_matrix`.</span>
<span class="sd">        daily_event_df_dict : `dict` or None, optional, default None</span>
<span class="sd">            A dictionary of data frames, each representing events data for the corresponding key.</span>
<span class="sd">            The DataFrame has two columns:</span>

<span class="sd">                - The first column contains event dates. Must be in a format</span>
<span class="sd">                  recognized by `pandas.to_datetime`. Must be at daily</span>
<span class="sd">                  frequency for proper join. It is joined against the time</span>
<span class="sd">                  in ``df``, converted to a day:</span>
<span class="sd">                  ``pd.to_datetime(pd.DatetimeIndex(df[time_col]).date)``.</span>
<span class="sd">                - the second column contains the event label for each date</span>

<span class="sd">            The column order is important; column names are ignored.</span>
<span class="sd">            The event dates must span their occurrences in both the training</span>
<span class="sd">            and future prediction period.</span>

<span class="sd">            During modeling, each key in the dictionary is mapped to a categorical variable</span>
<span class="sd">            named ``f&quot;{EVENT_PREFIX}_{key}&quot;``, whose value at each timestamp is specified</span>
<span class="sd">            by the corresponding DataFrame.</span>

<span class="sd">            For example, to manually specify a yearly event on September 1</span>
<span class="sd">            during a training/forecast period that spans 2020-2022::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;custom_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;, &quot;2022-09-01&quot;],</span>
<span class="sd">                        &quot;label&quot;: [&quot;is_event&quot;, &quot;is_event&quot;, &quot;is_event&quot;]</span>
<span class="sd">                    })</span>
<span class="sd">                }</span>

<span class="sd">            It&#39;s possible to specify multiple events in the same df. Two events,</span>
<span class="sd">            ``&quot;sep&quot;`` and ``&quot;oct&quot;`` are specified below for 2020-2021::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;custom_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2020-10-01&quot;, &quot;2021-09-01&quot;, &quot;2021-10-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: [&quot;sep&quot;, &quot;oct&quot;, &quot;sep&quot;, &quot;oct&quot;]</span>
<span class="sd">                    })</span>
<span class="sd">                }</span>

<span class="sd">            Use multiple keys if two events may fall on the same date. These events</span>
<span class="sd">            must be in separate DataFrames::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;fixed_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;, &quot;2022-09-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;fixed_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                    &quot;moving_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-08-28&quot;, &quot;2022-09-03&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;moving_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                }</span>

<span class="sd">            The multiple event specification can be used even if events never overlap. An</span>
<span class="sd">            equivalent specification to the second example::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;sep&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;is_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                    &quot;oct&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-10-01&quot;, &quot;2021-10-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;is_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                }</span>

<span class="sd">            .. note::</span>

<span class="sd">                The events you want to use must be specified in ``extra_pred_cols``.</span>
<span class="sd">                These take the form: ``f&quot;{EVENT_PREFIX}_{key}&quot;``, where</span>
<span class="sd">                `~greykite.common.constants.EVENT_PREFIX` is the constant.</span>

<span class="sd">                Do not use `~greykite.common.constants.EVENT_DEFAULT`</span>
<span class="sd">                in the second column. This is reserved to indicate dates that do not</span>
<span class="sd">                correspond to an event.</span>
<span class="sd">        daily_event_neighbor_impact : `int`, `list` [`int`], callable or None, default None</span>
<span class="sd">            The impact of neighboring timestamps of the events in ``event_df_dict``.</span>
<span class="sd">            This is for daily events so the units below are all in days.</span>

<span class="sd">            For example, if the data is weekly (&quot;W-SUN&quot;) and an event is daily,</span>
<span class="sd">            it may not exactly fall on the weekly date.</span>
<span class="sd">            But you can specify for New Year&#39;s day on 1/1, it affects all dates</span>
<span class="sd">            in the week, e.g. 12/31, 1/1, ..., 1/6, then it will be mapped to the weekly date.</span>
<span class="sd">            In this case you may want to map a daily event&#39;s date to a few dates,</span>
<span class="sd">            and can specify</span>
<span class="sd">            ``neighbor_impact=lambda x: [x-timedelta(days=x.isocalendar()[2]-1) + timedelta(days=i) for i in range(7)]``.</span>

<span class="sd">            Another example is that the data is rolling 7 day daily data,</span>
<span class="sd">            thus a holiday may affect the t, t+1, ..., t+6 dates.</span>
<span class="sd">            You can specify ``neighbor_impact=7``.</span>

<span class="sd">            If input is `int`, the mapping is t, t+1, ..., t+neighbor_impact-1.</span>
<span class="sd">            If input is `list`, the mapping is [t+x for x in neighbor_impact].</span>
<span class="sd">            If input is a function, it maps each daily event&#39;s date to a list of dates.</span>
<span class="sd">        daily_event_shifted_effect : `list` [`str`] or None, default None</span>
<span class="sd">            Additional neighbor events based on given events.</span>
<span class="sd">            For example, passing [&quot;-1D&quot;, &quot;7D&quot;] will add extra daily events which are 1 day before</span>
<span class="sd">            and 7 days after the given events.</span>
<span class="sd">            Offset format is {d}{freq} with any integer plus a frequency string.</span>
<span class="sd">            Must be parsable by pandas ``to_offset``.</span>
<span class="sd">            The new events&#39; names will be the current events&#39; names with suffix &quot;{offset}_before&quot; or &quot;{offset}_after&quot;.</span>
<span class="sd">            For example, if we have an event named &quot;US_Christmas Day&quot;,</span>
<span class="sd">            a &quot;7D&quot; shift will have name &quot;US_Christmas Day_7D_after&quot;.</span>
<span class="sd">            This is useful when you expect an offset of the current holidays also has impact on the</span>
<span class="sd">            time series, or you want to interact the lagged terms with autoregression.</span>
<span class="sd">            If ``daily_event_neighbor_impact`` is also specified, this will be applied after adding neighboring days.</span>
<span class="sd">        fs_components_df : `pandas.DataFrame` or None, optional</span>
<span class="sd">            A dataframe with information about fourier series generation.</span>
<span class="sd">            Must contain columns with following names:</span>

<span class="sd">                &quot;name&quot;: name of the timeseries feature e.g. &quot;tod&quot;, &quot;tow&quot; etc.</span>
<span class="sd">                &quot;period&quot;: Period of the fourier series, optional, default 1.0</span>
<span class="sd">                &quot;order&quot;: Order of the fourier series, optional, default 1.0</span>
<span class="sd">                &quot;seas_names&quot;: season names corresponding to the name</span>
<span class="sd">                (e.g. &quot;daily&quot;, &quot;weekly&quot; etc.), optional.</span>

<span class="sd">            Default includes daily, weekly , yearly seasonality.</span>
<span class="sd">        autoreg_dict : `dict` or `str` or None, optional, default `None`</span>
<span class="sd">            If a `dict`: A dictionary with arguments for `~greykite.common.features.timeseries_lags.build_autoreg_df`.</span>
<span class="sd">            That function&#39;s parameter ``value_col`` is inferred from the input of</span>
<span class="sd">            current function ``self.forecast``. Other keys are:</span>

<span class="sd">                ``&quot;lag_dict&quot;`` : `dict` or None</span>
<span class="sd">                ``&quot;agg_lag_dict&quot;`` : `dict` or None</span>
<span class="sd">                ``&quot;series_na_fill_func&quot;`` : callable</span>

<span class="sd">            If a `str`: The string will represent a method and a dictionary will be</span>
<span class="sd">            constructed using that `str`.</span>
<span class="sd">            Currently only implemented method is &quot;auto&quot; which uses</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.SilverkiteForecast.__get_default_autoreg_dict`</span>
<span class="sd">            to create a dictionary.</span>
<span class="sd">            See more details for above parameters in</span>
<span class="sd">            `~greykite.common.features.timeseries_lags.build_autoreg_df`.</span>
<span class="sd">        past_df : `pandas.DataFrame` or None, default None</span>
<span class="sd">            The past df used for building autoregression features.</span>
<span class="sd">            This is not necessarily needed since imputation is possible.</span>
<span class="sd">            However, it is recommended to provide ``past_df`` for more accurate</span>
<span class="sd">            autoregression features and faster training (by skipping imputation).</span>
<span class="sd">            The columns are:</span>

<span class="sd">                time_col : `pandas.Timestamp` or `str`</span>
<span class="sd">                    The timestamps.</span>
<span class="sd">                value_col : `float`</span>
<span class="sd">                    The past values.</span>
<span class="sd">                addition_regressor_cols : `float`</span>
<span class="sd">                    Any additional regressors.</span>

<span class="sd">            Note that this ``past_df`` is assumed to immediately precede ``df`` without gaps,</span>
<span class="sd">            otherwise an error will be raised.</span>
<span class="sd">        lagged_regressor_dict : `dict` or None, default None</span>
<span class="sd">            A dictionary with arguments for `~greykite.common.features.timeseries_lags.build_autoreg_df_multi`.</span>
<span class="sd">            The keys of the dictionary are the target lagged regressor column names.</span>
<span class="sd">            It can leverage the regressors included in ``df``.</span>
<span class="sd">            The value of each key is either a `dict` or `str`.</span>
<span class="sd">            If `dict`, it has the following keys:</span>

<span class="sd">                ``&quot;lag_dict&quot;`` : `dict` or None</span>
<span class="sd">                ``&quot;agg_lag_dict&quot;`` : `dict` or None</span>
<span class="sd">                ``&quot;series_na_fill_func&quot;`` : callable</span>

<span class="sd">            If `str`, it represents a method and a dictionary will be constructed using that `str`.</span>
<span class="sd">            Currently the only implemented method is &quot;auto&quot; which uses</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.SilverkiteForecast.__get_default_lagged_regressor_dict`</span>
<span class="sd">            to create a dictionary for each lagged regressor.</span>
<span class="sd">            An example::</span>

<span class="sd">                lagged_regressor_dict = {</span>
<span class="sd">                    &quot;regressor1&quot;: {</span>
<span class="sd">                        &quot;lag_dict&quot;: {&quot;orders&quot;: [1, 2, 3]},</span>
<span class="sd">                        &quot;agg_lag_dict&quot;: {</span>
<span class="sd">                            &quot;orders_list&quot;: [[7, 7 * 2, 7 * 3]],</span>
<span class="sd">                            &quot;interval_list&quot;: [(8, 7 * 2)]},</span>
<span class="sd">                        &quot;series_na_fill_func&quot;: lambda s: s.bfill().ffill()},</span>
<span class="sd">                    &quot;regressor2&quot;: &quot;auto&quot;}</span>

<span class="sd">            Check the docstring of `~greykite.common.features.timeseries_lags.build_autoreg_df_multi`</span>
<span class="sd">            for more details for each argument.</span>
<span class="sd">        changepoints_dict : `dict` or None, optional, default None</span>
<span class="sd">            Specifies the changepoint configuration.</span>

<span class="sd">            &quot;method&quot;: `str`</span>
<span class="sd">                The method to locate changepoints.</span>
<span class="sd">                Valid options:</span>

<span class="sd">                    - &quot;uniform&quot;. Places n_changepoints evenly spaced changepoints to allow growth to change.</span>
<span class="sd">                    - &quot;custom&quot;. Places changepoints at the specified dates.</span>
<span class="sd">                    - &quot;auto&quot;. Automatically detects change points. For configuration, see</span>
<span class="sd">                      `~greykite.algo.changepoint.adalasso.changepoint_detector.ChangepointDetector.find_trend_changepoints`</span>

<span class="sd">                Additional keys to provide parameters for each particular method are described below.</span>
<span class="sd">            &quot;continuous_time_col&quot;: `str`, optional</span>
<span class="sd">                Column to apply ``growth_func`` to, to generate changepoint features</span>
<span class="sd">                Typically, this should match the growth term in the model</span>
<span class="sd">            &quot;growth_func&quot;: Optional[func]</span>
<span class="sd">                Growth function (scalar -&gt; scalar). Changepoint features are created</span>
<span class="sd">                by applying ``growth_func`` to ``continuous_time_col`` with offsets.</span>
<span class="sd">                If None, uses identity function to use ``continuous_time_col`` directly</span>
<span class="sd">                as growth term</span>
<span class="sd">                If changepoints_dict[&quot;method&quot;] == &quot;uniform&quot;, this other key is required:</span>

<span class="sd">                    ``&quot;n_changepoints&quot;``: int</span>
<span class="sd">                        number of changepoints to evenly space across training period</span>

<span class="sd">                If changepoints_dict[&quot;method&quot;] == &quot;custom&quot;, this other key is required:</span>

<span class="sd">                    ``&quot;dates&quot;``: Iterable[Union[int, float, str, datetime]]</span>
<span class="sd">                        Changepoint dates. Must be parsable by pd.to_datetime.</span>
<span class="sd">                        Changepoints are set at the closest time on or after these dates</span>
<span class="sd">                        in the dataset.</span>

<span class="sd">                If changepoints_dict[&quot;method&quot;] == &quot;auto&quot;, the keys that matches the parameters in</span>
<span class="sd">                `~greykite.algo.changepoint.adalasso.changepoint_detector.ChangepointDetector.find_trend_changepoints`,</span>
<span class="sd">                except ``df``, ``time_col`` and ``value_col``, are optional.</span>
<span class="sd">                Extra keys also include &quot;dates&quot;, &quot;combine_changepoint_min_distance&quot; and &quot;keep_detected&quot; to specify</span>
<span class="sd">                additional custom trend changepoints. These three parameters correspond to the three parameters</span>
<span class="sd">                &quot;custom_changepoint_dates&quot;, &quot;min_distance&quot; and &quot;keep_detected&quot; in</span>
<span class="sd">                `~greykite.algo.changepoint.adalasso.changepoints_utils.combine_detected_and_custom_trend_changepoints`.</span>

<span class="sd">        seasonality_changepoints_dict : `dict` or None, default `None`</span>
<span class="sd">            The parameter dictionary for seasonality change point detection. Parameters are in</span>
<span class="sd">            `~greykite.algo.changepoint.adalasso.changepoint_detector.ChangepointDetector.find_seasonality_changepoints`.</span>
<span class="sd">            Note ``df``, ``time_col``, ``value_col`` and ``trend_changepoints`` are auto populated,</span>
<span class="sd">            and do not need to be provided.</span>
<span class="sd">        changepoint_detector : `ChangepointDetector` or `None`, default `None`</span>
<span class="sd">            The ChangepointDetector class</span>
<span class="sd">            :class:`~greykite.algo.changepoint.adalasso.changepoint_detector.ChangepointDetector`.</span>
<span class="sd">            This is specifically for</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.forecast_simple_silverkite.forecast_simple_silverkite`</span>
<span class="sd">            to pass the ChangepointDetector class for plotting purposes, in case that users use</span>
<span class="sd">            ``forecast_simple_silverkite`` with ``changepoints_dict[&quot;method&quot;] == &quot;auto&quot;``. The</span>
<span class="sd">            trend change point detection has to be run there to include possible interaction terms,</span>
<span class="sd">            so we need to pass the detection result from there to include in the output.</span>
<span class="sd">        min_admissible_value : `float` or None, optional, default `None`</span>
<span class="sd">            The minimum admissible value to return during prediction.</span>
<span class="sd">            If None, no limit is applied.</span>
<span class="sd">        max_admissible_value : `float` or None, optional, default `None`</span>
<span class="sd">            The maximum admissible value to return during prediction.</span>
<span class="sd">            If None, no limit is applied.</span>
<span class="sd">        uncertainty_dict : `dict` or None, optional, default `None`</span>
<span class="sd">            How to fit the uncertainty model. A dictionary with keys:</span>
<span class="sd">                ``&quot;uncertainty_method&quot;`` : `str`</span>
<span class="sd">                    The title of the method.</span>
<span class="sd">                    Only &quot;simple_conditional_residuals&quot; is implemented</span>
<span class="sd">                    in ``fit_ml_model`` which calculates CIs using residuals</span>
<span class="sd">                ``&quot;params&quot;`` : `dict`</span>
<span class="sd">                    A dictionary of parameters needed for</span>
<span class="sd">                    the requested ``uncertainty_method``. For example, for</span>
<span class="sd">                    ``uncertainty_method=&quot;simple_conditional_residuals&quot;``, see</span>
<span class="sd">                    parameters of `~greykite.algo.uncertainty.conditional.conf_interval.conf_interval`:</span>

<span class="sd">                        ``&quot;conditional_cols&quot;``</span>
<span class="sd">                        ``&quot;quantiles&quot;``</span>
<span class="sd">                        ``&quot;quantile_estimation_method&quot;``</span>
<span class="sd">                        ``&quot;sample_size_thresh&quot;``</span>
<span class="sd">                        ``&quot;small_sample_size_method&quot;``</span>
<span class="sd">                        ``&quot;small_sample_size_quantile&quot;``</span>

<span class="sd">            If None, no uncertainty intervals are calculated.</span>
<span class="sd">        normalize_method : `str` or None, default None</span>
<span class="sd">            If a string is provided, it will be used as the normalization method</span>
<span class="sd">            in `~greykite.common.features.normalize.normalize_df`, passed via</span>
<span class="sd">            the argument ``method``.</span>
<span class="sd">            Available options are: &quot;zero_to_one&quot;, &quot;statistical&quot;, &quot;minus_half_to_half&quot;, &quot;zero_at_origin&quot;.</span>
<span class="sd">            If None, no normalization will be performed.</span>
<span class="sd">            See that function for more details.</span>
<span class="sd">        adjust_anomalous_dict : `dict` or None, default None</span>
<span class="sd">            If not None, a dictionary with following items:</span>

<span class="sd">                - &quot;func&quot; : `callable`</span>
<span class="sd">                    A function to perform adjustment of anomalous data with following</span>
<span class="sd">                    signature::</span>

<span class="sd">                        adjust_anomalous_dict[&quot;func&quot;](</span>
<span class="sd">                            df=df,</span>
<span class="sd">                            time_col=time_col,</span>
<span class="sd">                            value_col=value_col,</span>
<span class="sd">                            **params) -&gt;</span>
<span class="sd">                        {&quot;adjusted_df&quot;: adjusted_df, ...}</span>

<span class="sd">                - &quot;params&quot; : `dict`</span>
<span class="sd">                    The extra parameters to be passed to the function above.</span>
<span class="sd">        impute_dict : `dict` or None, default None</span>
<span class="sd">            If not None, a dictionary with following items:</span>

<span class="sd">            - &quot;func&quot; : `callable`</span>
<span class="sd">                A function to perform imputations with following</span>
<span class="sd">                signature::</span>

<span class="sd">                    impute_dict[&quot;func&quot;](</span>
<span class="sd">                        df=df,</span>
<span class="sd">                        value_col=value_col,</span>
<span class="sd">                        **impute_dict[&quot;params&quot;] -&gt;</span>
<span class="sd">                    {&quot;df&quot;: imputed_df, ...}</span>

<span class="sd">            - &quot;params&quot; : `dict`</span>
<span class="sd">                The extra parameters to be passed to the function above.</span>

<span class="sd">        regression_weight_col : `str` or None, default None</span>
<span class="sd">            The column name for the weights to be used in weighted regression version</span>
<span class="sd">            of applicable machine-learning models.</span>
<span class="sd">        forecast_horizon : `int` or None, default None</span>
<span class="sd">            The number of periods for which forecast is needed.</span>
<span class="sd">            Note that this is only used in deciding what parameters should be</span>
<span class="sd">            used for certain components e.g. autoregression, if automatic methods</span>
<span class="sd">            are requested. While, the prediction time forecast horizon could be different</span>
<span class="sd">            from this variable, ideally they should be the same.</span>
<span class="sd">        simulation_based : `bool`, default False</span>
<span class="sd">            Boolean to specify if the future predictions are to be using simulations</span>
<span class="sd">            or not.</span>
<span class="sd">            Note that this is only used in deciding what parameters should be</span>
<span class="sd">            used for certain components e.g. autoregression, if automatic methods</span>
<span class="sd">            are requested. However, the auto-settings and the prediction settings</span>
<span class="sd">            regarding using simulations should match.</span>
<span class="sd">        simulation_num : `int`, default 10</span>
<span class="sd">            The number of simulations for when simulations are used for generating</span>
<span class="sd">            forecasts and prediction intervals.</span>
<span class="sd">        fast_simulation: `bool`, default False</span>
<span class="sd">            Deterimes if fast simulations are to be used. This only impacts models</span>
<span class="sd">            which include auto-regression. This method will only generate one simulation</span>
<span class="sd">            without any error being added and then add the error using the volatility</span>
<span class="sd">            model. The advantage is a major boost in speed during inference and the</span>
<span class="sd">            disadvantage is potentially less accurate prediction intervals.</span>
<span class="sd">        remove_intercept : `bool`, default False</span>
<span class="sd">            Whether to remove explicit and implicit intercepts.</span>
<span class="sd">            By default, `patsy` will make the design matrix always full rank.</span>
<span class="sd">            It will always include an intercept term unless we specify &quot;-1&quot; or &quot;+0&quot;.</span>
<span class="sd">            However, if there are categorical variables, even we specify &quot;-1&quot; or &quot;+0&quot;,</span>
<span class="sd">            it will include an implicit intercept by adding all levels of a categorical</span>
<span class="sd">            variable into the design matrix.</span>
<span class="sd">            Sometimes we don&#39;t want this to happen.</span>
<span class="sd">            Setting this parameter to True will remove both explicit and implicit intercepts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A dictionary that includes the fitted model from the function</span>
<span class="sd">            :func:`~greykite.algo.common.ml_models.fit_ml_model_with_evaluation`.</span>
<span class="sd">            The keys are:</span>

<span class="sd">                df_dropna: `pandas.DataFrame`</span>
<span class="sd">                    The ``df`` with NAs dropped.</span>
<span class="sd">                df: `pandas.DataFrame`</span>
<span class="sd">                    The original ``df``.</span>
<span class="sd">                num_training_points: `int`</span>
<span class="sd">                    The number of training points.</span>
<span class="sd">                features_df: `pandas.DataFrame`</span>
<span class="sd">                    The ``df`` with augmented time features.</span>
<span class="sd">                min_timestamp: `pandas.Timestamp`</span>
<span class="sd">                    The minimum timestamp in data.</span>
<span class="sd">                max_timestamp: `pandas.Timestamp`</span>
<span class="sd">                    The maximum timestamp in data.</span>
<span class="sd">                freq: `str`</span>
<span class="sd">                    The data frequency.</span>
<span class="sd">                inferred_freq: `str`</span>
<span class="sd">                    The data freqency inferred from data.</span>
<span class="sd">                inferred_freq_in_secs : `float`</span>
<span class="sd">                    The data frequency inferred from data in seconds.</span>
<span class="sd">                inferred_freq_in_days: `float`</span>
<span class="sd">                    The data frequency inferred from data in days.</span>
<span class="sd">                time_col: `str`</span>
<span class="sd">                    The time column name.</span>
<span class="sd">                value_col: `str`</span>
<span class="sd">                    The value column name.</span>
<span class="sd">                origin_for_time_vars: `float`</span>
<span class="sd">                    The first time stamp converted to a float number.</span>
<span class="sd">                fs_components_df: `pandas.DataFrame`</span>
<span class="sd">                    The dataframe that specifies the seasonality Fourier configuration.</span>
<span class="sd">                autoreg_dict: `dict`</span>
<span class="sd">                    The dictionary that specifies the autoregression configuration.</span>
<span class="sd">                lagged_regressor_dict: `dict`</span>
<span class="sd">                    The dictionary that specifies the lagged regressors configuration.</span>
<span class="sd">                lagged_regressor_cols: `list` [`str`]</span>
<span class="sd">                    List of regressor column names used for lagged regressor</span>
<span class="sd">                normalize_method: `str`</span>
<span class="sd">                    The normalization method.</span>
<span class="sd">                    See the function input parameter ``normalize_method``.</span>
<span class="sd">                daily_event_df_dict: `dict`</span>
<span class="sd">                    The dictionary that specifies daily events configuration.</span>
<span class="sd">                changepoints_dict: `dict`</span>
<span class="sd">                    The dictionary that specifies changepoints configuration.</span>
<span class="sd">                changepoint_values: `list` [`float`]</span>
<span class="sd">                    The list of changepoints in continuous time values.</span>
<span class="sd">                normalized_changepoint_values : `list` [`float`]</span>
<span class="sd">                    The list of changepoints in continuous time values normalized to 0 to 1.</span>
<span class="sd">                continuous_time_col: `str`</span>
<span class="sd">                    The continuous time column name in ``features_df``.</span>
<span class="sd">                growth_func: `func`</span>
<span class="sd">                    The growth function used in changepoints, None is linear function.</span>
<span class="sd">                fs_func: `func`</span>
<span class="sd">                    The function used to generate Fourier series for seasonality.</span>
<span class="sd">                has_autoreg_structure: `bool`</span>
<span class="sd">                    Whether the model has autoregression structure.</span>
<span class="sd">                autoreg_func: `func`</span>
<span class="sd">                    The function to generate autoregression columns.</span>
<span class="sd">                min_lag_order: `int`</span>
<span class="sd">                    Minimal lag order in autoregression.</span>
<span class="sd">                max_lag_order: `int`</span>
<span class="sd">                    Maximal lag order in autoregression.</span>
<span class="sd">                has_lagged_regressor_structure: `bool`</span>
<span class="sd">                    Whether the model has lagged regressor structure.</span>
<span class="sd">                lagged_regressor_func: `func`</span>
<span class="sd">                    The function to generate lagged regressor columns.</span>
<span class="sd">                min_lagged_regressor_order: `int`</span>
<span class="sd">                    Minimal lag order in lagged regressors.</span>
<span class="sd">                max_lagged_regressor_order: `int`</span>
<span class="sd">                    Maximal lag order in lagged regressors.</span>
<span class="sd">                uncertainty_dict: `dict`</span>
<span class="sd">                    The dictionary that specifies uncertainty model configuration.</span>
<span class="sd">                pred_cols: `list` [`str`]</span>
<span class="sd">                    List of predictor names.</span>
<span class="sd">                last_date_for_fit: `str` or `pandas.Timestamp`</span>
<span class="sd">                    The last timestamp used for fitting.</span>
<span class="sd">                trend_changepoint_dates: `list` [`pandas.Timestamp`]</span>
<span class="sd">                    List of trend changepoints.</span>
<span class="sd">                changepoint_detector: `class`</span>
<span class="sd">                    The `ChangepointDetector` class used to detected trend changepoints.</span>
<span class="sd">                seasonality_changepoint_dates: `list` [`pandas.Timestamp`]</span>
<span class="sd">                    List of seasonality changepoints.</span>
<span class="sd">                seasonality_changepoint_result: `dict`</span>
<span class="sd">                    The seasonality changepoint detection results.</span>
<span class="sd">                fit_algorithm: `str`</span>
<span class="sd">                    The algorithm used to fit the model.</span>
<span class="sd">                fit_algorithm_params: `dict`</span>
<span class="sd">                    The dictionary of parameters for ``fit_algorithm``.</span>
<span class="sd">                adjust_anomalous_info: `dict`</span>
<span class="sd">                    A dictionary that has anomaly adjustment results.</span>
<span class="sd">                impute_info: `dict`</span>
<span class="sd">                    A dictionary that has the imputation results.</span>
<span class="sd">                forecast_horizon: `int`</span>
<span class="sd">                    The forecast horizon in steps.</span>
<span class="sd">                forecast_horizon_in_days: `float`</span>
<span class="sd">                    The forecast horizon in days.</span>
<span class="sd">                forecast_horizon_in_timedelta: `datetime.timmdelta`</span>
<span class="sd">                    The forecast horizon in timedelta.</span>
<span class="sd">                simulation_based: `bool`</span>
<span class="sd">                    Whether to use simulation in prediction with autoregression terms.</span>
<span class="sd">                simulation_num : `int`, default 10</span>
<span class="sd">                    The number of simulations for when simulations are used for generating</span>
<span class="sd">                    forecasts and prediction intervals.</span>
<span class="sd">                train_df : `pandas.DataFrame`</span>
<span class="sd">                    The past dataframe used to generate AR terms.</span>
<span class="sd">                    It includes the concatenation of ``past_df`` and ``df`` if ``past_df`` is provided,</span>
<span class="sd">                    otherwise it is the ``df`` itself.</span>
<span class="sd">                drop_intercept_col : `str` or None</span>
<span class="sd">                    The intercept column, explicit or implicit, to be dropped.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>
        <span class="n">num_training_points</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">adjust_anomalous_info</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">simulation_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">simulation_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;simulation number must be a natural number&quot;</span>

        <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">past_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">past_df</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">past_df</span> <span class="o">=</span> <span class="n">past_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>
                <span class="n">past_df</span> <span class="o">=</span> <span class="n">past_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">time_col</span><span class="p">)</span>

        <span class="c1"># Adjusts anomalies if requested</span>
        <span class="k">if</span> <span class="n">adjust_anomalous_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">adjust_anomalous_info</span> <span class="o">=</span> <span class="n">adjust_anomalous_dict</span><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">](</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>
                <span class="o">**</span><span class="n">adjust_anomalous_dict</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">adjust_anomalous_info</span><span class="p">[</span><span class="s2">&quot;adjusted_df&quot;</span><span class="p">]</span>

        <span class="n">impute_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">impute_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">impute_info</span> <span class="o">=</span> <span class="n">impute_dict</span><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">](</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>
                <span class="o">**</span><span class="n">impute_dict</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">impute_info</span><span class="p">[</span><span class="s2">&quot;df&quot;</span><span class="p">]</span>

        <span class="c1"># Calculates time properties of the series</span>
        <span class="c1"># We include these properties in the returned `trained_model` object</span>
        <span class="n">time_stats</span> <span class="o">=</span> <span class="n">describe_timeseries</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">)</span>
        <span class="n">max_timestamp</span> <span class="o">=</span> <span class="n">time_stats</span><span class="p">[</span><span class="s2">&quot;max_timestamp&quot;</span><span class="p">]</span>
        <span class="n">min_timestamp</span> <span class="o">=</span> <span class="n">time_stats</span><span class="p">[</span><span class="s2">&quot;min_timestamp&quot;</span><span class="p">]</span>
        <span class="c1"># This infers a constant length freq (in seconds units or days) from data.</span>
        <span class="c1"># Note that in some cases e.g. monthly or annual data the real frequency can</span>
        <span class="c1"># be non-constant in length.</span>
        <span class="c1"># This inferred freq is of `pandas._libs.tslibs.timedeltas.Timedelta` type.</span>
        <span class="n">inferred_freq</span> <span class="o">=</span> <span class="n">time_stats</span><span class="p">[</span><span class="s2">&quot;freq_in_timedelta&quot;</span><span class="p">]</span>
        <span class="n">inferred_freq_in_secs</span> <span class="o">=</span> <span class="n">time_stats</span><span class="p">[</span><span class="s2">&quot;freq_in_secs&quot;</span><span class="p">]</span>
        <span class="n">inferred_freq_in_days</span> <span class="o">=</span> <span class="n">time_stats</span><span class="p">[</span><span class="s2">&quot;freq_in_days&quot;</span><span class="p">]</span>
        <span class="c1"># However in some use cases user might provide more complex</span>
        <span class="c1"># freq to `predict_n` functions.</span>
        <span class="c1"># As an example `freq=&#39;W-SUN&#39;` which can be passed by user.</span>
        <span class="c1"># If such freq is not passed, we can attempt to infer it.</span>
        <span class="c1"># Note that if there are data with gaps, this freq cannot be inferred.</span>
        <span class="c1"># E.g. if hourly data only include 9am-5pm.</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">infer_freq</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>

        <span class="c1"># Calculates forecast horizon (as a number of observations)</span>
        <span class="k">if</span> <span class="n">forecast_horizon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># expected to be kept in sync with default value set in ``get_default_time_parameters``</span>
            <span class="n">forecast_horizon</span> <span class="o">=</span> <span class="n">get_default_horizon_from_period</span><span class="p">(</span>
                <span class="n">period</span><span class="o">=</span><span class="n">inferred_freq_in_secs</span><span class="p">,</span>
                <span class="n">num_observations</span><span class="o">=</span><span class="n">num_training_points</span><span class="p">)</span>
        <span class="n">forecast_horizon_in_timedelta</span> <span class="o">=</span> <span class="n">inferred_freq</span> <span class="o">*</span> <span class="n">forecast_horizon</span>
        <span class="n">forecast_horizon_in_days</span> <span class="o">=</span> <span class="n">inferred_freq_in_days</span> <span class="o">*</span> <span class="n">forecast_horizon</span>

        <span class="k">if</span> <span class="n">extra_pred_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extra_pred_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">TimeFeaturesEnum</span><span class="o">.</span><span class="n">ct1</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>  <span class="c1"># linear in time</span>

        <span class="c1"># Makes sure the ``train_test_thresh`` is within the data</span>
        <span class="n">last_time_available</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">train_test_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">train_test_thresh</span> <span class="o">&gt;=</span> <span class="n">last_time_available</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Input timestamp for the parameter &#39;train_test_threshold&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">train_test_thresh</span><span class="si">}</span><span class="s2">) exceeds the maximum available timestamp &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;of the time series (</span><span class="si">{</span><span class="n">last_time_available</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Please pass a value within the range.&quot;</span><span class="p">)</span>

        <span class="c1"># Sets default origin so that &quot;ct1&quot; feature from `build_time_features_df`</span>
        <span class="c1"># Starts at 0 on train start date</span>
        <span class="k">if</span> <span class="n">origin_for_time_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin_for_time_vars</span> <span class="o">=</span> <span class="n">get_default_origin_for_time_vars</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">time_col</span><span class="p">)</span>
        <span class="c1"># Updates `changepoints_dict`, unchanged if not &quot;method&quot; == &quot;auto&quot;</span>
        <span class="n">changepoints_dict</span><span class="p">,</span> <span class="n">changepoint_detector_class</span> <span class="o">=</span> <span class="n">get_changepoints_dict</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
            <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>
            <span class="n">changepoints_dict</span><span class="o">=</span><span class="n">changepoints_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">changepoint_detector_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Handles the case that user uses `forecast_simple_silverkite` with automatic</span>
            <span class="c1"># trend change point detection. In that case, the `changepoints_dict` is already</span>
            <span class="c1"># transformed to &quot;method&quot; = &quot;custom&quot;, thus no changepoint detector is returned</span>
            <span class="c1"># by `get_changepoints_dict`, so we need the original `ChangepointDetector` class</span>
            <span class="c1"># to include in the output for plotting purpose.</span>
            <span class="n">changepoint_detector_class</span> <span class="o">=</span> <span class="n">changepoint_detector</span>
        <span class="c1"># Defines trend changepoints.</span>
        <span class="c1"># `df` contains all dates in the training period, including those</span>
        <span class="c1"># where `value_col` is np.nan and therefore not used in training</span>
        <span class="c1"># by `fit_ml_model_with_evaluation`.</span>
        <span class="c1"># Thus, when changepoint &quot;method&quot; = &quot;uniform&quot;, all dates are used to uniformly</span>
        <span class="c1"># place the changepoints. When changepoint &quot;method&quot; = &quot;auto&quot;, only dates without</span>
        <span class="c1"># missing values are used to place potential changepoints, after resampling</span>
        <span class="c1"># according to `resample_freq`. Seasonality changepoints are also placed using</span>
        <span class="c1"># resampled dates after excluding the missing values.</span>
        <span class="n">trend_changepoint_dates</span> <span class="o">=</span> <span class="n">get_changepoint_dates_from_changepoints_dict</span><span class="p">(</span>
            <span class="n">changepoints_dict</span><span class="o">=</span><span class="n">changepoints_dict</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span>
        <span class="p">)</span>
        <span class="n">changepoints</span> <span class="o">=</span> <span class="n">get_changepoint_features_and_values_from_config</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
            <span class="n">changepoints_dict</span><span class="o">=</span><span class="n">changepoints_dict</span><span class="p">,</span>
            <span class="n">origin_for_time_vars</span><span class="o">=</span><span class="n">origin_for_time_vars</span><span class="p">)</span>
        <span class="c1"># Checks the provided `extra_pred_cols`. If it contains a feature involving a changepoint,</span>
        <span class="c1"># the changepoint must be valid</span>
        <span class="n">keep_extra_pred_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">extra_pred_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">CHANGEPOINT_COL_PREFIX</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">changepoint_col</span> <span class="ow">in</span> <span class="n">changepoints</span><span class="p">[</span><span class="s2">&quot;changepoint_cols&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">changepoint_col</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
                        <span class="n">keep_extra_pred_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">keep_extra_pred_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_extra_pred_cols</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_pred_cols</span><span class="p">):</span>
            <span class="n">removed_pred_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">extra_pred_cols</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">keep_extra_pred_cols</span><span class="p">)</span>
            <span class="n">extra_pred_cols</span> <span class="o">=</span> <span class="n">keep_extra_pred_cols</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following features in extra_pred_cols are removed for this&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; training set: </span><span class="si">{</span><span class="n">removed_pred_cols</span><span class="si">}</span><span class="s2">. This is possible if running backtest&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; or cross validation, but you are fitting on the entire training set,&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; double check `extra_pred_cols` and other configuration.&quot;</span><span class="p">)</span>

        <span class="n">changepoint_values</span> <span class="o">=</span> <span class="n">changepoints</span><span class="p">[</span><span class="s2">&quot;changepoint_values&quot;</span><span class="p">]</span>
        <span class="n">continuous_time_col</span> <span class="o">=</span> <span class="n">changepoints</span><span class="p">[</span><span class="s2">&quot;continuous_time_col&quot;</span><span class="p">]</span>
        <span class="n">changepoint_cols</span> <span class="o">=</span> <span class="n">changepoints</span><span class="p">[</span><span class="s2">&quot;changepoint_cols&quot;</span><span class="p">]</span>
        <span class="n">growth_func</span> <span class="o">=</span> <span class="n">changepoints</span><span class="p">[</span><span class="s2">&quot;growth_func&quot;</span><span class="p">]</span>

        <span class="c1"># Adds fourier series for seasonality</span>
        <span class="c1"># Initializes fourier series function with None</span>
        <span class="c1"># and alters if fourier components are input</span>
        <span class="n">fs_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">fs_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">fs_components_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fs_components_df</span> <span class="o">=</span> <span class="n">fs_components_df</span><span class="p">[</span><span class="n">fs_components_df</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">fs_components_df</span> <span class="o">=</span> <span class="n">fs_components_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs_components_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fs_func</span> <span class="o">=</span> <span class="n">fourier_series_multi_fcn</span><span class="p">(</span>
                    <span class="n">col_names</span><span class="o">=</span><span class="n">fs_components_df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>  <span class="c1"># looks for corresponding column name in input df</span>
                    <span class="n">periods</span><span class="o">=</span><span class="n">fs_components_df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;period&quot;</span><span class="p">),</span>
                    <span class="n">orders</span><span class="o">=</span><span class="n">fs_components_df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">),</span>
                    <span class="n">seas_names</span><span class="o">=</span><span class="n">fs_components_df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;seas_names&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># Determines fourier series column names for use in &quot;build_features&quot;</span>
                <span class="n">fs_cols</span> <span class="o">=</span> <span class="n">get_fourier_feature_col_names</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                    <span class="n">fs_func</span><span class="o">=</span><span class="n">fs_func</span><span class="p">,</span>
                    <span class="n">conti_year_origin</span><span class="o">=</span><span class="n">origin_for_time_vars</span>
                <span class="p">)</span>
        <span class="c1"># Removes fs_cols with perfect or almost perfect collinearity for OLS.</span>
        <span class="c1"># For example, yearly seasonality with order 4 and quarterly seasonality with order 1, and etc.</span>
        <span class="k">if</span> <span class="n">fit_algorithm</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;statsmodels_wls&quot;</span><span class="p">,</span> <span class="s2">&quot;statsmodels_gls&quot;</span><span class="p">]:</span>
            <span class="c1"># Removes fourier columns with perfect or almost perfect collinearity.</span>
            <span class="n">fs_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__remove_fourier_col_with_collinearity</span><span class="p">(</span>
                <span class="n">fs_cols</span><span class="p">)</span>
            <span class="c1"># Also removes these terms from interactions.</span>
            <span class="n">extra_pred_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__remove_fourier_col_with_collinearity_and_interaction</span><span class="p">(</span>
                <span class="n">extra_pred_cols</span><span class="p">,</span> <span class="n">fs_cols</span><span class="p">)</span>

        <span class="c1"># Adds seasonality change point features</span>
        <span class="n">seasonality_changepoint_result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">seasonality_changepoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">seasonality_changepoint_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">seasonality_changepoints_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seasonality_changepoint_result</span> <span class="o">=</span> <span class="n">get_seasonality_changepoints</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>
                <span class="n">trend_changepoint_dates</span><span class="o">=</span><span class="n">trend_changepoint_dates</span><span class="p">,</span>
                <span class="n">seasonality_changepoints_dict</span><span class="o">=</span><span class="n">seasonality_changepoints_dict</span>
            <span class="p">)</span>
            <span class="n">seasonality_changepoints</span> <span class="o">=</span> <span class="n">seasonality_changepoint_result</span><span class="p">[</span><span class="s2">&quot;seasonality_changepoints&quot;</span><span class="p">]</span>
            <span class="n">seasonality_available</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fs_cols</span><span class="p">]))</span>
            <span class="n">seasonality_changepoint_cols</span> <span class="o">=</span> <span class="n">get_seasonality_changepoint_df_cols</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">seasonality_changepoints</span><span class="o">=</span><span class="n">seasonality_changepoints</span><span class="p">,</span>
                <span class="n">seasonality_components_df</span><span class="o">=</span><span class="n">seasonality_changepoint_result</span><span class="p">[</span><span class="s2">&quot;seasonality_components_df&quot;</span><span class="p">],</span>
                <span class="n">include_original_block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">include_components</span><span class="o">=</span><span class="n">seasonality_available</span>
            <span class="p">)</span>

        <span class="n">features_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_silverkite_features</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
            <span class="n">origin_for_time_vars</span><span class="o">=</span><span class="n">origin_for_time_vars</span><span class="p">,</span>
            <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="n">daily_event_df_dict</span><span class="p">,</span>
            <span class="n">daily_event_neighbor_impact</span><span class="o">=</span><span class="n">daily_event_neighbor_impact</span><span class="p">,</span>
            <span class="n">daily_event_shifted_effect</span><span class="o">=</span><span class="n">daily_event_shifted_effect</span><span class="p">,</span>
            <span class="n">changepoint_values</span><span class="o">=</span><span class="n">changepoint_values</span><span class="p">,</span>
            <span class="n">continuous_time_col</span><span class="o">=</span><span class="n">continuous_time_col</span><span class="p">,</span>
            <span class="n">growth_func</span><span class="o">=</span><span class="n">growth_func</span><span class="p">,</span>
            <span class="n">fs_func</span><span class="o">=</span><span class="n">fs_func</span><span class="p">,</span>
            <span class="n">seasonality_changepoint_result</span><span class="o">=</span><span class="n">seasonality_changepoint_result</span><span class="p">,</span>
            <span class="n">changepoint_dates</span><span class="o">=</span><span class="n">trend_changepoint_dates</span><span class="p">)</span>

        <span class="c1"># Adds autoregression columns to feature matrix</span>
        <span class="n">autoreg_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">lag_col_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">agg_lag_col_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">min_lag_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_lag_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">autoreg_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">autoreg_dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">autoreg_dict</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                <span class="n">autoreg_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_default_autoreg_dict</span><span class="p">(</span>
                    <span class="n">freq_in_days</span><span class="o">=</span><span class="n">inferred_freq_in_days</span><span class="p">,</span>
                    <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">,</span>
                    <span class="n">simulation_based</span><span class="o">=</span><span class="n">simulation_based</span><span class="p">)</span>
                <span class="n">autoreg_dict</span> <span class="o">=</span> <span class="n">autoreg_info</span><span class="p">[</span><span class="s2">&quot;autoreg_dict&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The method </span><span class="si">{</span><span class="n">autoreg_dict</span><span class="si">}</span><span class="s2"> is not implemented.&quot;</span><span class="p">)</span>

        <span class="n">has_autoreg_structure</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">autoreg_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">has_autoreg_structure</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">autoreg_components</span> <span class="o">=</span> <span class="n">build_autoreg_df</span><span class="p">(</span>
                <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>
                <span class="o">**</span><span class="n">autoreg_dict</span><span class="p">)</span>
            <span class="n">autoreg_func</span> <span class="o">=</span> <span class="n">autoreg_components</span><span class="p">[</span><span class="s2">&quot;build_lags_func&quot;</span><span class="p">]</span>
            <span class="n">lag_col_names</span> <span class="o">=</span> <span class="n">autoreg_components</span><span class="p">[</span><span class="s2">&quot;lag_col_names&quot;</span><span class="p">]</span>
            <span class="n">agg_lag_col_names</span> <span class="o">=</span> <span class="n">autoreg_components</span><span class="p">[</span><span class="s2">&quot;agg_lag_col_names&quot;</span><span class="p">]</span>
            <span class="n">min_lag_order</span> <span class="o">=</span> <span class="n">autoreg_components</span><span class="p">[</span><span class="s2">&quot;min_order&quot;</span><span class="p">]</span>
            <span class="n">max_lag_order</span> <span class="o">=</span> <span class="n">autoreg_components</span><span class="p">[</span><span class="s2">&quot;max_order&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">autoreg_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Fills in the gaps for imputation.</span>
                    <span class="n">expected_last_timestamp</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">expected_last_timestamp</span><span class="p">:</span>  <span class="c1"># ``past_df`` is already sorted.</span>
                        <span class="c1"># If ``past_df`` and ``df`` have gap in between, adds the last timestamp before ``df``.</span>
                        <span class="c1"># Then the rest will be filled with NA.</span>
                        <span class="n">log_message</span><span class="p">(</span>
                            <span class="n">message</span><span class="o">=</span><span class="s2">&quot;There is gaps between ``past_df`` and ``df``. &quot;</span>
                                    <span class="s2">&quot;Filling the missing timestamps.&quot;</span><span class="p">,</span>
                            <span class="n">level</span><span class="o">=</span><span class="n">LoggingLevelEnum</span><span class="o">.</span><span class="n">DEBUG</span>
                        <span class="p">)</span>
                        <span class="n">last_timestamp_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                            <span class="n">col</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="k">if</span> <span class="n">col</span> <span class="o">!=</span> <span class="n">time_col</span> <span class="k">else</span> <span class="p">[</span><span class="n">expected_last_timestamp</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">past_df</span><span class="o">.</span><span class="n">columns</span>
                        <span class="p">})</span>
                        <span class="n">past_df</span> <span class="o">=</span> <span class="n">past_df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_timestamp_df</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">past_df</span> <span class="o">=</span> <span class="n">fill_missing_dates</span><span class="p">(</span>
                        <span class="n">df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
                        <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                        <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># `fill_missing_dates` returns a tuple where the first one is the df.</span>
                    <span class="c1"># Only takes ``past_df`` that are before ``df``.</span>
                    <span class="n">past_df</span> <span class="o">=</span> <span class="n">past_df</span><span class="p">[</span><span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">expected_last_timestamp</span><span class="p">]</span>
                <span class="n">autoreg_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_autoreg_features</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>
                    <span class="n">autoreg_func</span><span class="o">=</span><span class="n">autoreg_func</span><span class="p">,</span>
                    <span class="n">phase</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span>
                    <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">)</span>
                <span class="n">features_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">features_df</span><span class="p">,</span> <span class="n">autoreg_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Adds lagged regressor columns to feature matrix</span>
        <span class="n">lagged_regressor_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">lagged_regressor_col_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lagged_regressor_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">min_lagged_regressor_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_lagged_regressor_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">lagged_regressor_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lagged_regressor_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The method </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> is not implemented.&quot;</span><span class="p">)</span>
                    <span class="n">lag_reg_dict_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_default_lagged_regressor_dict</span><span class="p">(</span>
                        <span class="n">freq_in_days</span><span class="o">=</span><span class="n">inferred_freq_in_days</span><span class="p">,</span>
                        <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">)</span>
                    <span class="c1"># If &quot;auto&quot; determines that no lag is needed, remove the key</span>
                    <span class="k">if</span> <span class="n">lag_reg_dict_info</span><span class="p">[</span><span class="s2">&quot;lag_reg_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">key_remove</span> <span class="o">+=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lagged_regressor_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">lag_reg_dict_info</span><span class="p">[</span><span class="s2">&quot;lag_reg_dict&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">key_remove</span><span class="p">:</span>
                <span class="n">lagged_regressor_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> has been dropped from `lagged_regressor_dict` and was not &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;used for lagged regressor as determined by &#39;auto&#39; option.&quot;</span><span class="p">,</span> <span class="n">LoggingLevelEnum</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="c1"># Converts empty dictionary to None if all keys are removed</span>
        <span class="k">if</span> <span class="n">lagged_regressor_dict</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="n">lagged_regressor_dict</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">has_lagged_regressor_structure</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">lagged_regressor_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">has_lagged_regressor_structure</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">lagged_regressor_components</span> <span class="o">=</span> <span class="n">build_autoreg_df_multi</span><span class="p">(</span><span class="n">value_lag_info_dict</span><span class="o">=</span><span class="n">lagged_regressor_dict</span><span class="p">)</span>
            <span class="n">lagged_regressor_func</span> <span class="o">=</span> <span class="n">lagged_regressor_components</span><span class="p">[</span><span class="s2">&quot;autoreg_func&quot;</span><span class="p">]</span>
            <span class="n">lagged_regressor_col_names</span> <span class="o">=</span> <span class="n">lagged_regressor_components</span><span class="p">[</span><span class="s2">&quot;autoreg_col_names&quot;</span><span class="p">]</span>
            <span class="n">lagged_regressor_cols</span> <span class="o">=</span> <span class="n">lagged_regressor_components</span><span class="p">[</span><span class="s2">&quot;autoreg_orig_col_names&quot;</span><span class="p">]</span>
            <span class="n">min_lagged_regressor_order</span> <span class="o">=</span> <span class="n">lagged_regressor_components</span><span class="p">[</span><span class="s2">&quot;min_order&quot;</span><span class="p">]</span>
            <span class="n">max_lagged_regressor_order</span> <span class="o">=</span> <span class="n">lagged_regressor_components</span><span class="p">[</span><span class="s2">&quot;max_order&quot;</span><span class="p">]</span>

            <span class="n">lagged_regressor_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_lagged_regressor_features</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                <span class="n">lagged_regressor_cols</span><span class="o">=</span><span class="n">lagged_regressor_cols</span><span class="p">,</span>
                <span class="n">lagged_regressor_func</span><span class="o">=</span><span class="n">lagged_regressor_func</span><span class="p">,</span>
                <span class="n">phase</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span>
                <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">features_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">features_df</span><span class="p">,</span> <span class="n">lagged_regressor_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">features_df</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># prediction cols</span>
        <span class="c1"># (Includes growth, interactions, if specified in extra_pred_cols)</span>
        <span class="n">pred_cols</span> <span class="o">=</span> <span class="n">extra_pred_cols</span> <span class="o">+</span> <span class="n">fs_cols</span>
        <span class="k">if</span> <span class="n">changepoint_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pred_cols</span> <span class="o">=</span> <span class="n">pred_cols</span> <span class="o">+</span> <span class="n">changepoint_cols</span>
        <span class="k">if</span> <span class="n">seasonality_changepoint_cols</span><span class="p">:</span>
            <span class="n">pred_cols</span> <span class="o">=</span> <span class="n">pred_cols</span> <span class="o">+</span> <span class="n">seasonality_changepoint_cols</span>
        <span class="k">if</span> <span class="n">lag_col_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pred_cols</span> <span class="o">=</span> <span class="n">pred_cols</span> <span class="o">+</span> <span class="n">lag_col_names</span>
        <span class="k">if</span> <span class="n">agg_lag_col_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pred_cols</span> <span class="o">=</span> <span class="n">pred_cols</span> <span class="o">+</span> <span class="n">agg_lag_col_names</span>
        <span class="k">if</span> <span class="n">lagged_regressor_col_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pred_cols</span> <span class="o">=</span> <span class="n">pred_cols</span> <span class="o">+</span> <span class="n">lagged_regressor_col_names</span>

        <span class="n">pred_cols</span> <span class="o">=</span> <span class="n">unique_elements_in_list</span><span class="p">(</span><span class="n">pred_cols</span><span class="p">)</span>
        <span class="c1"># Drops un-desired predictors</span>
        <span class="k">if</span> <span class="n">drop_pred_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pred_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">pred_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_pred_cols</span><span class="p">]</span>

        <span class="c1"># Only uses predictors appearing in ``explicit_pred_cols``</span>
        <span class="k">if</span> <span class="n">explicit_pred_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pred_cols</span> <span class="o">=</span> <span class="n">explicit_pred_cols</span>

        <span class="c1"># Makes sure we don&#39;t have an empty regressor string, which will cause patsy formula error.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pred_cols</span><span class="p">:</span>
            <span class="n">pred_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">]</span>
        <span class="n">explan_str</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pred_cols</span><span class="p">)</span>
        <span class="n">model_formula_str</span> <span class="o">=</span> <span class="n">value_col</span> <span class="o">+</span> <span class="s2">&quot;~&quot;</span> <span class="o">+</span> <span class="n">explan_str</span>
        <span class="n">ind_train</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ind_test</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">train_test_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">train_test_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">ind_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">train_test_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">trained_model</span> <span class="o">=</span> <span class="n">fit_ml_model_with_evaluation</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">features_df</span><span class="p">,</span>
            <span class="n">model_formula_str</span><span class="o">=</span><span class="n">model_formula_str</span><span class="p">,</span>
            <span class="n">fit_algorithm</span><span class="o">=</span><span class="n">fit_algorithm</span><span class="p">,</span>
            <span class="n">fit_algorithm_params</span><span class="o">=</span><span class="n">fit_algorithm_params</span><span class="p">,</span>
            <span class="n">ind_train</span><span class="o">=</span><span class="n">ind_train</span><span class="p">,</span>
            <span class="n">ind_test</span><span class="o">=</span><span class="n">ind_test</span><span class="p">,</span>
            <span class="n">training_fraction</span><span class="o">=</span><span class="n">training_fraction</span><span class="p">,</span>
            <span class="n">randomize_training</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">min_admissible_value</span><span class="o">=</span><span class="n">min_admissible_value</span><span class="p">,</span>
            <span class="n">max_admissible_value</span><span class="o">=</span><span class="n">max_admissible_value</span><span class="p">,</span>
            <span class="n">uncertainty_dict</span><span class="o">=</span><span class="n">uncertainty_dict</span><span class="p">,</span>
            <span class="n">normalize_method</span><span class="o">=</span><span class="n">normalize_method</span><span class="p">,</span>
            <span class="n">regression_weight_col</span><span class="o">=</span><span class="n">regression_weight_col</span><span class="p">,</span>
            <span class="n">remove_intercept</span><span class="o">=</span><span class="n">remove_intercept</span><span class="p">)</span>

        <span class="c1"># Normalizes the changepoint_values</span>
        <span class="n">normalized_changepoint_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__normalize_changepoint_values</span><span class="p">(</span>
            <span class="n">changepoint_values</span><span class="o">=</span><span class="n">changepoint_values</span><span class="p">,</span>
            <span class="n">pred_cols</span><span class="o">=</span><span class="n">pred_cols</span><span class="p">,</span>
            <span class="n">continuous_time_col</span><span class="o">=</span><span class="n">continuous_time_col</span><span class="p">,</span>
            <span class="n">normalize_df_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;normalize_df_func&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Excludes points with NA that are not used in fitting, similar to &quot;y&quot; and &quot;x_mat&quot;.</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;df_dropna&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="c1"># Includes points with NA</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;df&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;num_training_points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_training_points</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;features_df&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">features_df</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;min_timestamp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_timestamp</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_timestamp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_timestamp</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;inferred_freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inferred_freq</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;inferred_freq_in_secs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inferred_freq_in_secs</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;inferred_freq_in_days&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inferred_freq_in_days</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_col</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_col</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;origin_for_time_vars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">origin_for_time_vars</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fs_components_df&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs_components_df</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;autoreg_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">autoreg_dict</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;lagged_regressor_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lagged_regressor_dict</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;lagged_regressor_cols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lagged_regressor_cols</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;normalize_method&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_method</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_df_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">daily_event_df_dict</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_neighbor_impact&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">daily_event_neighbor_impact</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_shifted_effect&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">daily_event_shifted_effect</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;changepoints_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">changepoints_dict</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;changepoint_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">changepoint_values</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;normalized_changepoint_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalized_changepoint_values</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;continuous_time_col&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">continuous_time_col</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;growth_func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">growth_func</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fs_func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs_func</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;has_autoreg_structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">has_autoreg_structure</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;autoreg_func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">autoreg_func</span>
        <span class="c1"># ``past_df`` has been manipulated to have all timestamps (could be with NA) and immediately</span>
        <span class="c1"># precedes ``df``. If ``past_df`` is not None, the stored ``past_df`` will be the concatenation of</span>
        <span class="c1"># ``past_df`` and ``df``. Otherwise it will be ``df``.</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;train_df&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">past_df</span><span class="p">,</span> <span class="n">df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;min_lag_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_lag_order</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_lag_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_lag_order</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;has_lagged_regressor_structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">has_lagged_regressor_structure</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;lagged_regressor_func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lagged_regressor_func</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;min_lagged_regressor_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_lagged_regressor_order</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_lagged_regressor_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_lagged_regressor_order</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">uncertainty_dict</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;pred_cols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred_cols</span>  <span class="c1"># predictor column names</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;last_date_for_fit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;trend_changepoint_dates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trend_changepoint_dates</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;changepoint_detector&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">changepoint_detector_class</span>  <span class="c1"># the ChangepointDetector class with detection results</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;seasonality_changepoint_dates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seasonality_changepoints</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;seasonality_changepoint_result&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seasonality_changepoint_result</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fit_algorithm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_algorithm</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fit_algorithm_params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_algorithm_params</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;adjust_anomalous_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_anomalous_info</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;impute_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">impute_info</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;forecast_horizon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_horizon</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;forecast_horizon_in_days&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_horizon_in_days</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;forecast_horizon_in_timedelta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_horizon_in_timedelta</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;simulation_based&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">simulation_based</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;simulation_num&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">simulation_num</span>
        <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fast_simulation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fast_simulation</span>

        <span class="k">return</span> <span class="n">trained_model</span></div>

<div class="viewcode-block" id="SilverkiteForecast.predict_no_sim"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.predict_no_sim">[docs]</a>    <span class="k">def</span> <span class="nf">predict_no_sim</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">time_features_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">regressors_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs predictions for the dates in ``fut_df``.</span>
<span class="sd">        If ``extra_pred_cols`` refers to a column in ``df``, either ``fut_df``</span>
<span class="sd">        or ``new_external_regressor_df`` must contain the regressors and the columns needed for lagged regressors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        fut_df: `pandas.DataFrame`</span>
<span class="sd">            The data frame which includes the timestamps.</span>
<span class="sd">            for prediction and any regressors.</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``.</span>
<span class="sd">        past_df: `pandas.DataFrame`, optional</span>
<span class="sd">            A data frame with past values if autoregressive methods are called</span>
<span class="sd">            via autoreg_dict parameter of ``greykite.algo.forecast.silverkite.SilverkiteForecast.py``.</span>
<span class="sd">        new_external_regressor_df : `pandas.DataFrame`, optional</span>
<span class="sd">            Contains the regressors not already included in `fut_df`.</span>
<span class="sd">        time_features_ready : `bool`</span>
<span class="sd">            Boolean to denote if time features are already given in df or not.</span>
<span class="sd">        regressors_ready : `bool`</span>
<span class="sd">            Boolean to denote if regressors are already added to data (``fut_df``).</span>

<span class="sd">        Return</span>
<span class="sd">        --------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items</span>

<span class="sd">            - &quot;fut_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The same as input dataframe with an added column for the response.</span>
<span class="sd">                If value_col already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">                If ``uncertainty_dict`` is provided as input,</span>
<span class="sd">                it will also contain a ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                Design matrix of the predictive machine-learning model</span>
<span class="sd">            - &quot;features_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The features dataframe used for prediction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">time_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]</span>
        <span class="n">value_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">]</span>
        <span class="n">max_lag_order</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_lag_order&quot;</span><span class="p">]</span>
        <span class="n">max_lagged_regressor_order</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_lagged_regressor_order&quot;</span><span class="p">]</span>
        <span class="n">min_lagged_regressor_order</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;min_lagged_regressor_order&quot;</span><span class="p">]</span>
        <span class="n">lagged_regressor_cols</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;lagged_regressor_cols&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">max_lag_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">past_df</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">past_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_lag_order</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The autoregression lags data had to be interpolated at predict time.&quot;</span>
                <span class="s2">&quot;`past_df` was either not passed to `predict_silverkite` &quot;</span>
                <span class="s2">&quot;or it was not long enough to calculate all necessery lags &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;which is equal to `max_lag_order`=</span><span class="si">{</span><span class="n">max_lag_order</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_lagged_regressor_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">past_df</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">past_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_lagged_regressor_order</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The lagged regressor data had to be interpolated at predict time.&quot;</span>
                <span class="s2">&quot;`past_df` was either not passed to `predict_silverkite` &quot;</span>
                <span class="s2">&quot;or it was not long enough to calculate all necessery lags &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;which is equal to `max_lagged_regressor_order`=</span><span class="si">{</span><span class="n">max_lagged_regressor_order</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># This is the overall maximum lag order</span>
        <span class="n">max_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_lag_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_lagged_regressor_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span>
                <span class="n">max_lag_order</span><span class="p">,</span>
                <span class="n">max_lagged_regressor_order</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">max_lag_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="n">max_lag_order</span>
        <span class="k">elif</span> <span class="n">max_lagged_regressor_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="n">max_lagged_regressor_order</span>
        <span class="c1"># We only keep the rows needed in ``past_df``</span>
        <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">past_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_order</span><span class="p">:</span>
            <span class="n">past_df</span> <span class="o">=</span> <span class="n">past_df</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="n">max_order</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># adds extra regressors if provided</span>
        <span class="k">if</span> <span class="n">new_external_regressor_df</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">regressors_ready</span><span class="p">:</span>
            <span class="n">features_df_fut</span> <span class="o">=</span> <span class="n">fut_df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_external_regressor_df</span> <span class="o">=</span> <span class="n">new_external_regressor_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span>
                <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">features_df_fut</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">fut_df</span><span class="p">,</span> <span class="n">new_external_regressor_df</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># adds the other features</span>
        <span class="k">if</span> <span class="n">time_features_ready</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">features_df_fut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_silverkite_features</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">features_df_fut</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">],</span>
                <span class="n">origin_for_time_vars</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;origin_for_time_vars&quot;</span><span class="p">],</span>
                <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_df_dict&quot;</span><span class="p">],</span>
                <span class="n">daily_event_neighbor_impact</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_neighbor_impact&quot;</span><span class="p">],</span>
                <span class="n">daily_event_shifted_effect</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_shifted_effect&quot;</span><span class="p">],</span>
                <span class="n">changepoint_values</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;changepoint_values&quot;</span><span class="p">],</span>
                <span class="n">continuous_time_col</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;continuous_time_col&quot;</span><span class="p">],</span>
                <span class="n">growth_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;growth_func&quot;</span><span class="p">],</span>
                <span class="n">fs_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fs_func&quot;</span><span class="p">],</span>
                <span class="n">seasonality_changepoint_result</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;seasonality_changepoint_result&quot;</span><span class="p">],</span>
                <span class="n">changepoint_dates</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;trend_changepoint_dates&quot;</span><span class="p">])</span>

        <span class="c1"># adds autoregression columns to future feature matrix</span>
        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;autoreg_func&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Autoregression was used but no past_df was passed to &quot;</span>
                    <span class="s2">&quot;`predict_no_sim`&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the timestamps in ``fut_df`` are all before ``train_end_timestamp``,</span>
                <span class="c1"># then the phase is to calculate fitted values.</span>
                <span class="c1"># In this case if there are any values in ``fut_df``,</span>
                <span class="c1"># they can be used since the information is known by ``train_end_timestamp``.</span>
                <span class="n">train_end_timestamp</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_timestamp&quot;</span><span class="p">]</span>
                <span class="n">fut_df_max_timestamp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">fut_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">phase</span> <span class="o">=</span> <span class="s2">&quot;predict&quot;</span> <span class="k">if</span> <span class="n">train_end_timestamp</span> <span class="o">&lt;</span> <span class="n">fut_df_max_timestamp</span> <span class="k">else</span> <span class="s2">&quot;fit&quot;</span>
                <span class="k">if</span> <span class="n">phase</span> <span class="o">==</span> <span class="s2">&quot;predict&quot;</span><span class="p">:</span>
                    <span class="c1"># If phase is predict, we do not allow using ``value_col``.</span>
                    <span class="c1"># The AR lags should be enough since otherwise one would use ``predict_via_sim``.</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">value_col</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If phase is fit, we keep the values in ``value_col``.</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="p">[[</span><span class="n">value_col</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">autoreg_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_autoreg_features</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">value_col</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">],</span>
                    <span class="n">autoreg_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;autoreg_func&quot;</span><span class="p">],</span>
                    <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span>
                    <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">[[</span><span class="n">value_col</span><span class="p">]])</span>
                <span class="n">features_df_fut</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">features_df_fut</span><span class="p">,</span> <span class="n">autoreg_df</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># adds lagged regressor columns to future feature matrix</span>
        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;lagged_regressor_func&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Lagged regressor(s) were used but no past_df was passed to &quot;</span>
                    <span class="s2">&quot;`predict_no_sim`&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># `build_lagged_regressor_features` requires both ``df`` and ``past_df``</span>
                <span class="c1"># to contain the columns needed for lagged regressors</span>
                <span class="c1"># case 1: ``min_lagged_regressor_order`` &gt;= ``fut_df.shape[0]``</span>
                <span class="c1"># In this case we do not need ``fut_df`` to contain any values for</span>
                <span class="c1"># those columns, but we do need to make sure these columns are included</span>
                <span class="c1"># as required by `build_lagged_regressor_features`.</span>
                <span class="k">if</span> <span class="n">min_lagged_regressor_order</span> <span class="o">&gt;=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">lagged_regressor_cols</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                            <span class="n">features_df_fut</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="c1"># case 2: ``min_lagged_regressor_order`` &lt; ``fut_df.shape[0]``</span>
                <span class="c1"># In this case ``fut_df`` has to contain those columns, and an error</span>
                <span class="c1"># will be raised when `build_lagged_regressor_features` is called.</span>
                <span class="n">lagged_regressor_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_lagged_regressor_features</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">features_df_fut</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">lagged_regressor_cols</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;lagged_regressor_cols&quot;</span><span class="p">],</span>
                    <span class="n">lagged_regressor_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;lagged_regressor_func&quot;</span><span class="p">],</span>
                    <span class="n">phase</span><span class="o">=</span><span class="s2">&quot;predict&quot;</span><span class="p">,</span>
                    <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">[</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;lagged_regressor_cols&quot;</span><span class="p">]])</span>
                <span class="n">features_df_fut</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">features_df_fut</span><span class="p">,</span> <span class="n">lagged_regressor_df</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value_col</span> <span class="ow">in</span> <span class="n">features_df_fut</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># This is to remove duplicate ``value_col`` generated by building features.</span>
            <span class="c1"># The duplicates happen during calculating extended fitted values</span>
            <span class="c1"># when we intentionally include ``value_col``.</span>
            <span class="k">del</span> <span class="n">features_df_fut</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span>
        <span class="n">features_df_fut</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># predictions are stored to ``value_col``</span>
            <span class="n">pred_res</span> <span class="o">=</span> <span class="n">predict_ml</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">features_df_fut</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">)</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
            <span class="n">x_mat</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># predictions are stored to ``value_col``</span>
            <span class="c1"># quantiles are stored to ``QUANTILE_SUMMARY_COL``</span>
            <span class="n">pred_res</span> <span class="o">=</span> <span class="n">predict_ml_with_uncertainty</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">features_df_fut</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">)</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
            <span class="n">x_mat</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>

        <span class="c1"># Makes sure to return only necessary columns</span>
        <span class="n">potential_forecast_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_col</span><span class="p">,</span> <span class="n">value_col</span><span class="p">,</span> <span class="n">QUANTILE_SUMMARY_COL</span><span class="p">,</span> <span class="n">ERR_STD_COL</span><span class="p">]</span>
        <span class="n">existing_forecast_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">potential_forecast_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="p">[</span><span class="n">existing_forecast_cols</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;fut_df&quot;</span><span class="p">:</span> <span class="n">fut_df</span><span class="p">,</span>
            <span class="s2">&quot;x_mat&quot;</span><span class="p">:</span> <span class="n">x_mat</span><span class="p">,</span>
            <span class="s2">&quot;features_df&quot;</span><span class="p">:</span> <span class="n">features_df_fut</span><span class="p">}</span></div>

<div class="viewcode-block" id="SilverkiteForecast.predict_n_no_sim"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.predict_n_no_sim">[docs]</a>    <span class="k">def</span> <span class="nf">predict_n_no_sim</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_time_num</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">time_features_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">regressors_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is the forecast function which can be used to forecast.</span>
<span class="sd">        It accepts extra regressors (``extra_pred_cols``) originally in</span>
<span class="sd">        ``df`` via ``new_external_regressor_df``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_time_num : `int`</span>
<span class="sd">            number of needed future values</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``</span>
<span class="sd">        freq : `str`</span>
<span class="sd">            Frequency of future predictions.</span>
<span class="sd">            Accepts any valid frequency for ``pd.date_range``.</span>
<span class="sd">        new_external_regressor_df : `pandas.DataFrame` or None</span>
<span class="sd">            Contains the extra regressors if specified.</span>
<span class="sd">        time_features_ready : `bool`</span>
<span class="sd">            Boolean to denote if time features are already given in df or not.</span>
<span class="sd">        regressors_ready : `bool`</span>
<span class="sd">            Boolean to denote if regressors are already added to data (``fut_df``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items</span>

<span class="sd">            - &quot;fut_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The same as input dataframe with an added column for the response.</span>
<span class="sd">                If value_col already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">                If ``uncertainty_dict`` is provided as input,</span>
<span class="sd">                it will also contain a ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                Design matrix of the predictive machine-learning model</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># creates the future time grid</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;last_date_for_fit&quot;</span><span class="p">],</span>
            <span class="n">periods</span><span class="o">=</span><span class="n">fut_time_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">dates</span> <span class="o">&gt;</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;last_date_for_fit&quot;</span><span class="p">]]</span>  <span class="c1"># drops values up to last_date_for_fit</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]:</span> <span class="n">dates</span><span class="o">.</span><span class="n">tolist</span><span class="p">()})</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_no_sim</span><span class="p">(</span>
            <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;df&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>  <span class="c1"># observed data used for training the model</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="n">new_external_regressor_df</span><span class="p">,</span>
            <span class="n">time_features_ready</span><span class="o">=</span><span class="n">time_features_ready</span><span class="p">,</span>
            <span class="n">regressors_ready</span><span class="o">=</span><span class="n">regressors_ready</span><span class="p">)</span></div>

<div class="viewcode-block" id="SilverkiteForecast.simulate"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">time_features_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">regressors_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A function to simulate future series.</span>
<span class="sd">        If the fitted model supports uncertainty e.g. via ``uncertainty_dict``,</span>
<span class="sd">        errors are incorporated into the simulations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_df : `pandas.DataFrame`</span>
<span class="sd">            The data frame which includes the timestamps</span>
<span class="sd">            for prediction and any regressors.</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``.</span>
<span class="sd">        past_df : `pandas.DataFrame`, optional</span>
<span class="sd">            A data frame with past values if autoregressive methods are called</span>
<span class="sd">            via ``autoreg_dict`` parameter of ``greykite.algo.forecast.silverkite.SilverkiteForecast.py``</span>
<span class="sd">        new_external_regressor_df: `pandas.DataFrame`, optional</span>
<span class="sd">            Contains the regressors not already included in ``fut_df``.</span>
<span class="sd">        include_err : `bool`</span>
<span class="sd">            Boolean to determine if errors are to be incorporated in the simulations.</span>
<span class="sd">        time_features_ready : `bool`</span>
<span class="sd">            Boolean to denote if time features are already given in df or not.</span>
<span class="sd">        regressors_ready : `bool`</span>
<span class="sd">            Boolean to denote if regressors are already added to data (``fut_df``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items</span>

<span class="sd">            - &quot;fut_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The same as input dataframe with an added column for the response.</span>
<span class="sd">                If value_col already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">                If ``uncertainty_dict`` is provided as input,</span>
<span class="sd">                it will also contain a ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                Here are the expected columns:</span>

<span class="sd">                (1) A time column with the column name being ``trained_model[&quot;time_col&quot;]``</span>
<span class="sd">                (2) The predicted response in ``value_col`` column.</span>
<span class="sd">                (3) Quantile summary response in ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>
<span class="sd">                (4) Error std in `ERR_STD_COL` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>

<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                Design matrix of the predictive machine-learning model</span>
<span class="sd">            - &quot;features_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The features dataframe used for prediction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">)</span>
        <span class="n">past_df_sim</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">past_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fut_df_sim</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">time_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]</span>
        <span class="n">value_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">]</span>
        <span class="n">fut_df_sim</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">fut_df_sim</span> <span class="o">=</span> <span class="n">fut_df_sim</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="n">value_col</span><span class="p">:</span> <span class="s2">&quot;float64&quot;</span><span class="p">})</span>
        <span class="n">max_lag_order</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_lag_order&quot;</span><span class="p">]</span>
        <span class="n">max_lagged_regressor_order</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_lagged_regressor_order&quot;</span><span class="p">]</span>
        <span class="c1"># overall maximum lag order</span>
        <span class="n">max_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_lag_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_lagged_regressor_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span>
                <span class="n">max_lag_order</span><span class="p">,</span>
                <span class="n">max_lagged_regressor_order</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">max_lag_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="n">max_lag_order</span>
        <span class="k">elif</span> <span class="n">max_lagged_regressor_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="n">max_lagged_regressor_order</span>

        <span class="c1"># Only need to keep the last relevant rows to calculate AR terms</span>
        <span class="k">if</span> <span class="n">past_df_sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">past_df_sim</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_order</span><span class="p">:</span>
            <span class="n">past_df_sim</span> <span class="o">=</span> <span class="n">past_df_sim</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="n">max_order</span><span class="p">)</span>

        <span class="c1"># adds the other features</span>
        <span class="k">if</span> <span class="n">time_features_ready</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_silverkite_features</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">origin_for_time_vars</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;origin_for_time_vars&quot;</span><span class="p">],</span>
                <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_df_dict&quot;</span><span class="p">],</span>
                <span class="n">daily_event_neighbor_impact</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_neighbor_impact&quot;</span><span class="p">],</span>
                <span class="n">daily_event_shifted_effect</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_shifted_effect&quot;</span><span class="p">],</span>
                <span class="n">changepoint_values</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;changepoint_values&quot;</span><span class="p">],</span>
                <span class="n">continuous_time_col</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;continuous_time_col&quot;</span><span class="p">],</span>
                <span class="n">growth_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;growth_func&quot;</span><span class="p">],</span>
                <span class="n">fs_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fs_func&quot;</span><span class="p">],</span>
                <span class="n">seasonality_changepoint_result</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;seasonality_changepoint_result&quot;</span><span class="p">],</span>
                <span class="n">changepoint_dates</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;trend_changepoint_dates&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">new_external_regressor_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">regressors_ready</span><span class="p">:</span>
            <span class="n">new_external_regressor_df</span> <span class="o">=</span> <span class="n">new_external_regressor_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span>
                <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">fut_df</span><span class="p">,</span> <span class="n">new_external_regressor_df</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">x_mat_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">features_df_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">fut_df_sub</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df_sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;the subset dataframe must have only one row&quot;</span>

            <span class="n">pred_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_no_sim</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df_sub</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
                <span class="n">past_df</span><span class="o">=</span><span class="n">past_df_sim</span><span class="p">,</span>
                <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">time_features_ready</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">regressors_ready</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">fut_df_sub</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
            <span class="c1"># we expect the returned prediction will have only one row</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df_sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="n">x_mat</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
            <span class="n">features_df</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;features_df&quot;</span><span class="p">]</span>
            <span class="n">x_mat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_mat</span><span class="p">)</span>
            <span class="n">features_df_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">features_df</span><span class="p">)</span>

            <span class="n">fut_df_sim</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">fut_df_sub</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">include_err</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ERR_STD_COL</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">fut_df_sub</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                    <span class="n">scale</span> <span class="o">=</span> <span class="n">fut_df_sub</span><span class="p">[</span><span class="n">ERR_STD_COL</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                        <span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
                    <span class="n">fut_df_sim</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">fut_df_sub</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="o">+</span> <span class="n">err</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Error is requested via ``include_err = True``. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;However the std column (</span><span class="si">{</span><span class="n">ERR_STD_COL</span><span class="si">}</span><span class="s2">) &quot;</span>
                        <span class="s2">&quot;does not appear in the prediction&quot;</span><span class="p">)</span>

            <span class="c1"># Here after assigning values for future forecast, we clip the values based on ``min_admissible_value`` and ``max_admissible_value``</span>
            <span class="c1"># saved in ``trained_model``. The clip should only function when error terms are added, as ``predict_no_sim`` ensures the predicted</span>
            <span class="c1"># values (before errors are added) are bounded.</span>
            <span class="n">min_admissible_value</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;min_admissible_value&quot;</span><span class="p">]</span>
            <span class="n">max_admissible_value</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_admissible_value&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">min_admissible_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_admissible_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fut_df_sim</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                    <span class="n">a</span><span class="o">=</span><span class="n">fut_df_sim</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">value_col</span><span class="p">],</span>
                    <span class="n">a_min</span><span class="o">=</span><span class="n">min_admissible_value</span><span class="p">,</span>
                    <span class="n">a_max</span><span class="o">=</span><span class="n">max_admissible_value</span><span class="p">)</span>

            <span class="c1"># we get the last prediction value and concat that to the end of</span>
            <span class="c1"># ``past_df``</span>
            <span class="n">past_df_increment</span> <span class="o">=</span> <span class="n">fut_df_sim</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)[[</span><span class="n">value_col</span><span class="p">]]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">past_df_increment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">past_df_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">past_df_sim</span> <span class="o">=</span> <span class="n">past_df_increment</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">past_df_sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">past_df_sim</span><span class="p">,</span> <span class="n">past_df_increment</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Only need to keep the last relevant rows to calculate AR terms</span>
            <span class="k">if</span> <span class="n">past_df_sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">past_df_sim</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_order</span><span class="p">:</span>
                <span class="n">past_df_sim</span> <span class="o">=</span> <span class="n">past_df_sim</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="n">max_order</span><span class="p">)</span>
            <span class="n">past_df_sim</span> <span class="o">=</span> <span class="n">past_df_sim</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">x_mat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="n">x_mat_list</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># The index does not matter as we simply want to stack up the data</span>
            <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_mat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">),</span> <span class="s2">&quot;The design matrix size (number of rows) used in simulation must have same size as the input&quot;</span>

        <span class="n">features_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="n">features_df_list</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># The index does not matter as we simply want to stack up the data</span>
            <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">features_df</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">),</span> <span class="s2">&quot;The features data size (number of rows) used in simulation must have same size as the input&quot;</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;sim_df&quot;</span><span class="p">:</span> <span class="n">fut_df_sim</span><span class="p">[[</span><span class="n">time_col</span><span class="p">,</span> <span class="n">value_col</span><span class="p">]],</span>
            <span class="s2">&quot;x_mat&quot;</span><span class="p">:</span> <span class="n">x_mat</span><span class="p">,</span>
            <span class="s2">&quot;features_df&quot;</span><span class="p">:</span> <span class="n">features_df</span><span class="p">}</span></div>

<div class="viewcode-block" id="SilverkiteForecast.simulate_multi"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.simulate_multi">[docs]</a>    <span class="k">def</span> <span class="nf">simulate_multi</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A function to simulate future series.</span>
<span class="sd">        If the fitted model supports uncertainty e.g. via ``uncertainty_dict``,</span>
<span class="sd">        errors are incorporated into the simulations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_df : `pandas.DataFrame`</span>
<span class="sd">            The data frame which includes the timestamps</span>
<span class="sd">            for prediction and any regressors.</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``.</span>
<span class="sd">        simulation_num : `int`</span>
<span class="sd">            The number of simulated series,</span>
<span class="sd">            (each of which have the same number of rows as ``fut_df``)</span>
<span class="sd">            to be stacked up row-wise. This number must be larger than zero.</span>
<span class="sd">        past_df : `pandas.DataFrame`, optional</span>
<span class="sd">            A data frame with past values if autoregressive methods are called</span>
<span class="sd">            via ``autoreg_dict`` parameter of ``greykite.algo.forecast.silverkite.SilverkiteForecast.py``.</span>
<span class="sd">        new_external_regressor_df: `pandas.DataFrame`, optional</span>
<span class="sd">            Contains the regressors not already included in ``fut_df``.</span>
<span class="sd">        include_err : `bool`, optional, default None</span>
<span class="sd">            Boolean to determine if errors are to be incorporated in the simulations.</span>
<span class="sd">            If None, it will be set to True if uncertainty is passed to the model and</span>
<span class="sd">            otherwise will be set to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with follwing items</span>

<span class="sd">            - &quot;fut_df_sim&quot; : `pandas.DataFrame`</span>
<span class="sd">                Row-wise concatenation of dataframes each being the same as</span>
<span class="sd">                input dataframe (``fut_df``) with an added column for the response</span>
<span class="sd">                and a new column: &quot;sim_label&quot; to differentiate various simulations.</span>
<span class="sd">                The row number of the returned dataframe is:</span>
<span class="sd">                    ``simulation_num`` times the row number of ``fut_df``.</span>
<span class="sd">                If ``value_col`` already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                ``simulation_num`` copies of design matrix of the predictive machine-learning model</span>
<span class="sd">                concatenated. An extra index column (&quot;original_row_index&quot;)  is also added</span>
<span class="sd">                for aggregation when needed.</span>
<span class="sd">                Note that the all copies will be the same except for the case where</span>
<span class="sd">                auto-regression is utilized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">simulation_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;simulation number has to be a natural number.&quot;</span>

        <span class="k">if</span> <span class="n">include_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">include_err</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">include_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`include_err=True` was passed. &quot;</span>
                <span class="s2">&quot;However model does not support uncertainty. &quot;</span>
                <span class="s2">&quot;To support uncertainty pass `uncertainty_dict` to the model.&quot;</span><span class="p">)</span>

        <span class="n">value_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">]</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># reset_index returns a copy</span>

        <span class="n">fut_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_silverkite_features</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">],</span>
            <span class="n">origin_for_time_vars</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;origin_for_time_vars&quot;</span><span class="p">],</span>
            <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_df_dict&quot;</span><span class="p">],</span>
            <span class="n">daily_event_neighbor_impact</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_neighbor_impact&quot;</span><span class="p">],</span>
            <span class="n">daily_event_shifted_effect</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;daily_event_shifted_effect&quot;</span><span class="p">],</span>
            <span class="n">changepoint_values</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;changepoint_values&quot;</span><span class="p">],</span>
            <span class="n">continuous_time_col</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;continuous_time_col&quot;</span><span class="p">],</span>
            <span class="n">growth_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;growth_func&quot;</span><span class="p">],</span>
            <span class="n">fs_func</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fs_func&quot;</span><span class="p">],</span>
            <span class="n">seasonality_changepoint_result</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;seasonality_changepoint_result&quot;</span><span class="p">],</span>
            <span class="n">changepoint_dates</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;trend_changepoint_dates&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">new_external_regressor_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_external_regressor_df</span> <span class="o">=</span> <span class="n">new_external_regressor_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span>
                <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">fut_df</span><span class="p">,</span> <span class="n">new_external_regressor_df</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">one_sim_func</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Creates one simulation and labels it with ``label`` in an added</span>
<span class="sd">            column : &quot;sim_label&quot;</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">sim_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
                <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
                <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">include_err</span><span class="o">=</span><span class="n">include_err</span><span class="p">,</span>
                <span class="n">time_features_ready</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">regressors_ready</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sim_df</span> <span class="o">=</span> <span class="n">sim_res</span><span class="p">[</span><span class="s2">&quot;sim_df&quot;</span><span class="p">]</span>
            <span class="n">x_mat</span> <span class="o">=</span> <span class="n">sim_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
            <span class="n">sim_df</span><span class="p">[</span><span class="s2">&quot;sim_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
            <span class="c1"># ``x_mat`` does not necessarily have an index column.</span>
            <span class="c1"># We keep track of the original index, to be able to aggregate</span>
            <span class="c1"># across simulations later.</span>
            <span class="n">x_mat</span><span class="p">[</span><span class="s2">&quot;original_row_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">))</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;sim_df&quot;</span><span class="p">:</span> <span class="n">sim_df</span><span class="p">,</span>
                <span class="s2">&quot;x_mat&quot;</span><span class="p">:</span> <span class="n">x_mat</span><span class="p">}</span>

        <span class="n">sim_res_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">one_sim_func</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">simulation_num</span><span class="p">)]</span>
        <span class="n">sim_df_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim_res_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;sim_df&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">simulation_num</span><span class="p">)]</span>
        <span class="n">x_mat_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim_res_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">simulation_num</span><span class="p">)]</span>

        <span class="n">sim_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="n">sim_df_list</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># The index does not matter as we simply want to stack up the data</span>
            <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">sim_df</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim_df</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">x_mat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="n">x_mat_list</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># The index does not matter as we simply want to stack up the data</span>
            <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">sim_df</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim_df</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sim_df</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">)</span> <span class="o">*</span> <span class="n">simulation_num</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_mat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">)</span> <span class="o">*</span> <span class="n">simulation_num</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;sim_df&quot;</span><span class="p">:</span> <span class="n">sim_df</span><span class="p">,</span>
            <span class="s2">&quot;x_mat&quot;</span><span class="p">:</span> <span class="n">x_mat</span><span class="p">}</span></div>

<div class="viewcode-block" id="SilverkiteForecast.predict_via_sim"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.predict_via_sim">[docs]</a>    <span class="k">def</span> <span class="nf">predict_via_sim</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs predictions and calculate uncertainty using</span>
<span class="sd">        multiple simulations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_df : `pandas.DataFrame`</span>
<span class="sd">            The data frame which includes the timestamps for prediction</span>
<span class="sd">            and possibly regressors.</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``</span>
<span class="sd">        past_df : `pandas.DataFrame`, optional</span>
<span class="sd">            A data frame with past values if autoregressive methods are called</span>
<span class="sd">            via autoreg_dict parameter of ``greykite.algo.forecast.silverkite.SilverkiteForecast.py``</span>
<span class="sd">        new_external_regressor_df: `pandas.DataFrame`, optional</span>
<span class="sd">            Contains the regressors not already included in ``fut_df``.</span>
<span class="sd">        simulation_num : `int`, optional, default 10</span>
<span class="sd">            The number of simulated series to be used in prediction.</span>
<span class="sd">        include_err : `bool`, optional, default None</span>
<span class="sd">            Boolean to determine if errors are to be incorporated in the simulations.</span>
<span class="sd">            If None, it will be set to True if uncertainty is passed to the model and</span>
<span class="sd">            otherwise will be set to False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items</span>

<span class="sd">            - &quot;fut_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The same as input dataframe with an added column for the response.</span>
<span class="sd">                If value_col already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">                If ``uncertainty_dict`` is provided as input,</span>
<span class="sd">                it will also contain a ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                Here are the expected columns:</span>

<span class="sd">                (1) A time column with the column name being ``trained_model[&quot;time_col&quot;]``</span>
<span class="sd">                (2) The predicted response in ``value_col`` column.</span>
<span class="sd">                (3) Quantile summary response in ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>
<span class="sd">                (4) Error std in `ERR_STD_COL` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>

<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                Design matrix of the predictive machine-learning model</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">include_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">include_err</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">include_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`include_err=True` was passed. &quot;</span>
                <span class="s2">&quot;However model does not support uncertainty. &quot;</span>
                <span class="s2">&quot;To support uncertainty pass `uncertainty_dict` to the model.&quot;</span><span class="p">)</span>

        <span class="n">sim_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_multi</span><span class="p">(</span>
            <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="n">simulation_num</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="n">new_external_regressor_df</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="n">include_err</span><span class="p">)</span>
        <span class="n">sim_df</span> <span class="o">=</span> <span class="n">sim_res</span><span class="p">[</span><span class="s2">&quot;sim_df&quot;</span><span class="p">]</span>
        <span class="n">x_mat</span> <span class="o">=</span> <span class="n">sim_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">quantiles</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;params&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;quantiles&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">quantiles</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.975</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">quantile_summary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">quantiles</span><span class="p">))</span>

        <span class="n">value_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">]</span>
        <span class="n">time_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]</span>
        <span class="n">agg_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">value_col</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">quantile_summary</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">]}</span>
        <span class="n">agg_df</span> <span class="o">=</span> <span class="n">sim_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">time_col</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">agg_dict</span><span class="p">)</span>
        <span class="c1"># we flatten multi-index (result of aggregation)</span>
        <span class="n">agg_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">agg_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">agg_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">time_col</span><span class="p">,</span>
            <span class="n">value_col</span><span class="p">,</span>
            <span class="n">QUANTILE_SUMMARY_COL</span><span class="p">,</span>
            <span class="n">ERR_STD_COL</span><span class="p">]</span>

        <span class="c1"># When there is no uncertainty dict, the uncertainty columns are NA.</span>
        <span class="c1"># In this case, we only keep the other two columns.</span>
        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">agg_df</span> <span class="o">=</span> <span class="n">agg_df</span><span class="p">[[</span><span class="n">time_col</span><span class="p">,</span> <span class="n">value_col</span><span class="p">]]</span>

        <span class="n">x_mat</span> <span class="o">=</span> <span class="n">x_mat</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;original_row_index&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">x_mat</span><span class="p">[</span><span class="s2">&quot;original_row_index&quot;</span><span class="p">]</span>
        <span class="c1"># Checks to see if ``x_mat`` has the right number of rows</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_mat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">agg_df</span><span class="p">)</span>
        <span class="c1"># Checks to see if predict ``x_mat`` has the same columns as fitted ``x_mat``</span>
        <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_mat</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;fut_df&quot;</span><span class="p">:</span> <span class="n">agg_df</span><span class="p">,</span>
            <span class="s2">&quot;x_mat&quot;</span><span class="p">:</span> <span class="n">x_mat</span><span class="p">,</span>
            <span class="s2">&quot;sim_res&quot;</span><span class="p">:</span> <span class="n">sim_res</span><span class="p">}</span></div>

<div class="viewcode-block" id="SilverkiteForecast.predict_via_sim_fast"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.predict_via_sim_fast">[docs]</a>    <span class="k">def</span> <span class="nf">predict_via_sim_fast</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs predictions and calculates uncertainty using</span>
<span class="sd">        one simulation of future and calculate the error separately</span>
<span class="sd">        (not relying on multiple simulations). Due to this the prediction</span>
<span class="sd">        intervals well into future will be narrower than ``predict_via_sim``</span>
<span class="sd">        and therefore less accurate. However there will be a major speed gain</span>
<span class="sd">        which might be important in some use cases.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_df : `pandas.DataFrame`</span>
<span class="sd">            The data frame which includes the timestamps for prediction</span>
<span class="sd">            and possibly regressors.</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``.</span>
<span class="sd">        past_df : `pandas.DataFrame` or None, default None</span>
<span class="sd">            A data frame with past values if autoregressive methods are called</span>
<span class="sd">            via ``autoreg_dict`` parameter of ``greykite.algo.forecast.silverkite.SilverkiteForecast.py``</span>
<span class="sd">        new_external_regressor_df: `pandas.DataFrame` or None, default None</span>
<span class="sd">            Contains the regressors not already included in ``fut_df``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items</span>

<span class="sd">            - &quot;fut_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The same as input dataframe with an added column for the response.</span>
<span class="sd">                If value_col already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">                If ``uncertainty_dict`` is provided as input,</span>
<span class="sd">                it will also contain a ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                Here are the expected columns:</span>

<span class="sd">                (1) A time column with the column name being ``trained_model[&quot;time_col&quot;]``</span>
<span class="sd">                (2) The predicted response in ``value_col`` column.</span>
<span class="sd">                (3) Quantile summary response in ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>
<span class="sd">                (4) Error std in `ERR_STD_COL` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>

<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                Design matrix of the predictive machine-learning model</span>
<span class="sd">            - &quot;features_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The features dataframe used for prediction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">time_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]</span>
        <span class="n">value_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">]</span>

        <span class="c1"># We only simulate one series without using any error during simulations</span>
        <span class="n">sim_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
            <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="n">new_external_regressor_df</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">x_mat</span> <span class="o">=</span> <span class="n">sim_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
        <span class="n">features_df</span> <span class="o">=</span> <span class="n">sim_res</span><span class="p">[</span><span class="s2">&quot;features_df&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># predictions are stored to ``value_col``</span>
            <span class="n">pred_res</span> <span class="o">=</span> <span class="n">predict_ml</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">features_df</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">)</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
            <span class="n">x_mat</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># predictions are stored to ``value_col``</span>
            <span class="c1"># quantiles are stored to ``QUANTILE_SUMMARY_COL``</span>
            <span class="n">pred_res</span> <span class="o">=</span> <span class="n">predict_ml_with_uncertainty</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">features_df</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">)</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
            <span class="n">x_mat</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>

        <span class="c1"># Makes sure to return only necessary columns</span>
        <span class="n">potential_forecast_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_col</span><span class="p">,</span> <span class="n">value_col</span><span class="p">,</span> <span class="n">QUANTILE_SUMMARY_COL</span><span class="p">,</span> <span class="n">ERR_STD_COL</span><span class="p">]</span>
        <span class="n">existing_forecast_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">potential_forecast_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="p">[</span><span class="n">existing_forecast_cols</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;fut_df&quot;</span><span class="p">:</span> <span class="n">fut_df</span><span class="p">,</span>
            <span class="s2">&quot;x_mat&quot;</span><span class="p">:</span> <span class="n">x_mat</span><span class="p">,</span>
            <span class="s2">&quot;features_df&quot;</span><span class="p">:</span> <span class="n">features_df</span><span class="p">}</span></div>

<div class="viewcode-block" id="SilverkiteForecast.predict_n_via_sim"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.predict_n_via_sim">[docs]</a>    <span class="k">def</span> <span class="nf">predict_n_via_sim</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_time_num</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">fast_simulation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is the forecast function which can be used to forecast.</span>
<span class="sd">        This function&#39;s predictions are constructed using simulations</span>
<span class="sd">        from the fitted series. This supports both ``predict_silverkite_via_sim``</span>
<span class="sd">        and ````predict_silverkite_via_sim_fast`` depending on value of the</span>
<span class="sd">        passed argument ``fast_simulation``.</span>

<span class="sd">        The ``past_df`` is set to be the training data which is available</span>
<span class="sd">        in ``trained_model``.</span>
<span class="sd">        It accepts extra regressors (``extra_pred_cols``) originally in</span>
<span class="sd">        ``df`` via ``new_external_regressor_df``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_time_num : `int`</span>
<span class="sd">            number of needed future values</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``</span>
<span class="sd">        freq : `str`</span>
<span class="sd">            Frequency of future predictions.</span>
<span class="sd">            Accepts any valid frequency for ``pd.date_range``.</span>
<span class="sd">        new_external_regressor_df : `pandas.DataFrame` or None</span>
<span class="sd">            Contains the extra regressors if specified.</span>
<span class="sd">        simulation_num : `int`, optional, default 10</span>
<span class="sd">            The number of simulated series to be used in prediction.</span>
<span class="sd">        fast_simulation: `bool`, default False</span>
<span class="sd">            Deterimes if fast simulations are to be used. This only impacts models</span>
<span class="sd">            which include auto-regression. This method will only generate one simulation</span>
<span class="sd">            without any error being added and then add the error using the volatility</span>
<span class="sd">            model. The advantage is a major boost in speed during inference and the</span>
<span class="sd">            disadvantage is potentially less accurate prediction intervals.</span>
<span class="sd">        include_err : `bool`, optional, default None</span>
<span class="sd">            Boolean to determine if errors are to be incorporated in the simulations.</span>
<span class="sd">            If None, it will be set to True if uncertainty is passed to the model and</span>
<span class="sd">            otherwise will be set to False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items</span>

<span class="sd">            - &quot;fut_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The same as input dataframe with an added column for the response.</span>
<span class="sd">                If value_col already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">                If ``uncertainty_dict`` is provided as input,</span>
<span class="sd">                it will also contain a ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                Here are the expected columns:</span>

<span class="sd">                (1) A time column with the column name being ``trained_model[&quot;time_col&quot;]``</span>
<span class="sd">                (2) The predicted response in ``value_col`` column.</span>
<span class="sd">                (3) Quantile summary response in ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>
<span class="sd">                (4) Error std in `ERR_STD_COL` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>

<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                Design matrix of the predictive machine-learning model</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">include_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">include_err</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">include_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`include_err=True` was passed. &quot;</span>
                <span class="s2">&quot;However model does not support uncertainty. &quot;</span>
                <span class="s2">&quot;To support uncertainty pass `uncertainty_dict` to the model.&quot;</span><span class="p">)</span>

        <span class="n">time_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]</span>
        <span class="n">value_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">]</span>
        <span class="c1"># creates the future time grid</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;last_date_for_fit&quot;</span><span class="p">],</span>
            <span class="n">periods</span><span class="o">=</span><span class="n">fut_time_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">dates</span> <span class="o">&gt;</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;last_date_for_fit&quot;</span><span class="p">]]</span>  <span class="c1"># drops values up to last_date_for_fit</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">time_col</span><span class="p">:</span> <span class="n">dates</span><span class="o">.</span><span class="n">tolist</span><span class="p">()})</span>

        <span class="n">past_df</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;df&quot;</span><span class="p">][[</span><span class="n">value_col</span><span class="p">]]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fast_simulation</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_via_sim_fast</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
                <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>  <span class="c1"># observed data used for training the model</span>
                <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="n">new_external_regressor_df</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_via_sim</span><span class="p">(</span>
            <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>  <span class="c1"># observed data used for training the model</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="n">new_external_regressor_df</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="n">simulation_num</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="n">include_err</span><span class="p">)</span></div>

<div class="viewcode-block" id="SilverkiteForecast.predict"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">force_no_sim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fast_simulation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">na_fill_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">interpolate</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs predictions using silverkite model.</span>
<span class="sd">        It determines if the prediction should be simulation-based or not and then</span>
<span class="sd">        predicts using that setting.</span>
<span class="sd">        The function determines if it should use simulation-based predictions or</span>
<span class="sd">        that is not necessary.</span>
<span class="sd">        Here is the logic for determining if simulations are needed:</span>

<span class="sd">        - If the model is not autoregressive, then clearly no simulations are needed</span>
<span class="sd">        - If the model is autoregressive, however the minimum lag appearing in the model</span>
<span class="sd">          is larger than the forecast horizon, then simulations are not needed.</span>
<span class="sd">          This is because the lags can be calculated fully without predicting the future.</span>

<span class="sd">        User can overwrite the above behavior and force no simulations using</span>
<span class="sd">        ``force_no_sim`` argument, in which case some lags will be imputed.</span>
<span class="sd">        This option should not be used by most users.</span>
<span class="sd">        Some scenarios where advanced user might want to use</span>
<span class="sd">        this is (a) when ``min_lag_order &gt;= forecast_horizon`` does not hold strictly</span>
<span class="sd">        but close to hold. (b) user want to predict fast, the autoregression</span>
<span class="sd">        lags are normalized. In that case the predictions returned could correspond</span>
<span class="sd">        to an approximation of a model without autoregression.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_df : `pandas.DataFrame`</span>
<span class="sd">            The data frame which includes the timestamps for prediction</span>
<span class="sd">            and possibly regressors.</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``</span>
<span class="sd">        freq : `str`, optional, default None</span>
<span class="sd">            Timeseries frequency, DateOffset alias.</span>
<span class="sd">            See https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases</span>
<span class="sd">            for the allowed strings.</span>
<span class="sd">            If None, it is extracted from ``trained_model`` input.</span>
<span class="sd">        past_df : `pandas.DataFrame` or None, default None</span>
<span class="sd">            A data frame with past values if autoregressive methods are called</span>
<span class="sd">            via autoreg_dict parameter of ``greykite.algo.forecast.silverkite.SilverkiteForecast.py``.</span>
<span class="sd">            Note that this ``past_df`` can be anytime before the training end timestamp, but can not</span>
<span class="sd">            exceed it.</span>
<span class="sd">        new_external_regressor_df: `pandas.DataFrame` or None, default None</span>
<span class="sd">            Contains the regressors not already included in ``fut_df``.</span>
<span class="sd">        include_err : `bool`, optional, default None</span>
<span class="sd">            Boolean to determine if errors are to be incorporated in the simulations.</span>
<span class="sd">            If None, it will be set to True if uncertainty is passed to the model and</span>
<span class="sd">            otherwise will be set to False</span>
<span class="sd">        force_no_sim : `bool`, default False</span>
<span class="sd">            If True, prediction with no simulations is forced.</span>
<span class="sd">            This can be useful when speed is of concern or for validation purposes.</span>
<span class="sd">            In this case, the potential non-available lags will be imputed.</span>
<span class="sd">            Most users should not set this to True as the consequences could be</span>
<span class="sd">            hard to quantify.</span>
<span class="sd">        simulation_num : `int` or None, default None</span>
<span class="sd">            The number of simulations for when simulations are used for generating</span>
<span class="sd">            forecasts and prediction intervals. If None, it will be inferred from</span>
<span class="sd">            the model (``trained_model``).</span>
<span class="sd">        fast_simulation: `bool` or None, default None</span>
<span class="sd">            Deterimes if fast simulations are to be used. This only impacts models</span>
<span class="sd">            which include auto-regression. This method will only generate one simulation</span>
<span class="sd">            without any error being added and then add the error using the volatility</span>
<span class="sd">            model. The advantage is a major boost in speed during inference and the</span>
<span class="sd">            disadvantage is potentially less accurate prediction intervals.</span>
<span class="sd">            If None, it will be inferred from the model (``trained_model``).</span>
<span class="sd">        na_fill_func : callable (`pd.DataFrame` -&gt; `pd.DataFrame`)</span>
<span class="sd">            default::</span>

<span class="sd">                lambda df: df.interpolate().bfill().ffill()</span>

<span class="sd">            A function which interpolates missing values in a dataframe.</span>
<span class="sd">            The main usage is invoked when there is a gap between the timestamps in ``fut_df``.</span>
<span class="sd">            The main use case is when the user wants to predict a period which is not an immediate period</span>
<span class="sd">            after training.</span>
<span class="sd">            In that case to fill in the gaps, the regressors need to be interpolated/filled.</span>
<span class="sd">            The default works by first interpolating the continuous variables.</span>
<span class="sd">            Then it uses back-filling and then forward-filling for categorical variables.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items</span>

<span class="sd">            - &quot;fut_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The same as input dataframe with an added column for the response.</span>
<span class="sd">                If value_col already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">                If ``uncertainty_dict`` is provided as input,</span>
<span class="sd">                it will also contain a ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                Here are the expected columns:</span>

<span class="sd">                (1) A time column with the column name being ``trained_model[&quot;time_col&quot;]``</span>
<span class="sd">                (2) The predicted response in ``value_col`` column.</span>
<span class="sd">                (3) Quantile summary response in ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>
<span class="sd">                (4) Error std in `ERR_STD_COL` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>

<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                Design matrix of the predictive machine-learning model</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">time_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]</span>
        <span class="n">value_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;value_col&quot;</span><span class="p">]</span>
        <span class="n">min_lag_order</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;min_lag_order&quot;</span><span class="p">]</span>
        <span class="n">max_lag_order</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_lag_order&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">simulation_num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">simulation_num</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;simulation_num&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">fast_simulation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fast_simulation</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fast_simulation&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;``fut_df`` must be a dataframe of non-zero size.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;``fut_df`` must include </span><span class="si">{</span><span class="n">time_col</span><span class="si">}</span><span class="s2"> as time column, &quot;</span>
                <span class="s2">&quot;which is what ``trained_model`` considers to be the time column.&quot;</span><span class="p">)</span>
        <span class="n">fut_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">fut_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>

        <span class="c1"># Handles ``past_df``.</span>
        <span class="n">training_past_df</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;train_df&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">past_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># In the case that we use ``train_df`` from the ``forecast`` method,</span>
            <span class="c1"># we don&#39;t check the quality since it&#39;s constructed by the method.</span>
            <span class="n">log_message</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;``past_df`` not provided during prediction, use the ``train_df`` from training results.&quot;</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="n">LoggingLevelEnum</span><span class="o">.</span><span class="n">DEBUG</span>
            <span class="p">)</span>
            <span class="c1"># The ``past_df`` has been manipulated in the training method to immediately precede the future periods.</span>
            <span class="n">past_df</span> <span class="o">=</span> <span class="n">training_past_df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In the case that ``past_df`` is passed, we combine it with the known dfs.</span>
            <span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">training_past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;``past_df`` can not have timestamps later than the training end timestamp.&quot;</span><span class="p">)</span>
            <span class="c1"># Combines ``past_df`` with ``training_past_df`` to get all available values.</span>
            <span class="n">past_df</span> <span class="o">=</span> <span class="p">(</span><span class="n">past_df</span>
                       <span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">training_past_df</span><span class="p">)</span>
                       <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">value_col</span><span class="p">])</span>
                       <span class="c1"># When there are duplicates, the value passed from ``past_df`` is kept.</span>
                       <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">time_col</span><span class="p">)</span>
                       <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                       <span class="p">)</span>
        <span class="c1"># Fills any missing timestamps in ``past_df``. These values will be imputed.</span>
        <span class="n">past_df</span> <span class="o">=</span> <span class="n">fill_missing_dates</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># `fill_missing_dates` returns a tuple where the first one is the df.</span>

        <span class="c1"># If ``value_col`` appears in user provided ``fut_df``,</span>
        <span class="c1"># we remove it to avoid issues in merging</span>
        <span class="c1"># also note that such column is unnecessary</span>
        <span class="k">if</span> <span class="n">value_col</span> <span class="ow">in</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">fut_df</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">include_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">include_err</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;uncertainty_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">include_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`include_err=True` was passed. &quot;</span>
                <span class="s2">&quot;However model does not support uncertainty. &quot;</span>
                <span class="s2">&quot;To support uncertainty pass `uncertainty_dict` to the model.&quot;</span><span class="p">)</span>

        <span class="c1"># If the minimal lag order for lagged regressors is less than the size of fut_df,</span>
        <span class="c1"># raise a warning of potential imputation of lagged regressor columns.</span>
        <span class="c1"># Note that all lagged regressor columns must be included in ``fut_df`` or ``new_external_regressor_df``</span>
        <span class="n">min_lagged_regressor_order</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;min_lagged_regressor_order&quot;</span><span class="p">]</span>
        <span class="n">lagged_regressor_dict</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s1">&#39;lagged_regressor_dict&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">min_lagged_regressor_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_lagged_regressor_order</span> <span class="o">&lt;</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Trained model&#39;s `min_lagged_regressor_order` (</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">min_lagged_regressor_order</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;is less than the size of `fut_df` (</span><span class="si">{</span><span class="n">fut_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;NaN values (if there are any) in lagged regressor columns have been imputed. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;More info: </span><span class="si">{</span><span class="n">lagged_regressor_dict</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">)</span>

        <span class="n">has_autoreg_structure</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;has_autoreg_structure&quot;</span><span class="p">]</span>

        <span class="c1"># In absence of autoregression, we can return quickly.</span>
        <span class="c1"># Also note ``fut_df`` can overlap with training times without any issues,</span>
        <span class="c1"># ``past_df`` is not needed for autoregression, but may be needed for lagged regression</span>
        <span class="c1"># and we do not need to track the overlap.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_autoreg_structure</span><span class="p">:</span>
            <span class="n">pred_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_no_sim</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
                <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
                <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="n">new_external_regressor_df</span><span class="p">,</span>
                <span class="n">time_features_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">regressors_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
            <span class="n">x_mat</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;fut_df&quot;</span><span class="p">:</span> <span class="n">fut_df</span><span class="p">,</span>
                <span class="s2">&quot;x_mat&quot;</span><span class="p">:</span> <span class="n">x_mat</span><span class="p">,</span>
                <span class="s2">&quot;simulations_not_used&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;fut_df_info&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;min_lag_order&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># From here we assume model has autoregression,</span>
        <span class="c1"># because otherwise we would have returned above.</span>

        <span class="c1"># Checks if imputation is needed.</span>
        <span class="c1"># Writes to log message if imputation is needed for debugging purposes.</span>
        <span class="c1"># This happens when</span>
        <span class="c1"># (1) ``past_df`` is too short and does not cover the earliest lag needed.</span>
        <span class="c1"># (2) ``past_df`` has missing values.</span>
        <span class="n">past_df_sufficient</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># The check happens when ``freq`` is not None.</span>
        <span class="c1"># We made sure ``freq`` is not None before but wanna add a safeguard.</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pred_min_ts</span> <span class="o">=</span> <span class="n">fut_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>  <span class="c1"># the prediction period&#39;s minimum timestamp</span>
            <span class="n">past_df_min_ts</span> <span class="o">=</span> <span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>  <span class="c1"># the past df&#39;s minimum timestamp</span>
            <span class="n">lag_min_ts_needed</span> <span class="o">=</span> <span class="n">pred_min_ts</span> <span class="o">-</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_lag_order</span>  <span class="c1"># the minimum timestamp needed (max lag)</span>
            <span class="c1"># Checks (1) if ``past_df`` covers the period after ``lag_min_ts_needed``.</span>
            <span class="n">past_df_sufficient</span> <span class="o">=</span> <span class="n">past_df_sufficient</span> <span class="ow">and</span> <span class="p">(</span><span class="n">past_df_min_ts</span> <span class="o">&lt;=</span> <span class="n">lag_min_ts_needed</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">past_df_sufficient</span><span class="p">:</span>
                <span class="c1"># Checks (2) if ``past_df`` has any missing value after ``lag_min_ts_needed``</span>
                <span class="n">past_df_after_min_ts</span> <span class="o">=</span> <span class="n">past_df</span><span class="p">[</span><span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lag_min_ts_needed</span><span class="p">]</span>
                <span class="n">past_df_sufficient</span> <span class="o">=</span> <span class="n">past_df_sufficient</span> <span class="ow">and</span> <span class="p">(</span><span class="n">past_df_after_min_ts</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">past_df_sufficient</span><span class="p">:</span>
            <span class="n">log_message</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;``past_df`` is not sufficient, imputation is performed when creating autoregression terms.&quot;</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="n">LoggingLevelEnum</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_external_regressor_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">fut_df</span><span class="p">,</span> <span class="n">new_external_regressor_df</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">fut_df_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_fut_df</span><span class="p">(</span>
            <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
            <span class="n">na_fill_func</span><span class="o">=</span><span class="n">na_fill_func</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

        <span class="n">fut_df_before_training</span> <span class="o">=</span> <span class="n">fut_df_info</span><span class="p">[</span><span class="s2">&quot;fut_df_before_training&quot;</span><span class="p">]</span>
        <span class="n">fut_df_within_training</span> <span class="o">=</span> <span class="n">fut_df_info</span><span class="p">[</span><span class="s2">&quot;fut_df_within_training&quot;</span><span class="p">]</span>
        <span class="n">fut_df_after_training_expanded</span> <span class="o">=</span> <span class="n">fut_df_info</span><span class="p">[</span><span class="s2">&quot;fut_df_after_training_expanded&quot;</span><span class="p">]</span>
        <span class="n">index_after_training_original</span> <span class="o">=</span> <span class="n">fut_df_info</span><span class="p">[</span><span class="s2">&quot;index_after_training_original&quot;</span><span class="p">]</span>

        <span class="n">inferred_forecast_horizon</span> <span class="o">=</span> <span class="n">fut_df_info</span><span class="p">[</span><span class="s2">&quot;inferred_forecast_horizon&quot;</span><span class="p">]</span>

        <span class="n">fut_df_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x_mat_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># We allow calculating extended fitted values on a longer backward</span>
        <span class="c1"># history with imputation if ``past_df`` is not sufficient.</span>
        <span class="k">if</span> <span class="n">fut_df_before_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_timestamp</span> <span class="o">=</span> <span class="n">fut_df_before_training</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">past_df_before_min_timestamp</span> <span class="o">=</span> <span class="n">past_df</span><span class="p">[</span><span class="n">past_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_timestamp</span><span class="p">]</span>
            <span class="c1"># Since ``fut_df_before_training`` does not have ``value_col`` (dropped above),</span>
            <span class="c1"># but we need the actual values for ``fut_df_before_training`` in case the lags</span>
            <span class="c1"># are not enough and we don&#39;t have simulation, we try to find the values from</span>
            <span class="c1"># ``past_df``. If some values are still missing, those values will be imputed.</span>
            <span class="n">fut_df_before_training</span> <span class="o">=</span> <span class="n">fut_df_before_training</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">past_df</span><span class="p">[[</span><span class="n">time_col</span><span class="p">,</span> <span class="n">value_col</span><span class="p">]],</span>
                <span class="n">on</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>
            <span class="c1"># Imputation will be done during ``self.predict_no_sim`` if ``past_df_before_min_timestamp``</span>
            <span class="c1"># does not have sufficient AR terms.</span>
            <span class="n">pred_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_no_sim</span><span class="p">(</span>
                <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df_before_training</span><span class="p">,</span>
                <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
                <span class="n">past_df</span><span class="o">=</span><span class="n">past_df_before_min_timestamp</span><span class="p">,</span>
                <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">time_features_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">regressors_ready</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fut_df0</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
            <span class="n">x_mat0</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
            <span class="n">fut_df_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fut_df0</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">x_mat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_mat0</span><span class="p">)</span>

        <span class="n">fitted_df</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;fitted_df&quot;</span><span class="p">]</span>
        <span class="n">fitted_x_mat</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
        <span class="n">potential_forecast_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_col</span><span class="p">,</span> <span class="n">value_col</span><span class="p">,</span> <span class="n">QUANTILE_SUMMARY_COL</span><span class="p">,</span> <span class="n">ERR_STD_COL</span><span class="p">]</span>
        <span class="n">existing_forecast_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">potential_forecast_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fitted_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">fitted_df</span> <span class="o">=</span> <span class="n">fitted_df</span><span class="p">[</span><span class="n">existing_forecast_cols</span><span class="p">]</span>

        <span class="c1"># For within training times, we simply use the fitted data</span>
        <span class="k">if</span> <span class="n">fut_df_within_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Creates a dummy index to get the consistent index on ``fitted_x_mat``</span>
            <span class="n">fut_df0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">fut_df_within_training</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">fitted_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>

            <span class="c1"># Finds out where ``fut_df_within_training`` intersects with ``fitted_df``</span>
            <span class="c1"># This is for edge cases where ```fut_df_within_training``` does not have all the</span>
            <span class="c1"># times appearing in ``fitted_df``</span>
            <span class="n">fut_df_within_training</span><span class="p">[</span><span class="s2">&quot;dummy_bool_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">fut_df_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">fut_df_within_training</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)[[</span><span class="n">time_col</span><span class="p">,</span> <span class="s2">&quot;dummy_bool_index&quot;</span><span class="p">]],</span>
                <span class="n">fitted_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)[[</span><span class="n">time_col</span><span class="p">]],</span>
                <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">time_col</span><span class="p">],</span>
                <span class="n">how</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">fut_df_index</span><span class="p">[</span><span class="s2">&quot;dummy_bool_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">fut_df_index</span>
            <span class="n">fitted_x_mat</span> <span class="o">=</span> <span class="n">fitted_x_mat</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">fut_df_within_training</span><span class="p">[</span><span class="s2">&quot;dummy_bool_index&quot;</span><span class="p">]</span>

            <span class="k">assert</span> <span class="n">fut_df0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fut_df_within_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">fut_df_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fut_df0</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">x_mat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fitted_x_mat</span><span class="p">)</span>

        <span class="c1"># The future timestamps need to be predicted</span>
        <span class="c1"># There are two cases: either simulations are needed or not</span>
        <span class="c1"># This is decided as follows:</span>
        <span class="n">simulations_not_used</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">has_autoreg_structure</span><span class="p">)</span> <span class="ow">or</span> <span class="n">force_no_sim</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">inferred_forecast_horizon</span> <span class="o">&lt;=</span> <span class="n">min_lag_order</span><span class="p">)</span>

        <span class="c1"># ``new_external_regressor_df`` will be passed as None</span>
        <span class="c1"># since it is already included in ``fut_df``.</span>
        <span class="c1"># ``past_df`` doesn&#39;t need to change because either (1) it is passed from</span>
        <span class="c1"># this ``predict`` method directly, in which case it should be immediately preceding the</span>
        <span class="c1"># ``fut_df_after_training_expanded``;</span>
        <span class="c1"># or (2) it is from the training model, where the last term is the last training timestamp,</span>
        <span class="c1"># which should also immediately precedes the ``fut_df_after_training_expanded``.</span>
        <span class="k">if</span> <span class="n">fut_df_after_training_expanded</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fut_df_after_training_expanded</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simulations_not_used</span><span class="p">:</span>
                <span class="n">pred_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_no_sim</span><span class="p">(</span>
                    <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df_after_training_expanded</span><span class="p">,</span>
                    <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
                    <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
                    <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">time_features_ready</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">regressors_ready</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">fut_df0</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
                <span class="n">x_mat0</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">fast_simulation</span><span class="p">:</span>
                <span class="n">pred_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_via_sim_fast</span><span class="p">(</span>
                    <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df_after_training_expanded</span><span class="p">,</span>
                    <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
                    <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
                    <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">fut_df0</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
                <span class="n">x_mat0</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pred_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_via_sim</span><span class="p">(</span>
                    <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df_after_training_expanded</span><span class="p">,</span>
                    <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
                    <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
                    <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">simulation_num</span><span class="o">=</span><span class="n">simulation_num</span><span class="p">,</span>
                    <span class="n">include_err</span><span class="o">=</span><span class="n">include_err</span><span class="p">)</span>
                <span class="n">fut_df0</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;fut_df&quot;</span><span class="p">]</span>
                <span class="n">x_mat0</span> <span class="o">=</span> <span class="n">pred_res</span><span class="p">[</span><span class="s2">&quot;x_mat&quot;</span><span class="p">]</span>
            <span class="n">fut_df0</span> <span class="o">=</span> <span class="n">fut_df0</span><span class="p">[</span><span class="n">index_after_training_original</span><span class="p">]</span>
            <span class="n">x_mat0</span> <span class="o">=</span> <span class="n">x_mat0</span><span class="p">[</span><span class="n">index_after_training_original</span><span class="p">]</span>
            <span class="n">fut_df_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fut_df0</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">x_mat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_mat0</span><span class="p">)</span>

        <span class="n">fut_df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="n">fut_df_list</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">x_mat_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="n">x_mat_list</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Makes sure to return only necessary columns</span>
        <span class="n">potential_forecast_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_col</span><span class="p">,</span> <span class="n">value_col</span><span class="p">,</span> <span class="n">QUANTILE_SUMMARY_COL</span><span class="p">,</span> <span class="n">ERR_STD_COL</span><span class="p">]</span>
        <span class="n">existing_forecast_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">potential_forecast_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fut_df_final</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">fut_df_final</span> <span class="o">=</span> <span class="n">fut_df_final</span><span class="p">[</span><span class="n">existing_forecast_cols</span><span class="p">]</span>

        <span class="c1"># Expects the created data has same size as the passed ``fut_df``</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df_final</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">),</span> <span class="s2">&quot;The generated data at predict phase must have same length as input ``fut_df``&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_mat_final</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">),</span> <span class="s2">&quot;The generated data at predict phase must have same length as input ``fut_df``&quot;</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;fut_df&quot;</span><span class="p">:</span> <span class="n">fut_df_final</span><span class="p">,</span>
            <span class="s2">&quot;x_mat&quot;</span><span class="p">:</span> <span class="n">x_mat_final</span><span class="p">,</span>
            <span class="s2">&quot;simulations_not_used&quot;</span><span class="p">:</span> <span class="n">simulations_not_used</span><span class="p">,</span>
            <span class="s2">&quot;fut_df_info&quot;</span><span class="p">:</span> <span class="n">fut_df_info</span><span class="p">,</span>
            <span class="s2">&quot;min_lag_order&quot;</span><span class="p">:</span> <span class="n">min_lag_order</span><span class="p">}</span></div>

<div class="viewcode-block" id="SilverkiteForecast.predict_n"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.predict_n">[docs]</a>    <span class="k">def</span> <span class="nf">predict_n</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_time_num</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">force_no_sim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fast_simulation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">na_fill_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">interpolate</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is the forecast function which can be used to forecast a number of</span>
<span class="sd">        periods into the future.</span>
<span class="sd">        It determines if the prediction should be simulation-based or not and then</span>
<span class="sd">        predicts using that setting. Currently if the silverkite model uses</span>
<span class="sd">        autoregression simulation-based prediction/CIs are used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_time_num : `int`</span>
<span class="sd">            number of needed future values</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of ``self.forecast``</span>
<span class="sd">        freq : `str`, optional, default None</span>
<span class="sd">            Timeseries frequency, DateOffset alias.</span>
<span class="sd">            See https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases</span>
<span class="sd">            for the allowed frequencies.</span>
<span class="sd">            If None, it is extracted from ``trained_model`` input.</span>
<span class="sd">        new_external_regressor_df : `pandas.DataFrame` or None</span>
<span class="sd">            Contains the extra regressors if specified.</span>
<span class="sd">        simulation_num : `int`, optional, default 10</span>
<span class="sd">            The number of simulated series to be used in prediction.</span>
<span class="sd">        fast_simulation: `bool` or None, default None</span>
<span class="sd">            Deterimes if fast simulations are to be used. This only impacts models</span>
<span class="sd">            which include auto-regression. This method will only generate one simulation</span>
<span class="sd">            without any error being added and then add the error using the volatility</span>
<span class="sd">            model. The advantage is a major boost in speed during inference and the</span>
<span class="sd">            disadvantage is potentially less accurate prediction intervals.</span>
<span class="sd">            If None, it will be inferred from the model (``trained_model``).</span>
<span class="sd">        include_err : `bool` or None, default None</span>
<span class="sd">            Boolean to determine if errors are to be incorporated in the simulations.</span>
<span class="sd">            If None, it will be set to True if uncertainty is passed to the model and</span>
<span class="sd">            otherwise will be set to False</span>
<span class="sd">        force_no_sim: `bool`, default False</span>
<span class="sd">            If True, prediction with no simulations is forced.</span>
<span class="sd">            This can be useful when speed is of concern or for validation purposes.</span>
<span class="sd">        na_fill_func : callable (`pd.DataFrame` -&gt; `pd.DataFrame`)</span>
<span class="sd">            default::</span>

<span class="sd">                lambda df: df.interpolate().bfill().ffill()</span>

<span class="sd">            A function which interpolated missing values in a dataframe.</span>
<span class="sd">            The main usage is invoked when there is a gap between the timestamps.</span>
<span class="sd">            In that case to fill in the gaps, the regressors need to be interpolated/filled.</span>
<span class="sd">            The default works by first interpolating the continuous variables.</span>
<span class="sd">            Then it uses back-filling and then forward-filling for categorical variables.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items</span>

<span class="sd">            - &quot;fut_df&quot;: `pandas.DataFrame`</span>
<span class="sd">                The same as input dataframe with an added column for the response.</span>
<span class="sd">                If value_col already appears in ``fut_df``, it will be over-written.</span>
<span class="sd">                If ``uncertainty_dict`` is provided as input,</span>
<span class="sd">                it will also contain a ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                Here are the expected columns:</span>

<span class="sd">                (1) A time column with the column name being ``trained_model[&quot;time_col&quot;]``</span>
<span class="sd">                (2) The predicted response in ``value_col`` column.</span>
<span class="sd">                (3) Quantile summary response in ``QUANTILE_SUMMARY_COL`` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>
<span class="sd">                (4) Error std in `ERR_STD_COL` column.</span>
<span class="sd">                    This column only appears if the model includes uncertainty.</span>

<span class="sd">            - &quot;x_mat&quot;: `pandas.DataFrame`</span>
<span class="sd">                Design matrix of the predictive machine-learning model</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span>
        <span class="c1"># Creates the future time grid</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;last_date_for_fit&quot;</span><span class="p">],</span>
            <span class="n">periods</span><span class="o">=</span><span class="n">fut_time_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">dates</span> <span class="o">&gt;</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;last_date_for_fit&quot;</span><span class="p">]]</span>  <span class="c1"># drops values up to last_date_for_fit</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]:</span> <span class="n">dates</span><span class="o">.</span><span class="n">tolist</span><span class="p">()})</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">fut_df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="o">=</span><span class="n">trained_model</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">,</span>
            <span class="n">new_external_regressor_df</span><span class="o">=</span><span class="n">new_external_regressor_df</span><span class="p">,</span>
            <span class="n">include_err</span><span class="o">=</span><span class="n">include_err</span><span class="p">,</span>
            <span class="n">force_no_sim</span><span class="o">=</span><span class="n">force_no_sim</span><span class="p">,</span>
            <span class="n">simulation_num</span><span class="o">=</span><span class="n">simulation_num</span><span class="p">,</span>
            <span class="n">fast_simulation</span><span class="o">=</span><span class="n">fast_simulation</span><span class="p">,</span>
            <span class="n">na_fill_func</span><span class="o">=</span><span class="n">na_fill_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="SilverkiteForecast.partition_fut_df"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SilverkiteForecast.partition_fut_df">[docs]</a>    <span class="k">def</span> <span class="nf">partition_fut_df</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fut_df</span><span class="p">,</span>
            <span class="n">trained_model</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">na_fill_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">interpolate</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function takes a dataframe ``fut_df`` which includes the timestamps to forecast</span>
<span class="sd">        and a ``trained_model`` returned by</span>
<span class="sd">        `~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`</span>
<span class="sd">        and decomposes</span>
<span class="sd">        ``fut_df`` to various dataframes which reflect if the timestamps are before,</span>
<span class="sd">        during or after the training periods.</span>
<span class="sd">        It also determines if: &#39;the future timestamps after the training period&#39; are immediately</span>
<span class="sd">        after &#39;the last training period&#39; or if there is some extra gap.</span>
<span class="sd">        In that case, this function creates an expanded dataframe which includes the missing</span>
<span class="sd">        timestamps as well.</span>
<span class="sd">        If ``fut_df`` also includes extra columns (they could be regressor columns),</span>
<span class="sd">        this function will interpolate the extra regressor columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fut_df : `pandas.DataFrame`</span>
<span class="sd">            The data frame which includes the timestamps for prediction</span>
<span class="sd">            and possibly regressors. Note that the timestamp column in ``fut_df``</span>
<span class="sd">            must be the same as ``trained_model[&quot;time_col&quot;]``.</span>
<span class="sd">            We assume ``fut_df[time_col]`` is pandas.datetime64 type.</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            A fitted silverkite model which is the output of</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`</span>
<span class="sd">        freq : `str`</span>
<span class="sd">            Timeseries frequency, DateOffset alias.</span>
<span class="sd">            See https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases</span>
<span class="sd">            for the allowed frequencies.</span>
<span class="sd">        na_fill_func : callable (`pd.DataFrame` -&gt; `pd.DataFrame`)</span>
<span class="sd">            default::</span>

<span class="sd">                lambda df: df.interpolate().bfill().ffill()</span>

<span class="sd">            A function which interpolated missing values in a dataframe.</span>
<span class="sd">            The main usage is invoked when there is a gap between the timestamps.</span>
<span class="sd">            In that case to fill in the gaps, the regressors need to be interpolated/filled.</span>
<span class="sd">            The default works by first interpolating the continuous variables.</span>
<span class="sd">            Then it uses back-filling and then forward-filling for categorical variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `dict`</span>
<span class="sd">            A dictionary with following items:</span>

<span class="sd">            - ``&quot;fut_freq_in_secs&quot;``: `float`</span>
<span class="sd">                The inferred frequency in ``fut_df``</span>
<span class="sd">            - ``&quot;training_freq_in_secs&quot;``: `float`</span>
<span class="sd">                The inferred frequency in training data</span>
<span class="sd">            - ``&quot;index_before_training&quot;``: `list` [`bool`]</span>
<span class="sd">                A boolean list to determine which rows of ``fut_df`` include a time</span>
<span class="sd">                which is before the training start.</span>
<span class="sd">            - ``&quot;index_within_training&quot;``: `list` [`bool`]</span>
<span class="sd">                A boolean list to determine which rows of ``fut_df`` include a time</span>
<span class="sd">                which is during the training period.</span>
<span class="sd">            - ``&quot;index_after_training&quot;``: `list` [`bool`]</span>
<span class="sd">                A boolean list to determine which rows of ``fut_df`` include a time</span>
<span class="sd">                which is after the training end date.</span>
<span class="sd">            - ``&quot;fut_df_before_training&quot;``: `pandas.DataFrame`</span>
<span class="sd">                A partition of ``fut_df`` with timestamps before the training start date</span>
<span class="sd">            - ``&quot;fut_df_within_training&quot;``: `pandas.DataFrame`</span>
<span class="sd">                A partition of ``fut_df`` with timestamps during the training period</span>
<span class="sd">            - ``&quot;fut_df_after_training&quot;``: `pandas.DataFrame`</span>
<span class="sd">                A partition of ``fut_df`` with timestamps after the training start date</span>
<span class="sd">            - ``&quot;fut_df_gap&quot;``: `pandas.DataFrame` or None</span>
<span class="sd">                If there is a gap between training end date and the first timestamp</span>
<span class="sd">                after the training end date in ``fut_df``, this dataframe can fill the</span>
<span class="sd">                gap between the two. In case ``fut_df`` includes extra columns as well,</span>
<span class="sd">                the values for those columns will be filled using ``na_fill_func``.</span>
<span class="sd">            - ``&quot;fut_df_after_training_expanded&quot;``: `pandas.DataFrame`</span>
<span class="sd">                If there is a gap between training end date and the first timestamp</span>
<span class="sd">                after the training end date in ``fut_df``, this dataframe will include</span>
<span class="sd">                the data for the gaps (``fut_df_gap``) as well as ``fut_df_after_training``.</span>
<span class="sd">            - ``&quot;index_after_training_original&quot;``: `list` [`bool`]</span>
<span class="sd">                A boolean list to determine which rows of ``fut_df_after_training_expanded``</span>
<span class="sd">                correspond to raw data passed by user which are after training end date,</span>
<span class="sd">                appearing in ``fut_df``.</span>
<span class="sd">                Note that this partition corresponds to ``fut_df_after_training``</span>
<span class="sd">                which is the subset of data in ``fut_df`` provided by user and</span>
<span class="sd">                also returned by this function.</span>
<span class="sd">            - ``&quot;missing_periods_num&quot;``: `int`</span>
<span class="sd">                Number of missing timestamps between the last date of training and</span>
<span class="sd">                first date in ``fut_df`` appearing after the training end date</span>
<span class="sd">            - ``&quot;inferred_forecast_horizon&quot;``: `int`</span>
<span class="sd">                This is the inferred forecast horizon from ``fut_df``.</span>
<span class="sd">                This is defined to be the distance between the last training end date</span>
<span class="sd">                and last date appearing in ``fut_df``.</span>
<span class="sd">                Note that this value can be smaller or larger than the number of</span>
<span class="sd">                rows of ``fut_df``.</span>
<span class="sd">                This is calculated by adding the number of potentially missing timestamps</span>
<span class="sd">                and the number of time periods appearing after the training end point.</span>
<span class="sd">                Also note if there are no timestamps after the training end point in</span>
<span class="sd">                ``fut_df``, this value will be zero.</span>
<span class="sd">            - ``&quot;forecast_partition_summary&quot;``: `dict`</span>
<span class="sd">                A dictionary which includes the size of various partitions of ``fut_df``</span>
<span class="sd">                as well as the missing timestamps if needed. The dictionary keys are as</span>
<span class="sd">                follows:</span>

<span class="sd">                    - ``&quot;len_before_training&quot;``: the number of time periods before training start</span>
<span class="sd">                    - ``&quot;len_within_training&quot;``: the number of time periods within training</span>
<span class="sd">                    - ``&quot;len_after_training&quot;``: the number of time periods after training</span>
<span class="sd">                    - ``&quot;len_gap&quot;``: the number of missing time periods between training data and</span>
<span class="sd">                      future time stamps in ``fut_df``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fut_df</span> <span class="o">=</span> <span class="n">fut_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">training_start_timestamp</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;min_timestamp&quot;</span><span class="p">]</span>
        <span class="n">training_end_timestamp</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;max_timestamp&quot;</span><span class="p">]</span>
        <span class="n">training_freq_in_secs</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;inferred_freq_in_secs&quot;</span><span class="p">]</span>
        <span class="n">time_col</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">[</span><span class="s2">&quot;time_col&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fut_df_time_stats</span> <span class="o">=</span> <span class="n">describe_timeseries</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">fut_df</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">fut_df_time_stats</span><span class="p">[</span><span class="s2">&quot;regular_increments&quot;</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;``fut_df`` does not have regular time increments&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">fut_df_time_stats</span><span class="p">[</span><span class="s2">&quot;increasing&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;``fut_df``&#39;s time column </span><span class="si">{</span><span class="n">time_col</span><span class="si">}</span><span class="s2"> must be increasing in time&quot;</span><span class="p">)</span>

            <span class="n">fut_freq_in_secs</span> <span class="o">=</span> <span class="n">fut_df_time_stats</span><span class="p">[</span><span class="s2">&quot;freq_in_secs&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When test_horizon/cv_horizon/forecast_horizon is 1, not all stats above</span>
            <span class="c1"># are available, thus it produces an error.</span>
            <span class="c1"># The &quot;else&quot; handles this case.</span>
            <span class="n">fut_freq_in_secs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">index_before_training</span> <span class="o">=</span> <span class="p">(</span><span class="n">fut_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">training_start_timestamp</span><span class="p">)</span>
        <span class="n">index_within_training</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">fut_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">training_start_timestamp</span><span class="p">)</span> <span class="o">&amp;</span>
                <span class="p">(</span><span class="n">fut_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">training_end_timestamp</span><span class="p">))</span>
        <span class="n">index_after_training</span> <span class="o">=</span> <span class="p">(</span><span class="n">fut_df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">training_end_timestamp</span><span class="p">)</span>

        <span class="n">fut_df_before_training</span> <span class="o">=</span> <span class="n">fut_df</span><span class="p">[</span><span class="n">index_before_training</span><span class="p">]</span>
        <span class="n">fut_df_within_training</span> <span class="o">=</span> <span class="n">fut_df</span><span class="p">[</span><span class="n">index_within_training</span><span class="p">]</span>
        <span class="n">fut_df_after_training</span> <span class="o">=</span> <span class="n">fut_df</span><span class="p">[</span><span class="n">index_after_training</span><span class="p">]</span>

        <span class="n">fut_df_gap</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># a dataframe which fills in the missing time periods</span>
        <span class="n">missing_periods_num</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the number of missing time periods</span>

        <span class="k">if</span> <span class="n">fut_df_after_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_timestamp_after_training</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">fut_df_after_training</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>
            <span class="n">expected_timestamp_after_training</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="n">training_end_timestamp</span><span class="p">,</span>
                <span class="n">periods</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">min_timestamp_after_training</span> <span class="o">&lt;</span> <span class="n">expected_timestamp_after_training</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The most immediate time in the future is off &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;The last training date: </span><span class="si">{</span><span class="n">training_end_timestamp</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;The first future period: </span><span class="si">{</span><span class="n">min_timestamp_after_training</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected first future period is </span><span class="si">{</span><span class="n">expected_timestamp_after_training</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">min_timestamp_after_training</span> <span class="o">&gt;</span> <span class="n">expected_timestamp_after_training</span><span class="p">:</span>
                <span class="n">missing_dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">expected_timestamp_after_training</span><span class="p">,</span>
                    <span class="n">end</span><span class="o">=</span><span class="n">min_timestamp_after_training</span><span class="p">,</span>
                    <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
                <span class="c1"># The last timestamp is already there, therefore we drop it</span>
                <span class="n">missing_dates</span> <span class="o">=</span> <span class="n">missing_dates</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">missing_periods_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_dates</span><span class="p">)</span>
                <span class="c1"># The length of missing dates is non-zero since there are missing timestamps</span>
                <span class="c1"># since ``min_timestamp_after_training &gt; next_period_after_training``</span>
                <span class="k">assert</span> <span class="n">missing_periods_num</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">fut_df_gap</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">time_col</span><span class="p">:</span> <span class="n">missing_dates</span><span class="o">.</span><span class="n">tolist</span><span class="p">()})</span>

        <span class="c1"># `fut_df` might include other columns than `time_col`</span>
        <span class="c1"># Those extra columns might be the regressors passed through `fut_df`</span>
        <span class="c1"># Therefore we need to ensure `fut_df_gap` includes those columns</span>
        <span class="c1"># Also note that those extra columns need to be imputed in that case</span>
        <span class="k">if</span> <span class="n">fut_df_gap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fut_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fut_df_expanded</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">fut_df_within_training</span><span class="p">,</span> <span class="n">fut_df_gap</span><span class="p">,</span> <span class="n">fut_df_after_training</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Imputes the missing values</span>
            <span class="c1"># Excludes time column which doesn&#39;t need imputation,</span>
            <span class="c1"># otherwise it causes error with pandas&gt;=1.4.</span>
            <span class="n">fut_df_expanded</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">fut_df_expanded</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="n">time_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">na_fill_func</span><span class="p">(</span>
                <span class="n">fut_df_expanded</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">fut_df_expanded</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="n">time_col</span><span class="p">])</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">fut_df_within_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                    <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">fut_df_gap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                    <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">fut_df_after_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">fut_df_gap</span> <span class="o">=</span> <span class="n">fut_df_expanded</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">inferred_forecast_horizon</span> <span class="o">=</span> <span class="n">fut_df_after_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fut_df_gap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inferred_forecast_horizon</span> <span class="o">+=</span> <span class="n">fut_df_gap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Creates an expanded dataframe which includes the missing times</span>
        <span class="c1"># between the end of training and the forecast period</span>
        <span class="n">fut_df_after_training_expanded</span> <span class="o">=</span> <span class="n">fut_df_after_training</span>
        <span class="n">index_after_training_original</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">fut_df_after_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fut_df_gap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fut_df_after_training_expanded</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">fut_df_gap</span><span class="p">,</span> <span class="n">fut_df_after_training</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">index_after_training_original</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">fut_df_gap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                    <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">fut_df_after_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">forecast_partition_summary</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;len_before_training&quot;</span><span class="p">:</span> <span class="n">fut_df_before_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;len_within_training&quot;</span><span class="p">:</span> <span class="n">fut_df_within_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;len_after_training&quot;</span><span class="p">:</span> <span class="n">fut_df_after_training</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;len_gap&quot;</span><span class="p">:</span> <span class="n">missing_periods_num</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;fut_freq_in_secs&quot;</span><span class="p">:</span> <span class="n">fut_freq_in_secs</span><span class="p">,</span>
            <span class="s2">&quot;training_freq_in_secs&quot;</span><span class="p">:</span> <span class="n">training_freq_in_secs</span><span class="p">,</span>
            <span class="s2">&quot;index_before_training&quot;</span><span class="p">:</span> <span class="n">index_before_training</span><span class="p">,</span>
            <span class="s2">&quot;index_within_training&quot;</span><span class="p">:</span> <span class="n">index_within_training</span><span class="p">,</span>
            <span class="s2">&quot;index_after_training&quot;</span><span class="p">:</span> <span class="n">index_after_training</span><span class="p">,</span>
            <span class="s2">&quot;fut_df_before_training&quot;</span><span class="p">:</span> <span class="n">fut_df_before_training</span><span class="p">,</span>
            <span class="s2">&quot;fut_df_within_training&quot;</span><span class="p">:</span> <span class="n">fut_df_within_training</span><span class="p">,</span>
            <span class="s2">&quot;fut_df_after_training&quot;</span><span class="p">:</span> <span class="n">fut_df_after_training</span><span class="p">,</span>
            <span class="s2">&quot;fut_df_gap&quot;</span><span class="p">:</span> <span class="n">fut_df_gap</span><span class="p">,</span>
            <span class="s2">&quot;fut_df_after_training_expanded&quot;</span><span class="p">:</span> <span class="n">fut_df_after_training_expanded</span><span class="p">,</span>
            <span class="s2">&quot;index_after_training_original&quot;</span><span class="p">:</span> <span class="n">index_after_training_original</span><span class="p">,</span>
            <span class="s2">&quot;missing_periods_num&quot;</span><span class="p">:</span> <span class="n">missing_periods_num</span><span class="p">,</span>
            <span class="s2">&quot;inferred_forecast_horizon&quot;</span><span class="p">:</span> <span class="n">inferred_forecast_horizon</span><span class="p">,</span>
            <span class="s2">&quot;forecast_partition_summary&quot;</span><span class="p">:</span> <span class="n">forecast_partition_summary</span><span class="p">}</span></div>

    <span class="k">def</span> <span class="nf">__build_silverkite_features</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="p">,</span>
            <span class="n">origin_for_time_vars</span><span class="p">,</span>
            <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">daily_event_neighbor_impact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">daily_event_shifted_effect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">changepoint_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">continuous_time_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">growth_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fs_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">seasonality_changepoint_result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">changepoint_dates</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function adds the prediction model features in training and</span>
<span class="sd">        predict phase for ``self.forecast`` internal use but can be called</span>
<span class="sd">        outside that context if desired.</span>
<span class="sd">        The features are time related features such as seasonality, change points,</span>
<span class="sd">        holidays, ...</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : `pandas.DataFrame`</span>
<span class="sd">            input dataframe, which could be in training phase or predict phase</span>
<span class="sd">        time_col : `str`</span>
<span class="sd">            The column name in df representing time for the time series data</span>
<span class="sd">            The time column values can be anything that can be parsed by pandas DatetimeIndex</span>
<span class="sd">        origin_for_time_vars : `float`</span>
<span class="sd">            The time origin used to create continuous variables for time</span>
<span class="sd">        daily_event_df_dict : `dict` [`str`, `pandas.DataFrame`] or None, default None</span>
<span class="sd">            A dictionary of data frames, each representing events data for the corresponding key.</span>
<span class="sd">            The DataFrame has two columns:</span>

<span class="sd">                - The first column contains event dates. Must be in a format</span>
<span class="sd">                  recognized by `pandas.to_datetime`. Must be at daily</span>
<span class="sd">                  frequency for proper join. It is joined against the time</span>
<span class="sd">                  in ``df``, converted to a day:</span>
<span class="sd">                  ``pd.to_datetime(pd.DatetimeIndex(df[time_col]).date)``.</span>
<span class="sd">                - the second column contains the event label for each date</span>

<span class="sd">            The column order is important; column names are ignored.</span>
<span class="sd">            The event dates must span their occurrences in both the training</span>
<span class="sd">            and future prediction period.</span>

<span class="sd">            During modeling, each key in the dictionary is mapped to a categorical variable</span>
<span class="sd">            named ``f&quot;{EVENT_PREFIX}_{key}&quot;``, whose value at each timestamp is specified</span>
<span class="sd">            by the corresponding DataFrame.</span>

<span class="sd">            For example, to manually specify a yearly event on September 1</span>
<span class="sd">            during a training/forecast period that spans 2020-2022::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;custom_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;, &quot;2022-09-01&quot;],</span>
<span class="sd">                        &quot;label&quot;: [&quot;is_event&quot;, &quot;is_event&quot;, &quot;is_event&quot;]</span>
<span class="sd">                    })</span>
<span class="sd">                }</span>

<span class="sd">            It&#39;s possible to specify multiple events in the same df. Two events,</span>
<span class="sd">            ``&quot;sep&quot;`` and ``&quot;oct&quot;`` are specified below for 2020-2021::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;custom_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2020-10-01&quot;, &quot;2021-09-01&quot;, &quot;2021-10-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: [&quot;sep&quot;, &quot;oct&quot;, &quot;sep&quot;, &quot;oct&quot;]</span>
<span class="sd">                    })</span>
<span class="sd">                }</span>

<span class="sd">            Use multiple keys if two events may fall on the same date. These events</span>
<span class="sd">            must be in separate DataFrames::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;fixed_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;, &quot;2022-09-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;fixed_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                    &quot;moving_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-08-28&quot;, &quot;2022-09-03&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;moving_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                }</span>

<span class="sd">            The multiple event specification can be used even if events never overlap. An</span>
<span class="sd">            equivalent specification to the second example::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;sep&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;is_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                    &quot;oct&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-10-01&quot;, &quot;2021-10-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;is_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                }</span>

<span class="sd">            Note: The events you want to use must be specified in ``extra_pred_cols``.</span>
<span class="sd">            These take the form: ``f&quot;{EVENT_PREFIX}_{key}&quot;``, where</span>
<span class="sd">            `~greykite.common.constants.EVENT_PREFIX` is the constant.</span>

<span class="sd">            Note: Do not use `~greykite.common.constants.EVENT_DEFAULT`</span>
<span class="sd">            in the second column. This is reserved to indicate dates that do not</span>
<span class="sd">            correspond to an event.</span>
<span class="sd">        daily_event_neighbor_impact : `int`, `list` [`int`], callable or None, default None</span>
<span class="sd">            The impact of neighboring timestamps of the events in ``event_df_dict``.</span>
<span class="sd">            This is for daily events so the units below are all in days.</span>

<span class="sd">            For example, if the data is weekly (&quot;W-SUN&quot;) and an event is daily,</span>
<span class="sd">            it may not exactly fall on the weekly date.</span>
<span class="sd">            But you can specify for New Year&#39;s day on 1/1, it affects all dates</span>
<span class="sd">            in the week, e.g. 12/31, 1/1, ..., 1/6, then it will be mapped to the weekly date.</span>
<span class="sd">            In this case you may want to map a daily event&#39;s date to a few dates,</span>
<span class="sd">            and can specify</span>
<span class="sd">            ``neighbor_impact=lambda x: [x-timedelta(days=x.isocalendar()[2]-1) + timedelta(days=i) for i in range(7)]``.</span>

<span class="sd">            Another example is that the data is rolling 7 day daily data,</span>
<span class="sd">            thus a holiday may affect the t, t+1, ..., t+6 dates.</span>
<span class="sd">            You can specify ``neighbor_impact=7``.</span>

<span class="sd">            If input is `int`, the mapping is t, t+1, ..., t+neighbor_impact-1.</span>
<span class="sd">            If input is `list`, the mapping is [t+x for x in neighbor_impact].</span>
<span class="sd">            If input is a function, it maps each daily event&#39;s date to a list of dates.</span>
<span class="sd">        daily_event_shifted_effect : `list` [`str`] or None, default None</span>
<span class="sd">            Additional neighbor events based on given events.</span>
<span class="sd">            For example, passing [&quot;-1D&quot;, &quot;7D&quot;] will add extra daily events which are 1 day before</span>
<span class="sd">            and 7 days after the given events.</span>
<span class="sd">            Offset format is {d}{freq} with any integer plus a frequency string.</span>
<span class="sd">            Must be parsable by pandas ``to_offset``.</span>
<span class="sd">            The new events&#39; names will be the current events&#39; names with suffix &quot;{offset}_before&quot; or &quot;{offset}_after&quot;.</span>
<span class="sd">            For example, if we have an event named &quot;US_Christmas Day&quot;,</span>
<span class="sd">            a &quot;7D&quot; shift will have name &quot;US_Christmas Day_7D_after&quot;.</span>
<span class="sd">            This is useful when you expect an offset of the current holidays also has impact on the</span>
<span class="sd">            time series, or you want to interact the lagged terms with autoregression.</span>
<span class="sd">            If ``daily_event_neighbor_impact`` is also specified, this will be applied after adding neighboring days.</span>
<span class="sd">        changepoint_values : `list` of Union[int, float, double]], optional</span>
<span class="sd">            The values of the growth term at the changepoints</span>
<span class="sd">            Can be generated by the ``get_evenly_spaced_changepoints``,</span>
<span class="sd">                `get_custom_changepoints` functions</span>
<span class="sd">        continuous_time_col : `str`, optional</span>
<span class="sd">            This parameter is used only if ``changepoint_values`` is not None.</span>
<span class="sd">            Column to apply growth_func to, to generate changepoint features</span>
<span class="sd">        growth_func: callable, optional</span>
<span class="sd">            Growth function (scalar -&gt; scalar).</span>
<span class="sd">            This parameter is used only if ``changepoint_values`` is not None.</span>
<span class="sd">            Changepoint features are created by applying</span>
<span class="sd">            ``growth_func`` to ``continuous_time_col`` with offsets.</span>
<span class="sd">            If None, uses identity function to use ``continuous_time_col`` directly</span>
<span class="sd">            as growth term.</span>
<span class="sd">        fs_func: callable, optional</span>
<span class="sd">            A function which takes a df as input and returns an output df</span>
<span class="sd">            with fourier terms. ``fs_func`` is expected to be constructed using</span>
<span class="sd">            ``greykite.common.features.timeseries_features.fourier_series_multi_fcn``, but</span>
<span class="sd">            that is not a hard requirement.</span>
<span class="sd">        seasonality_changepoint_result: `dict`</span>
<span class="sd">            The detected seasonality change points result dictionary, returned by</span>
<span class="sd">            `~greykite.algo.changepoint.adalasso.changepoint_detector.ChangepointDetector.find_seasonality_changepoints`.</span>
<span class="sd">        changepoint_dates : `list`</span>
<span class="sd">            List of change point dates with `strftime` attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        features_df : `pandas.DataFrame`</span>
<span class="sd">            a data frame with the added features as new columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># adds time features</span>
        <span class="n">features_df</span> <span class="o">=</span> <span class="n">add_time_features_df</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
            <span class="n">conti_year_origin</span><span class="o">=</span><span class="n">origin_for_time_vars</span><span class="p">)</span>

        <span class="c1"># adds daily events (e.g. holidays)</span>
        <span class="c1"># if daily event data are given, we add them to temporal features data</span>
        <span class="c1"># ``date_col`` below is used to join with ``daily_events`` data given</span>
        <span class="c1"># in ``daily_event_df_dict``</span>
        <span class="c1"># Note: events must be provided for both train and forecast time range</span>
        <span class="k">if</span> <span class="n">daily_event_df_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="n">min_gap_in_seconds</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">time_col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TimeEnum</span><span class="o">.</span><span class="n">ONE_DAY_IN_SECONDS</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The granularity of data is larger than daily. &quot;</span>
                              <span class="s2">&quot;Ensure the daily events data match the timestamps&quot;</span><span class="p">)</span>
            <span class="n">features_df</span> <span class="o">=</span> <span class="n">add_daily_events</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">features_df</span><span class="p">,</span>
                <span class="n">event_df_dict</span><span class="o">=</span><span class="n">daily_event_df_dict</span><span class="p">,</span>
                <span class="n">date_col</span><span class="o">=</span><span class="s2">&quot;date&quot;</span><span class="p">,</span>
                <span class="n">neighbor_impact</span><span class="o">=</span><span class="n">daily_event_neighbor_impact</span><span class="p">,</span>
                <span class="n">shifted_effect</span><span class="o">=</span><span class="n">daily_event_shifted_effect</span><span class="p">)</span>

        <span class="c1"># adds changepoints</span>
        <span class="k">if</span> <span class="n">changepoint_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">changepoint_features_df</span> <span class="o">=</span> <span class="n">get_changepoint_features</span><span class="p">(</span>
                <span class="n">features_df</span><span class="p">,</span>
                <span class="n">changepoint_values</span><span class="p">,</span>
                <span class="n">continuous_time_col</span><span class="o">=</span><span class="n">continuous_time_col</span><span class="p">,</span>
                <span class="n">growth_func</span><span class="o">=</span><span class="n">growth_func</span><span class="p">,</span>
                <span class="n">changepoint_dates</span><span class="o">=</span><span class="n">changepoint_dates</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">features_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">changepoint_features_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">features_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">features_df</span><span class="p">,</span> <span class="n">changepoint_features_df</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># adds seasonality</span>
        <span class="k">if</span> <span class="n">fs_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fs_features</span> <span class="o">=</span> <span class="n">fs_func</span><span class="p">(</span><span class="n">features_df</span><span class="p">)</span>
            <span class="n">fs_df</span> <span class="o">=</span> <span class="n">fs_features</span><span class="p">[</span><span class="s2">&quot;df&quot;</span><span class="p">]</span>
            <span class="n">features_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">features_df</span><span class="p">,</span> <span class="n">fs_df</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># adds seasonality change points</span>
        <span class="k">if</span> <span class="n">seasonality_changepoint_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seasonality_available</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fs_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]))</span> <span class="k">if</span> <span class="n">fs_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">seasonality_df</span> <span class="o">=</span> <span class="n">build_seasonality_feature_df_from_detection_result</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">seasonality_changepoints</span><span class="o">=</span><span class="n">seasonality_changepoint_result</span><span class="p">[</span><span class="s2">&quot;seasonality_changepoints&quot;</span><span class="p">],</span>
                <span class="n">seasonality_components_df</span><span class="o">=</span><span class="n">seasonality_changepoint_result</span><span class="p">[</span><span class="s2">&quot;seasonality_components_df&quot;</span><span class="p">],</span>
                <span class="n">include_original_block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">include_components</span><span class="o">=</span><span class="n">seasonality_available</span>
            <span class="p">)</span>
            <span class="n">features_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">features_df</span><span class="p">,</span> <span class="n">seasonality_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">features_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>  <span class="c1"># assigns a copy of original index</span>
        <span class="k">return</span> <span class="n">features_df</span>

    <span class="k">def</span> <span class="nf">__build_autoreg_features</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">value_col</span><span class="p">,</span>
            <span class="n">autoreg_func</span><span class="p">,</span>
            <span class="n">phase</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds autoregressive df to be used in forecast models.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : `pandas.Dataframe`</span>
<span class="sd">            Dataframe to predict on, passed to ``autoreg_func``.</span>
<span class="sd">        value_col : `str`, optional</span>
<span class="sd">            This is the column name for the values of the time series.</span>
<span class="sd">            This parameter is only required if autoregressive methods are used.</span>
<span class="sd">            ``value_col`` is needed at the &quot;predict&quot; phase to add to the ``df``</span>
<span class="sd">            with NULL values so it can be appended to ``past_df``.</span>
<span class="sd">        autoreg_func : callable, optional</span>
<span class="sd">            A function constructed by</span>
<span class="sd">            `~greykite.common.features.timeseries_lags.build_autoreg_df`</span>
<span class="sd">            with the following signature::</span>

<span class="sd">                def autoreg_func(df: pd.DataFrame, past_df: pd.DataFrame) -&gt;</span>
<span class="sd">                    dict(lag_df: pd.DataFrame, agg_lag_df: pd.DataFrame)</span>

<span class="sd">            See more details for above parameters in</span>
<span class="sd">            `~greykite.common.features.timeseries_lags.build_autoreg_df`.</span>
<span class="sd">        phase : `str`, optional, default &quot;fit&quot;</span>
<span class="sd">            It denotes the phase the features are being built. It can be either of</span>

<span class="sd">                - &quot;fit&quot;: indicates the features are being built for the fitting phase</span>

<span class="sd">                - &quot;predict&quot;: indicates the features are being built for predict phase</span>
<span class="sd">            This argument is used minimally inside the function.</span>
<span class="sd">            Currently only to throw an exception when ``phase = &quot;predict&quot;`` and</span>
<span class="sd">            ``autoreg_func`` is not None but ``past_df`` is None.</span>
<span class="sd">        past_df : `pandas.DataFrame`, optional</span>
<span class="sd">            If autoregressive methods are used by providing ``autoreg_func``,</span>
<span class="sd">            this parameter is used to append to ``df`` (from left)</span>
<span class="sd">            before calculating the lags</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        autoreg_df : `pandas.DataFrame`</span>
<span class="sd">            a data frame with autoregression columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># we raise an exception if we are in the &#39;predict&#39; phase</span>
        <span class="c1"># and `autoreg_func` is not None</span>
        <span class="c1"># but either of ``past_df`` or ``value_col`` is not provided</span>
        <span class="c1"># This is because in that case `autoreg_func` will not be able to provide useful</span>
        <span class="c1"># lag-based predictors</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="o">==</span> <span class="s2">&quot;predict&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value_col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;At &#39;predict&#39; phase, if autoreg_func is not None,&quot;</span>
                    <span class="s2">&quot; &#39;past_df&#39; and &#39;value_col&#39; must be provided to &quot;</span>
                    <span class="s2">&quot;`build_autoreg_features`&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># in the predict phase, we add the `value_col` to the df</span>
                <span class="c1"># to enable `past_df` to be appended</span>
                <span class="n">df</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">past_df</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="p">(</span>
                <span class="s2">&quot;`autoreg_func(df, past_df)` expects &quot;</span>
                <span class="s2">&quot;`df` and `past_df` to have the same columns. &quot;</span>
                <span class="s2">&quot;This is not the case: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`df` columns: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`past_df` columns: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">past_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">autoreg_data</span> <span class="o">=</span> <span class="n">autoreg_func</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">)</span>
        <span class="n">autoreg_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">autoreg_data</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Preserves the original index of `df`</span>
        <span class="n">autoreg_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
        <span class="k">return</span> <span class="n">autoreg_df</span>

    <span class="k">def</span> <span class="nf">__build_lagged_regressor_features</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">lagged_regressor_cols</span><span class="p">,</span>
            <span class="n">lagged_regressor_func</span><span class="p">,</span>
            <span class="n">phase</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span>
            <span class="n">past_df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds lagged regressor df to be used in forecast models.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : `pandas.Dataframe`</span>
<span class="sd">            Dataframe to predict on, passed to ``lagged_regressor_func``.</span>
<span class="sd">        lagged_regressor_cols : `list` [`str`], optional</span>
<span class="sd">            This is the original column names for the lagged regressors.</span>
<span class="sd">            This parameter is only required if lagged regressor methods are used.</span>
<span class="sd">            ``lagged_regressor_cols`` is needed at the &quot;predict&quot; phase to add to the ``df``</span>
<span class="sd">            with NULL values so it can be appended to ``past_df``.</span>
<span class="sd">        lagged_regressor_func : callable, optional</span>
<span class="sd">            A function constructed by</span>
<span class="sd">            `~greykite.common.features.timeseries_lags.build_autoreg_df_multi`</span>
<span class="sd">            with the following signature::</span>

<span class="sd">                def build_autoreg_df_multi(df: pd.DataFrame, past_df: pd.DataFrame) -&gt; autoreg_df: pd.DataFrame</span>

<span class="sd">            See more details for above parameters in</span>
<span class="sd">            `~greykite.common.features.timeseries_lags.build_autoreg_df_multi`.</span>
<span class="sd">        phase : `str`, optional, default &quot;fit&quot;</span>
<span class="sd">            It denotes the phase the features are being built. It can be either of</span>

<span class="sd">                - &quot;fit&quot;: indicates the features are being built for the fitting phase</span>

<span class="sd">                - &quot;predict&quot;: indicates the features are being built for predict phase</span>

<span class="sd">            This argument is used minimally inside the function.</span>
<span class="sd">            Currently only to throw an exception when ``phase = &quot;predict&quot;`` and</span>
<span class="sd">            ``lagged_regressor_func`` is not None but ``past_df`` is None.</span>
<span class="sd">        past_df : `pandas.DataFrame`, optional</span>
<span class="sd">            If lagged regressor methods are used by providing ``lagged_regressor_func``,</span>
<span class="sd">            this parameter is used to append to ``df`` (from left)</span>
<span class="sd">            before calculating the lags</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lagged_regressor_df : `pandas.DataFrame`</span>
<span class="sd">            a data frame with lagged regressor columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># we raise an exception if we are in the &#39;predict&#39; phase</span>
        <span class="c1"># and `lagged_regressor_func` is not None</span>
        <span class="c1"># but either of ``past_df`` or ``lagged_regressor_cols`` is not provided</span>
        <span class="c1"># This is because in that case `lagged_regressor_func` will not be able to provide useful</span>
        <span class="c1"># lag-based predictors</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="o">==</span> <span class="s2">&quot;predict&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lagged_regressor_cols</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;At &#39;predict&#39; phase, if lagged_regressor_func is not None,&quot;</span>
                    <span class="s2">&quot; &#39;past_df&#39; and &#39;lagged_regressor_cols&#39; must be provided to &quot;</span>
                    <span class="s2">&quot;`build_lagged_regressor_features`&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_col_missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lagged_regressor_cols</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_col_missing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;All columns in `lagged_regressor_cols` must appear in `df`, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but </span><span class="si">{</span><span class="n">df_col_missing</span><span class="si">}</span><span class="s2"> is missing in `df`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">past_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">past_df_col_missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lagged_regressor_cols</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">past_df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">past_df_col_missing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;All columns in `lagged_regressor_cols` must appear in `past_df`, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but </span><span class="si">{</span><span class="n">past_df_col_missing</span><span class="si">}</span><span class="s2"> is missing in `past_df`.&quot;</span><span class="p">)</span>

        <span class="n">lagged_regressor_df</span> <span class="o">=</span> <span class="n">lagged_regressor_func</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">past_df</span><span class="o">=</span><span class="n">past_df</span><span class="p">)</span>
        <span class="c1"># Preserves the original index of `df`</span>
        <span class="n">lagged_regressor_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
        <span class="k">return</span> <span class="n">lagged_regressor_df</span>

    <span class="k">def</span> <span class="nf">__get_default_autoreg_dict</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">freq_in_days</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="p">,</span>
            <span class="n">simulation_based</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates the autoregressive components for forecasting</span>
<span class="sd">        given the forecast horizon and time frequency.</span>

<span class="sd">        Only if ``forecast_horizon`` is less than or equal to 30 days</span>
<span class="sd">        auto-regression is used.</span>
<span class="sd">        If ``forecast_horizon`` is larger than 30, the function returns None.</span>

<span class="sd">        First, we calculate an integer called ``proper_order`` defined below:</span>
<span class="sd">        This will be the smallest integer which is</span>
<span class="sd">            (i) larger than ``forecast_horizon``</span>
<span class="sd">            (ii) multiple of number of observations per week</span>
<span class="sd">        For example, for daily data if ``forecast_horizon`` is 2,</span>
<span class="sd">        we let the ``proper_order`` to be 7.</span>
<span class="sd">        As another example, if ``forecast_horizon`` is 9, we let the ``proper_order``</span>
<span class="sd">        to be 14.</span>
<span class="sd">        This order is useful because often the same day of week is best</span>
<span class="sd">        correlated with the observed value.</span>
<span class="sd">        As an example, for daily data, one aggregated lag predictors</span>
<span class="sd">        can be constructed by averaging these lags:</span>
<span class="sd">            `[proper_order, proper_order+7, proper_order+7*2]`</span>
<span class="sd">        which is equal to `[7, 14, 21]` when `forecast_horizon = 1`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq_in_days : `float`</span>
<span class="sd">            The frequency of the timeseries in days. e.g. 7.0 for weekly data,</span>
<span class="sd">            1.0 for daily data, 0.04166... for hourly data.</span>
<span class="sd">        forecast_horizon : `int`</span>
<span class="sd">            The number of time intervals into the future which are to be forecasted.</span>
<span class="sd">        simulation_based : `bool`, default False</span>
<span class="sd">            A boolean to decide if the forecast is performed via simulations or</span>
<span class="sd">            without simulations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        autoreg_dict : `dict` or `None`</span>
<span class="sd">            A dictionary which can be passed to</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`</span>
<span class="sd">            to specify the autoregressive structure.</span>
<span class="sd">            See that function&#39;s definition for details.</span>
<span class="sd">        proper_order : `int` or None</span>
<span class="sd">            This will be the smallest integer which is</span>
<span class="sd">                (i) larger than ``forecast_horizon``</span>
<span class="sd">                (ii) multiple of 7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">forecast_horizon_in_days</span> <span class="o">=</span> <span class="n">freq_in_days</span> <span class="o">*</span> <span class="n">forecast_horizon</span>

        <span class="n">similar_lag</span> <span class="o">=</span> <span class="n">get_similar_lag</span><span class="p">(</span><span class="n">freq_in_days</span><span class="p">)</span>
        <span class="n">proper_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">similar_lag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">proper_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">forecast_horizon</span> <span class="o">/</span> <span class="n">similar_lag</span><span class="p">)</span> <span class="o">*</span> <span class="n">similar_lag</span><span class="p">)</span>

        <span class="n">autoreg_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orders</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orders_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interval_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Following considers two cases:</span>
        <span class="c1"># (i) simulation-based</span>
        <span class="c1"># (ii) non-simulation-based</span>
        <span class="c1"># In simulation-based we are able to use small orders</span>
        <span class="c1"># even for longer horizon ie we allow a orders for which</span>
        <span class="c1"># ``order &lt; forecast_horizon``.</span>
        <span class="c1"># The above is not possible for non-simulation based approach.</span>
        <span class="k">if</span> <span class="n">simulation_based</span><span class="p">:</span>
            <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># 1st, 2nd, 3rd time lags</span>
            <span class="k">if</span> <span class="n">similar_lag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">interval_list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">similar_lag</span><span class="p">),</span> <span class="p">(</span>
                    <span class="n">similar_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">similar_lag</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>  <span class="c1"># weekly average of last week, and weekly average of two weeks ago</span>
                <span class="n">orders_list</span> <span class="o">=</span> <span class="p">[[</span>
                    <span class="n">similar_lag</span><span class="p">,</span>  <span class="c1"># (i) same week day in a week which is 7 days prior</span>
                    <span class="n">similar_lag</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1"># (ii) same week day a week before (i)</span>
                    <span class="n">similar_lag</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]]</span>  <span class="c1"># (iii) same week day in a week before (ii)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># non-simulation-based case</span>
            <span class="k">if</span> <span class="n">forecast_horizon_in_days</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">:</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">forecast_horizon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">forecast_horizon</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">similar_lag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">interval_list</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">(</span><span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">forecast_horizon</span> <span class="o">+</span> <span class="n">similar_lag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">forecast_horizon</span> <span class="o">+</span> <span class="n">similar_lag</span><span class="p">,</span> <span class="n">forecast_horizon</span> <span class="o">+</span> <span class="n">similar_lag</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

                    <span class="c1"># The following will induce an average between three lags on the same time of week</span>
                    <span class="n">orders_list</span> <span class="o">=</span> <span class="p">[[</span>
                        <span class="n">proper_order</span><span class="p">,</span>  <span class="c1"># (i) same time in week, in a week which is ``proper_order`` times prior</span>
                        <span class="n">proper_order</span> <span class="o">+</span> <span class="n">similar_lag</span><span class="p">,</span>  <span class="c1"># (ii) same time in a week before (i)</span>
                        <span class="n">proper_order</span> <span class="o">+</span> <span class="n">similar_lag</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]]</span>  <span class="c1"># (iii) same time in a week before (ii)</span>

        <span class="k">if</span> <span class="n">forecast_horizon_in_days</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">:</span>
            <span class="n">autoreg_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">autoreg_dict</span><span class="p">[</span><span class="s2">&quot;lag_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">autoreg_dict</span><span class="p">[</span><span class="s2">&quot;agg_lag_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">orders</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">autoreg_dict</span><span class="p">[</span><span class="s2">&quot;lag_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;orders&quot;</span><span class="p">:</span> <span class="n">orders</span><span class="p">}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orders_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">autoreg_dict</span><span class="p">[</span><span class="s2">&quot;agg_lag_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;orders_list&quot;</span><span class="p">:</span> <span class="n">orders_list</span><span class="p">,</span>
                    <span class="s2">&quot;interval_list&quot;</span><span class="p">:</span> <span class="n">interval_list</span><span class="p">}</span>
            <span class="n">autoreg_dict</span><span class="p">[</span><span class="s2">&quot;series_na_fill_func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">())</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;proper_order&quot;</span><span class="p">:</span> <span class="n">proper_order</span><span class="p">,</span>
            <span class="s2">&quot;autoreg_dict&quot;</span><span class="p">:</span> <span class="n">autoreg_dict</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__get_default_lagged_regressor_dict</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">freq_in_days</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates the lagged regressor components for forecasting</span>
<span class="sd">        given the forecast horizon and time frequency.</span>
<span class="sd">        This applies to ONE lagged regressor column at a time.</span>

<span class="sd">        Only if ``forecast_horizon`` is less than or equal to 30 days</span>
<span class="sd">        lagged regressors are used.</span>
<span class="sd">        If ``forecast_horizon`` is larger than 30, the function returns None.</span>

<span class="sd">        First, we calculate an integer called ``proper_order`` defined below:</span>
<span class="sd">        This will be the smallest integer which is</span>
<span class="sd">            (i) larger than ``forecast_horizon``</span>
<span class="sd">            (ii) multiple of number of observations per week</span>
<span class="sd">        For example, for daily data if ``forecast_horizon`` is 2,</span>
<span class="sd">        we let the ``proper_order`` to be 7.</span>
<span class="sd">        As another example, if ``forecast_horizon`` is 9, we let the ``proper_order``</span>
<span class="sd">        to be 14.</span>
<span class="sd">        This order is useful because often the same day of week is best</span>
<span class="sd">        correlated with the observed response.</span>
<span class="sd">        As an example, for daily data, one aggregated lagged regressor</span>
<span class="sd">        can be constructed by averaging these lags:</span>
<span class="sd">            `[proper_order, proper_order+7, proper_order+7*2]`</span>
<span class="sd">        which is equal to `[7, 14, 21]` when `forecast_horizon = 1`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq_in_days : `float`</span>
<span class="sd">            The frequency of the timeseries in days. e.g. 7.0 for weekly data,</span>
<span class="sd">            1.0 for daily data, 0.04166... for hourly data.</span>
<span class="sd">        forecast_horizon : `int`</span>
<span class="sd">            The number of time intervals into the future which are to be forecasted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lag_reg_dict : `dict` or `None`</span>
<span class="sd">            A dictionary which specifies the lagged regressor structure in ``lagged_regressor_dict``,</span>
<span class="sd">            which then can be passed to</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`.</span>
<span class="sd">            See that function&#39;s definition for details.</span>
<span class="sd">        proper_order : `int` or None</span>
<span class="sd">            This will be the smallest integer which is</span>
<span class="sd">                (i) larger than ``forecast_horizon``</span>
<span class="sd">                (ii) multiple of 7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">forecast_horizon_in_days</span> <span class="o">=</span> <span class="n">freq_in_days</span> <span class="o">*</span> <span class="n">forecast_horizon</span>

        <span class="n">similar_lag</span> <span class="o">=</span> <span class="n">get_similar_lag</span><span class="p">(</span><span class="n">freq_in_days</span><span class="p">)</span>
        <span class="n">proper_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">similar_lag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">proper_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">forecast_horizon</span> <span class="o">/</span> <span class="n">similar_lag</span><span class="p">)</span> <span class="o">*</span> <span class="n">similar_lag</span><span class="p">)</span>

        <span class="n">lag_reg_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orders</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orders_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interval_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Since simulation is not allowed for lagged regressors,</span>
        <span class="c1"># the minimal lag order has to be greater than or equal to the forecast horizon.</span>
        <span class="k">if</span> <span class="n">forecast_horizon_in_days</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">forecast_horizon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">proper_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="n">proper_order</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="n">forecast_horizon</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">similar_lag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">interval_list</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">forecast_horizon</span> <span class="o">+</span> <span class="n">similar_lag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

                <span class="c1"># The following will induce an average between three lags on the same time of week</span>
                <span class="n">orders_list</span> <span class="o">=</span> <span class="p">[[</span>
                    <span class="n">proper_order</span><span class="p">,</span>  <span class="c1"># (i) same time in week, in a week which is ``proper_order`` times prior</span>
                    <span class="n">proper_order</span> <span class="o">+</span> <span class="n">similar_lag</span><span class="p">,</span>  <span class="c1"># (ii) same time in a week before (i)</span>
                    <span class="n">proper_order</span> <span class="o">+</span> <span class="n">similar_lag</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]]</span>  <span class="c1"># (iii) same time in a week before (ii)</span>

        <span class="k">if</span> <span class="n">forecast_horizon_in_days</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">:</span>
            <span class="n">lag_reg_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">lag_reg_dict</span><span class="p">[</span><span class="s2">&quot;lag_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">lag_reg_dict</span><span class="p">[</span><span class="s2">&quot;agg_lag_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">orders</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lag_reg_dict</span><span class="p">[</span><span class="s2">&quot;lag_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;orders&quot;</span><span class="p">:</span> <span class="n">orders</span><span class="p">}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orders_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lag_reg_dict</span><span class="p">[</span><span class="s2">&quot;agg_lag_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;orders_list&quot;</span><span class="p">:</span> <span class="n">orders_list</span><span class="p">,</span>
                    <span class="s2">&quot;interval_list&quot;</span><span class="p">:</span> <span class="n">interval_list</span><span class="p">}</span>
            <span class="n">lag_reg_dict</span><span class="p">[</span><span class="s2">&quot;series_na_fill_func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">())</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;proper_order&quot;</span><span class="p">:</span> <span class="n">proper_order</span><span class="p">,</span>
            <span class="s2">&quot;lag_reg_dict&quot;</span><span class="p">:</span> <span class="n">lag_reg_dict</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__normalize_changepoint_values</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">changepoint_values</span><span class="p">,</span>
            <span class="n">pred_cols</span><span class="p">,</span>
            <span class="n">continuous_time_col</span><span class="p">,</span>
            <span class="n">normalize_df_func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalizes the ``changepoint_values`` in</span>
<span class="sd">        `~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`</span>
<span class="sd">        with the same normalize method specified in the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        changepoint_values : `numpy.array` or `None`</span>
<span class="sd">            The trend change point values as returned by</span>
<span class="sd">            `~greykite.common.features.timeseries_features.get_changepoint_features_and_values_from_config`</span>
<span class="sd">        pred_cols : `list`</span>
<span class="sd">            List of names of predictors.</span>
<span class="sd">        continuous_time_col : `str`</span>
<span class="sd">            The name of continuous time column in ``pred_cols``.</span>
<span class="sd">        normalize_df_func : `function` or `None`</span>
<span class="sd">            The normalization function as returned by</span>
<span class="sd">            `~greykite.common.features.normalize.normalize_df`</span>
<span class="sd">            It should be compatible with ``pred_cols`` (generated on the same design matrix).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        normalized_changepoint_values : `numpy.array`</span>
<span class="sd">            The normalized change points, on the same scale as the normalized continuous time column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">changepoint_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">normalize_df_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">changepoint_values</span>
        <span class="k">if</span> <span class="n">continuous_time_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">continuous_time_col</span> <span class="o">=</span> <span class="n">TimeFeaturesEnum</span><span class="o">.</span><span class="n">ct1</span><span class="o">.</span><span class="n">value</span>
        <span class="n">new_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">changepoint_values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pred_cols</span><span class="p">)]))</span>
        <span class="n">new_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">pred_cols</span>
        <span class="n">new_df</span><span class="p">[</span><span class="n">continuous_time_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">changepoint_values</span>
        <span class="n">normalized_df</span> <span class="o">=</span> <span class="n">normalize_df_func</span><span class="p">(</span><span class="n">new_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">normalized_df</span><span class="p">[</span><span class="n">continuous_time_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__remove_fourier_col_with_collinearity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fs_cols</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes fourier series terms with perfect or almost perfect collinearity.</span>
<span class="sd">        This function is intended to be used when fitting algorithm is OLS.</span>

<span class="sd">        These terms include, for example, yearly seasonality with order 4 and quarterly</span>
<span class="sd">        seasonality with order 1; yearly seasonality with order 12, quarterly seasonality</span>
<span class="sd">        with order 3 and monthly seasonality with order 1; etc.</span>
<span class="sd">        Including these terms together is possible to lead to NaN coefficients in OLS models.</span>

<span class="sd">        Note: the function assumes the user includes ``seas_names`` in ``fs_components_df``</span>
<span class="sd">        and labels them: weekly, monthly, quarterly and yearly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fs_cols : `list` [`str`]</span>
<span class="sd">            A list of Fourier series column names generated by</span>
<span class="sd">            `~greykite.common.features.timeseries_features.fourier_series_multi_fcn`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fs_cols : `list` [`str`]</span>
<span class="sd">            The ``fs_cols`` with collinear cols removed.</span>
<span class="sd">            The removed columns always have shorter periods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yearly_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fs_cols</span> <span class="k">if</span> <span class="s2">&quot;yearly&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
        <span class="n">quarterly_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fs_cols</span> <span class="k">if</span> <span class="s2">&quot;quarterly&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
        <span class="n">monthly_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fs_cols</span> <span class="k">if</span> <span class="s2">&quot;monthly&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
        <span class="n">weekly_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fs_cols</span> <span class="k">if</span> <span class="s2">&quot;weekly&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>

        <span class="c1"># Assuming the provided seasonality orders are in reasonable ranges.</span>
        <span class="c1"># We need to deal with year/quarter, year/month, quarter/month for cos/sin</span>
        <span class="c1"># We need to deal with weekly for cos.</span>
        <span class="c1"># The Fourier series column names are generated by ``get_fourier_col_name``,</span>
        <span class="c1"># and the maximum order of a component can be parsed from the names.</span>
        <span class="c1"># For example, yearly seasonality has the form &quot;sin12_ct1_yearly&quot; or &quot;cos12_ct1_yearly&quot;.</span>
        <span class="c1"># Parsing the number after sin/cos and before the first &quot;_&quot; gives the order.</span>
        <span class="n">max_yearly_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">:])</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">yearly_cols</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">max_quarterly_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">:])</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">quarterly_cols</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Adds columns to be removed for year/quarter, year/month, quarter/month</span>
        <span class="c1"># These always include components with shorter periods.</span>
        <span class="c1"># For example, if we have both yearly seasonality with order 4 and quarterly seasonality with order 1,</span>
        <span class="c1"># quarterly seasonality with order 1 will be removed.</span>
        <span class="n">removed_cols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Removes redundant quarterly seasonality with yearly seasonality.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_yearly_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">removed_cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">quarterly_cols</span> <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;sin</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">4</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">col</span> <span class="ow">or</span> <span class="sa">f</span><span class="s2">&quot;cos</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">4</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
        <span class="c1"># Removes redundant monthly seasonality with yearly seasonality.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">max_yearly_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
            <span class="n">removed_cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">monthly_cols</span> <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;sin</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">12</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">col</span> <span class="ow">or</span> <span class="sa">f</span><span class="s2">&quot;cos</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">12</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
        <span class="c1"># Removes redundant monthly seasonality with quarterly seasonality.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_quarterly_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">removed_cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">monthly_cols</span> <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;sin</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">3</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">col</span> <span class="ow">or</span> <span class="sa">f</span><span class="s2">&quot;cos</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">3</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>

        <span class="c1"># Adds columns for weekly seasonality.</span>
        <span class="c1"># Removes higher order cosine terms because order k and order period - k have the same cosine columns.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="o">.</span><span class="n">WEEKLY_SEASONALITY</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">period</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="o">.</span><span class="n">WEEKLY_SEASONALITY</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">period</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">removed_cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">weekly_cols</span> <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;cos</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>

        <span class="c1"># Removes both sine and cosine terms if the order is greater than the period.</span>
        <span class="c1"># The reason is that for weekly order 1 is the same as order 8.</span>
        <span class="c1"># This concern only applies to weekly seasonality, because the period 7 is small.</span>
        <span class="n">removed_cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">weekly_cols</span>
                         <span class="k">if</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">:])</span>
                             <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="o">.</span><span class="n">WEEKLY_SEASONALITY</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">period</span><span class="p">)]</span>

        <span class="n">final_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fs_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_cols</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed_cols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following Fourier series terms are removed due to collinearity:</span><span class="se">\n</span><span class="si">{</span><span class="n">removed_cols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final_cols</span>

    <span class="k">def</span> <span class="nf">__remove_fourier_col_with_collinearity_and_interaction</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">extra_pred_cols</span><span class="p">,</span>
            <span class="n">fs_cols</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes interaction terms that include fourier series terms removed in</span>
<span class="sd">        `~greykite.algo.forecast.silverkite.SilverkiteForecast.__remove_fourier_col_with_collinearity`.</span>
<span class="sd">        This function is intended to be used when fitting algorithm is OLS.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extra_pred_cols : `list` [`str`]</span>
<span class="sd">            A list of features that include extra interaction terms in</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`.</span>
<span class="sd">        fs_cols : `list` [`str`]</span>
<span class="sd">            A list of Fourier series column names to keep from</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.SilverkiteForecast.__remove_fourier_col_with_collinearity`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        extra_pred_cols : `list` [`str`]</span>
<span class="sd">            The ``extra_pred_cols`` with interaction terms including fourier series not in ``fs_col`` removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seas_cols</span> <span class="o">=</span> <span class="n">get_pattern_cols</span><span class="p">(</span><span class="n">extra_pred_cols</span><span class="p">,</span> <span class="n">SEASONALITY_REGEX</span><span class="p">)</span>
        <span class="n">seas_cols</span> <span class="o">=</span> <span class="n">get_pattern_cols</span><span class="p">(</span><span class="n">seas_cols</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="n">removed_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">seas_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fs_cols</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">SEASONALITY_REGEX</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">term</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)]):</span>
                <span class="n">removed_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="n">extra_pred_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">extra_pred_cols</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_cols</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed_cols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following interaction terms are removed:</span><span class="se">\n</span><span class="si">{</span><span class="n">removed_cols</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;due to the removal of the corresponding Fourier series terms.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">extra_pred_cols</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, LinkedIn.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>