

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>greykite.algo.forecast.silverkite.forecast_simple_silverkite &mdash; Greykite Library  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/gallery-dataframe.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 

  
  <script src="../../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../../index.html" class="icon icon-home"> Greykite Library
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Greykite Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/greykite/overview.html">Overview</a></li>
</ul>
<p class="caption"><span class="caption-text">Quick Start</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gallery/quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gallery/tutorials/index.html">Tutorials</a></li>
</ul>
<p class="caption"><span class="caption-text">Step by Step</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0000_stepbystep.html">Forecasting Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0100_choose_model.html">Choose a Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0200_choose_template.html">Choose a Model Template</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0300_input.html">Examine Input Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0400_configuration.html">Configure a Forecast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0500_output.html">Check Forecast Result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/stepbystep/0600_debug.html">Debugging</a></li>
</ul>
<p class="caption"><span class="caption-text">Tuning the Model Components</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0100_introduction.html">Greykite models and components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0200_growth.html">Growth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0300_seasonality.html">Seasonality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0400_events.html">Holidays and Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0500_changepoints.html">Changepoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0600_custom.html">Custom Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0700_regressors.html">Regressors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0800_autoregression.html">Auto-regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/0900_uncertainty.html">Uncertainty Intervals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/model_components/1000_override.html">Pre-processing, Selective Grid Search</a></li>
</ul>
<p class="caption"><span class="caption-text">Benchmarking</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/benchmarking/benchmarking.html">Benchmarking</a></li>
</ul>
<p class="caption"><span class="caption-text">Changelog</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/changelog/changelog.html">Changelog</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pages/autodoc/doc.html">Docs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Greykite Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
      <li>greykite.algo.forecast.silverkite.forecast_simple_silverkite</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for greykite.algo.forecast.silverkite.forecast_simple_silverkite</h1><div class="highlight"><pre>
<span></span><span class="c1"># BSD 2-CLAUSE LICENSE</span>

<span class="c1"># Redistribution and use in source and binary forms, with or without modification,</span>
<span class="c1"># are permitted provided that the following conditions are met:</span>

<span class="c1"># Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1"># list of conditions and the following disclaimer.</span>
<span class="c1"># Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1"># this list of conditions and the following disclaimer in the documentation</span>
<span class="c1"># and/or other materials provided with the distribution.</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="c1"># ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="c1"># DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR</span>
<span class="c1"># #ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="c1"># (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="c1"># LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="c1"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># original author: Albert Chen</span>


<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Type</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">greykite.algo.changepoint.adalasso.changepoint_detector</span> <span class="kn">import</span> <span class="n">get_changepoints_dict</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.constants.silverkite_column</span> <span class="kn">import</span> <span class="n">SilverkiteColumn</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.constants.silverkite_constant</span> <span class="kn">import</span> <span class="n">SilverkiteConstant</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.constants.silverkite_constant</span> <span class="kn">import</span> <span class="n">default_silverkite_constant</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.constants.silverkite_holiday</span> <span class="kn">import</span> <span class="n">SilverkiteHoliday</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.constants.silverkite_time_frequency</span> <span class="kn">import</span> <span class="n">SilverkiteTimeFrequencyEnum</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.forecast_silverkite</span> <span class="kn">import</span> <span class="n">SilverkiteForecast</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.forecast_simple_silverkite_helper</span> <span class="kn">import</span> <span class="n">cols_interact</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.forecast_simple_silverkite_helper</span> <span class="kn">import</span> <span class="n">generate_holiday_events</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.forecast_simple_silverkite_helper</span> <span class="kn">import</span> <span class="n">get_event_pred_cols</span>
<span class="kn">from</span> <span class="nn">greykite.algo.forecast.silverkite.forecast_simple_silverkite_helper</span> <span class="kn">import</span> <span class="n">patsy_categorical_term</span>
<span class="kn">from</span> <span class="nn">greykite.common</span> <span class="kn">import</span> <span class="n">constants</span> <span class="k">as</span> <span class="n">cst</span>
<span class="kn">from</span> <span class="nn">greykite.common.constants</span> <span class="kn">import</span> <span class="n">GROWTH_COL_ALIAS</span>
<span class="kn">from</span> <span class="nn">greykite.common.enums</span> <span class="kn">import</span> <span class="n">SimpleTimeFrequencyEnum</span>
<span class="kn">from</span> <span class="nn">greykite.common.enums</span> <span class="kn">import</span> <span class="n">TimeEnum</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">get_available_holidays_across_countries</span>
<span class="kn">from</span> <span class="nn">greykite.common.features.timeseries_features</span> <span class="kn">import</span> <span class="n">get_changepoint_features_and_values_from_config</span>
<span class="kn">from</span> <span class="nn">greykite.common.logging</span> <span class="kn">import</span> <span class="n">LoggingLevelEnum</span>
<span class="kn">from</span> <span class="nn">greykite.common.logging</span> <span class="kn">import</span> <span class="n">log_message</span>
<span class="kn">from</span> <span class="nn">greykite.common.python_utils</span> <span class="kn">import</span> <span class="n">unique_elements_in_list</span>
<span class="kn">from</span> <span class="nn">greykite.common.python_utils</span> <span class="kn">import</span> <span class="n">update_dictionary</span>
<span class="kn">from</span> <span class="nn">greykite.common.time_properties_forecast</span> <span class="kn">import</span> <span class="n">get_forecast_time_properties</span>


<div class="viewcode-block" id="SimpleSilverkiteForecast"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SimpleSilverkiteForecast">[docs]</a><span class="k">class</span> <span class="nc">SimpleSilverkiteForecast</span><span class="p">(</span><span class="n">SilverkiteForecast</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A derived class of `~greykite.algo.forecast.silverkite.SilverkiteForecast`.</span>
<span class="sd">    Provides an alternative interface with simplified configuration parameters.</span>
<span class="sd">    Produces the same trained model output and uses the same predict functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">constants</span><span class="p">:</span> <span class="n">SilverkiteConstant</span> <span class="o">=</span> <span class="n">default_silverkite_constant</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">constants</span><span class="o">=</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_time_frequency_enum</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">SilverkiteTimeFrequencyEnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">get_silverkite_time_frequency_enum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_holiday</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">SilverkiteHoliday</span><span class="p">]</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">get_silverkite_holiday</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">SilverkiteColumn</span><span class="p">]</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">get_silverkite_column</span><span class="p">()</span>

<div class="viewcode-block" id="SimpleSilverkiteForecast.convert_params"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SimpleSilverkiteForecast.convert_params">[docs]</a>    <span class="k">def</span> <span class="nf">convert_params</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">time_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">value_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">time_properties</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">origin_for_time_vars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">train_test_thresh</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">training_fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
            <span class="n">fit_algorithm</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ridge&quot;</span><span class="p">,</span>
            <span class="n">fit_algorithm_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">holidays_to_model_separately</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">holiday_lookup_countries</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">holiday_pre_num_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">holiday_post_num_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">holiday_pre_post_num_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">daily_event_df_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">changepoints_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">yearly_seasonality</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">quarterly_seasonality</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">monthly_seasonality</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">weekly_seasonality</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">daily_seasonality</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">max_daily_seas_interaction_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">max_weekly_seas_interaction_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">autoreg_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">seasonality_changepoints_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">min_admissible_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">max_admissible_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">uncertainty_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">growth_term</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="n">regressor_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">feature_sets_enabled</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]]]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">extra_pred_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">regression_weight_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">simulation_based</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts parameters of</span>
<span class="sd">        :func:`~greykite.algo.forecast.silverkite.forecast_simple_silverkite` into those</span>
<span class="sd">        of :func:`~greykite.algo.forecast.forecast_silverkite.SilverkiteForecast::forecast`.</span>

<span class="sd">        Makes it easier to set parameters to ``SilverkiteForecast::forecast`` suitable for most forecasting problems.</span>
<span class="sd">        Provides data-aware defaults for seasonality and interaction terms. Provides a simple</span>
<span class="sd">        configuration of holidays from an internal holiday database, and user-friendly configuration</span>
<span class="sd">        for growth and regressors.</span>

<span class="sd">        These parameters can be set from a plain-text config (e.g. no pandas dataframes).</span>
<span class="sd">        The parameter list is intentionally flat to facilitate hyperparameter grid search. Every</span>
<span class="sd">        parameter is either a parameter of ``SilverkiteForecast::forecast`` or a tuning parameter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The basic parameters are identical to ``SilverkiteForecast::forecast``.</span>
<span class="sd">        The more complex parameters are specified via config parameters:</span>

<span class="sd">        * ``daily_event_df_dict`` (via ``holiday*``)</span>
<span class="sd">        * ``fs_components_df`` (via `*_seasonality``)</span>
<span class="sd">        * ``extra_pred_cols`` (via ``holiday*``, ``*seas*``, ``growth_term``,</span>
<span class="sd">          ``regressor_cols``, ``feature_sets_enabled``, ``extra_pred_cols``)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : `pandas.DataFrame`</span>
<span class="sd">            A data frame which includes the timestamp column</span>
<span class="sd">            as well as the value column. This is the ``df`` for</span>
<span class="sd">            training the model, not for future prediction.</span>
<span class="sd">        time_col : `str`</span>
<span class="sd">            The column name in `df` representing time for the time series data</span>
<span class="sd">            The time column can be anything that can be parsed by pandas DatetimeIndex</span>
<span class="sd">        value_col: `str`</span>
<span class="sd">            The column name which has the value of interest to be forecasted</span>
<span class="sd">        time_properties : `dict` [`str`, `any`] or None, optional</span>
<span class="sd">            Time properties dictionary (likely produced by</span>
<span class="sd">            `~greykite.common.time_properties_forecast.get_forecast_time_properties`)</span>
<span class="sd">            with keys:</span>

<span class="sd">                ``&quot;ts&quot;`` : `UnivariateTimeSeries` or None</span>
<span class="sd">                    ``df`` converted to a ``UnivariateTimeSeries``.</span>
<span class="sd">                ``&quot;period&quot;`` : `int`</span>
<span class="sd">                    Period of each observation (i.e. minimum time between observations, in seconds).</span>
<span class="sd">                ``&quot;simple_freq&quot;`` : `SimpleTimeFrequencyEnum`</span>
<span class="sd">                    ``SimpleTimeFrequencyEnum`` member corresponding to data frequency.</span>
<span class="sd">                ``&quot;num_training_points&quot;`` : `int`</span>
<span class="sd">                    Number of observations for training.</span>
<span class="sd">                ``&quot;num_training_days&quot;`` : `int`</span>
<span class="sd">                    Number of days for training.</span>
<span class="sd">                ``&quot;start_year&quot;`` : `int`</span>
<span class="sd">                    Start year of the training period.</span>
<span class="sd">                ``&quot;end_year&quot;`` : `int`</span>
<span class="sd">                    End year of the forecast period.</span>
<span class="sd">                ``&quot;origin_for_time_vars&quot;`` : `float`</span>
<span class="sd">                    Continuous time representation of the first date in ``df``.</span>

<span class="sd">            In this function,</span>

<span class="sd">                - ``start_year`` and ``end_year`` are used to define ``daily_event_df_dict``.</span>
<span class="sd">                - ``simple_freq`` and ``num_training_days`` are used to define ``fs_components_df``.</span>
<span class="sd">                - ``simple_freq`` and ``num_training_days`` are used to set default ``feature_sets_enabled``.</span>
<span class="sd">                - ``origin_for_time_vars`` is used to set default ``origin_for_time_vars``.</span>
<span class="sd">                - the other parameters are ignored</span>

<span class="sd">            It is okay if ``num_training_points``, ``num_training_days``, ``start_year``, ``end_year``</span>
<span class="sd">            are computed for a superset of ``df``. This allows CV splits and backtest, which train on</span>
<span class="sd">            partial data, to use the same data-aware model parameters as the forecast on all training data.</span>

<span class="sd">            If None, the values are computed for ``df``. This corresponds to using the same</span>
<span class="sd">            modeling *approach* on the CV splits and backtest from `forecast_pipeline`, without</span>
<span class="sd">            requiring the same parameters. In this case, make sure ``forecast_horizon`` is at</span>
<span class="sd">            least as large as the test period for the split, to ensure all holidays are captured.</span>
<span class="sd">        freq : `str` or None, optional, default `None`</span>
<span class="sd">            Frequency of input data.</span>
<span class="sd">            Used to compute ``time_properties`` only if ``time_properties is None``.</span>
<span class="sd">            Frequency strings can have multiples, e.g. &#39;5H&#39;.</span>
<span class="sd">            See https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases</span>
<span class="sd">            for a list of frequency aliases.</span>
<span class="sd">            If None, inferred by `pandas.infer_freq`.</span>
<span class="sd">            Provide this parameter if ``df`` has missing timepoints.</span>
<span class="sd">        forecast_horizon : `int` or None, optional, default `None`</span>
<span class="sd">            Number of periods to forecast into the future. Must be &gt; 0.</span>
<span class="sd">            Used to compute ``time_properties`` only if ``time_properties is None``.</span>
<span class="sd">            If None, default is determined by input data frequency.</span>
<span class="sd">            Used to determine forecast end date, to pull the appropriate holiday data.</span>
<span class="sd">            Should be at least as large as the prediction period (if this function</span>
<span class="sd">            is called from ``forecast_pipeline``, the prediction period for different</span>
<span class="sd">            splits is set via ``cv_horizon``, ``test_horizon``, ``forecast_horizon``).</span>
<span class="sd">        origin_for_time_vars : `float` or None, optional, default `None`</span>
<span class="sd">            The time origin used to create continuous variables for time.</span>
<span class="sd">            If None, uses the value from ``time_properties``.</span>
<span class="sd">        train_test_thresh : `datetime.datetime` or None, optional, default `None`</span>
<span class="sd">            e.g. datetime.datetime(2019, 6, 30)</span>
<span class="sd">            The threshold for training and testing split.</span>
<span class="sd">            Note that the final returned model is trained using all data.</span>
<span class="sd">            If None, training split is based on ``training_fraction``.</span>
<span class="sd">        training_fraction : `float` or None, optional, default 0.9</span>
<span class="sd">            The fraction of data used for training (0.0 to 1.0)</span>
<span class="sd">            Used only if ``train_test_thresh is None``.</span>
<span class="sd">            If this is also None or 1.0, then we skip testing</span>
<span class="sd">            and train on the entire dataset.</span>
<span class="sd">        fit_algorithm : `str`, optional, default &quot;linear&quot;</span>
<span class="sd">            The type of predictive model used in fitting.</span>

<span class="sd">            See `~greykite.algo.common.ml_models.fit_model_via_design_matrix`</span>
<span class="sd">            for available options and their parameters.</span>
<span class="sd">        fit_algorithm_params : `dict` or None, optional, default None</span>
<span class="sd">            Parameters passed to the requested fit_algorithm.</span>
<span class="sd">            If None, uses the defaults in `~greykite.algo.common.ml_models.fit_model_via_design_matrix`.</span>
<span class="sd">        holiday_lookup_countries : `list` [`str`] or &quot;auto&quot; or None, optional, default &quot;auto&quot;</span>
<span class="sd">            The countries that contain the holidays you intend to model</span>
<span class="sd">            (``holidays_to_model_separately``).</span>

<span class="sd">                * If &quot;auto&quot;, uses a default list of countries</span>
<span class="sd">                  that contain the default ``holidays_to_model_separately``.</span>
<span class="sd">                  See `~greykite.algo.forecast.silverkite.constants.silverkite_holiday.SilverkiteHoliday.HOLIDAY_LOOKUP_COUNTRIES_AUTO`.</span>
<span class="sd">                * If a list, must be a list of country names.</span>
<span class="sd">                * If None or an empty list, no holidays are modeled.</span>

<span class="sd">        holidays_to_model_separately : `list` [`str`] or &quot;auto&quot; or `~greykite.algo.forecast.silverkite.constants.silverkite_holiday.SilverkiteHoliday.ALL_HOLIDAYS_IN_COUNTRIES` or None, optional, default &quot;auto&quot;  # noqa: E501</span>
<span class="sd">            Which holidays to include in the model.</span>
<span class="sd">            The model creates a separate key, value for each item in ``holidays_to_model_separately``.</span>
<span class="sd">            The other holidays in the countries are grouped together as a single effect.</span>

<span class="sd">                * If &quot;auto&quot;, uses a default list of important holidays.</span>
<span class="sd">                  See `~greykite.algo.forecast.silverkite.constants.silverkite_holiday.SilverkiteHoliday.HOLIDAYS_TO_MODEL_SEPARATELY_AUTO`.</span>
<span class="sd">                * If `~greykite.algo.forecast.silverkite.constants.silverkite_holiday.SilverkiteHoliday.ALL_HOLIDAYS_IN_COUNTRIES`,</span>
<span class="sd">                  uses all available holidays in ``holiday_lookup_countries``. This can often</span>
<span class="sd">                  create a model that has too many parameters, and should typically be avoided.</span>
<span class="sd">                * If a list, must be a list of holiday names.</span>
<span class="sd">                * If None or an empty list, all holidays in ``holiday_lookup_countries`` are grouped together</span>
<span class="sd">                  as a single effect.</span>

<span class="sd">            Use ``holiday_lookup_countries`` to provide a list of countries where these holiday occur.</span>
<span class="sd">        holiday_pre_num_days : `int`, default 2</span>
<span class="sd">            Model holiday effects for ``holiday_pre_num_days`` days before the holiday.</span>
<span class="sd">        holiday_post_num_days : `int`, default 2</span>
<span class="sd">            Model holiday effects for ``holiday_post_num_days`` days after the holiday.</span>
<span class="sd">        holiday_pre_post_num_dict : `dict` [`str`, (`int`, `int`)] or None, default None</span>
<span class="sd">            Overrides ``pre_num`` and ``post_num`` for each holiday in</span>
<span class="sd">            ``holidays_to_model_separately``.</span>
<span class="sd">            For example, if ``holidays_to_model_separately`` contains &quot;Thanksgiving&quot; and &quot;Labor Day&quot;,</span>
<span class="sd">            this parameter can be set to ``{&quot;Thanksgiving&quot;: [1, 3], &quot;Labor Day&quot;: [1, 2]}``,</span>
<span class="sd">            denoting that the &quot;Thanksgiving&quot; ``pre_num`` is 1 and ``post_num`` is 3, and &quot;Labor Day&quot;</span>
<span class="sd">            ``pre_num`` is 1 and ``post_num`` is 2.</span>
<span class="sd">            Holidays not specified use the default given by ``pre_num`` and ``post_num``.</span>
<span class="sd">        daily_event_df_dict : `dict` [`str`, `pandas.DataFrame`] or None, default None</span>
<span class="sd">            A dictionary of data frames, each representing events data for the corresponding key.</span>
<span class="sd">            Specifies additional events to include besides the holidays specified above. The format</span>
<span class="sd">            is the same as in `~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`.</span>
<span class="sd">            The DataFrame has two columns:</span>

<span class="sd">                - The first column contains event dates. Must be in a format</span>
<span class="sd">                  recognized by `pandas.to_datetime`. Must be at daily</span>
<span class="sd">                  frequency for proper join. It is joined against the time</span>
<span class="sd">                  in ``df``, converted to a day:</span>
<span class="sd">                  ``pd.to_datetime(pd.DatetimeIndex(df[time_col]).date)``.</span>
<span class="sd">                - the second column contains the event label for each date</span>

<span class="sd">            The column order is important; column names are ignored.</span>
<span class="sd">            The event dates must span their occurrences in both the training</span>
<span class="sd">            and future prediction period.</span>

<span class="sd">            During modeling, each key in the dictionary is mapped to a categorical variable</span>
<span class="sd">            named ``f&quot;{EVENT_PREFIX}_{key}&quot;``, whose value at each timestamp is specified</span>
<span class="sd">            by the corresponding DataFrame.</span>

<span class="sd">            For example, to manually specify a yearly event on September 1</span>
<span class="sd">            during a training/forecast period that spans 2020-2022::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;custom_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;, &quot;2022-09-01&quot;],</span>
<span class="sd">                        &quot;label&quot;: [&quot;is_event&quot;, &quot;is_event&quot;, &quot;is_event&quot;]</span>
<span class="sd">                    })</span>
<span class="sd">                }</span>

<span class="sd">            It&#39;s possible to specify multiple events in the same df. Two events,</span>
<span class="sd">            ``&quot;sep&quot;`` and ``&quot;oct&quot;`` are specified below for 2020-2021::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;custom_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2020-10-01&quot;, &quot;2021-09-01&quot;, &quot;2021-10-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: [&quot;sep&quot;, &quot;oct&quot;, &quot;sep&quot;, &quot;oct&quot;]</span>
<span class="sd">                    })</span>
<span class="sd">                }</span>

<span class="sd">            Use multiple keys if two events may fall on the same date. These events</span>
<span class="sd">            must be in separate DataFrames::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;fixed_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;, &quot;2022-09-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;fixed_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                    &quot;moving_event&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-08-28&quot;, &quot;2022-09-03&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;moving_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                }</span>

<span class="sd">            The multiple event specification can be used even if events never overlap. An</span>
<span class="sd">            equivalent specification to the second example::</span>

<span class="sd">                daily_event_df_dict = {</span>
<span class="sd">                    &quot;sep&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-09-01&quot;, &quot;2021-09-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;is_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                    &quot;oct&quot;: pd.DataFrame({</span>
<span class="sd">                        &quot;date&quot;: [&quot;2020-10-01&quot;, &quot;2021-10-01&quot;],</span>
<span class="sd">                        &quot;event_name&quot;: &quot;is_event&quot;</span>
<span class="sd">                    }),</span>
<span class="sd">                }</span>

<span class="sd">            Note: All these events are automatically added to the model. There is no need</span>
<span class="sd">            to specify them in ``extra_pred_cols`` as you would for</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`.</span>

<span class="sd">            Note: Do not use `~greykite.common.constants.EVENT_DEFAULT`</span>
<span class="sd">            in the second column. This is reserved to indicate dates that do not</span>
<span class="sd">            correspond to an event.</span>
<span class="sd">        changepoints_dict : `dict` or None, optional, default None</span>
<span class="sd">            Specifies the changepoint configuration.</span>

<span class="sd">            ``&quot;method&quot;``: `str`</span>
<span class="sd">                The method to locate changepoints.</span>
<span class="sd">                Valid options:</span>

<span class="sd">                    - &quot;uniform&quot;. Places n_changepoints evenly spaced changepoints to allow growth to change.</span>
<span class="sd">                    - &quot;custom&quot;. Places changepoints at the specified dates.</span>
<span class="sd">                    - &quot;auto&quot;. Automatically detects change points. For configuration, see</span>
<span class="sd">                      `~greykite.algo.changepoint.adalasso.changepoint_detector.ChangepointDetector.find_trend_changepoints`</span>

<span class="sd">                Additional keys to provide parameters for each particular method are described below.</span>
<span class="sd">            ``&quot;continuous_time_col&quot;``: `str`, optional</span>
<span class="sd">                Column to apply ``growth_func`` to, to generate changepoint features</span>
<span class="sd">                Typically, this should match the growth term in the model</span>
<span class="sd">            ``&quot;growth_func&quot;``: callable or None, optional</span>
<span class="sd">                Growth function (scalar -&gt; scalar). Changepoint features are created</span>
<span class="sd">                by applying ``growth_func`` to ``continuous_time_col`` with offsets.</span>
<span class="sd">                If None, uses identity function to use ``continuous_time_col`` directly</span>
<span class="sd">                as growth term</span>
<span class="sd">                If changepoints_dict[&quot;method&quot;] == &quot;uniform&quot;, this other key is required:</span>

<span class="sd">                    ``&quot;n_changepoints&quot;``: int</span>
<span class="sd">                        number of changepoints to evenly space across training period</span>

<span class="sd">                If changepoints_dict[&quot;method&quot;] == &quot;custom&quot;, this other key is required:</span>

<span class="sd">                    ``&quot;dates&quot;``: Iterable[Union[int, float, str, datetime]]</span>
<span class="sd">                        Changepoint dates. Must be parsable by pd.to_datetime.</span>
<span class="sd">                        Changepoints are set at the closest time on or after these dates</span>
<span class="sd">                        in the dataset.</span>

<span class="sd">                If changepoints_dict[&quot;method&quot;] == &quot;auto&quot;, the keys that matches the parameters in</span>
<span class="sd">                `~greykite.algo.changepoint.adalasso.changepoint_detector.ChangepointDetector.find_trend_changepoints`,</span>
<span class="sd">                except ``df``, ``time_col`` and ``value_col``, are optional.</span>
<span class="sd">                Extra keys also include &quot;dates&quot;, &quot;combine_changepoint_min_distance&quot; and &quot;keep_detected&quot; to specify</span>
<span class="sd">                additional custom trend changepoints. These three parameters correspond to the three parameters</span>
<span class="sd">                &quot;custom_changepoint_dates&quot;, &quot;min_distance&quot; and &quot;keep_detected&quot; in</span>
<span class="sd">                `~greykite.algo.changepoint.adalasso.changepoints_utils.combine_detected_and_custom_trend_changepoints`.</span>

<span class="sd">        yearly_seasonality : `str` or `bool` or `int`</span>
<span class="sd">            Determines the yearly seasonality.</span>
<span class="sd">            &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">        quarterly_seasonality : `str` or `bool` or `int`</span>
<span class="sd">            Determines the quarterly seasonality.</span>
<span class="sd">            &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">        monthly_seasonality : `str` or `bool` or `int`</span>
<span class="sd">            Determines the monthly seasonality.</span>
<span class="sd">            &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">        weekly_seasonality : `str` or `bool` or `int`</span>
<span class="sd">            Determines the weekly seasonality.</span>
<span class="sd">            &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">        daily_seasonality : `str` or `bool` or `int`</span>
<span class="sd">            Determines the daily seasonality.</span>
<span class="sd">            &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">        max_daily_seas_interaction_order : `int` or None, optional, default `None`</span>
<span class="sd">            Max fourier order for interaction terms with daily seasonality.</span>
<span class="sd">            If None, uses all available terms.</span>
<span class="sd">        max_weekly_seas_interaction_order : `int` or None, optional, default `None`</span>
<span class="sd">            Max fourier order for interaction terms with weekly seasonality.</span>
<span class="sd">            If None, uses all available terms.</span>
<span class="sd">        autoreg_dict : `dict` or None, optional, default `None`</span>
<span class="sd">            A dictionary with arguments for `~greykite.common.features.timeseries_lags.build_autoreg_df`.</span>
<span class="sd">            That function&#39;s parameter ``value_col`` is inferred from the input of</span>
<span class="sd">            current function ``SilverkiteForecast::forecast``. Other keys are:</span>

<span class="sd">                ``&quot;lag_dict&quot;`` : `dict` or None</span>
<span class="sd">                ``&quot;agg_lag_dict&quot;`` : `dict` or None</span>
<span class="sd">                ``&quot;series_na_fill_func&quot;`` : callable</span>

<span class="sd">            See more details for above parameters in</span>
<span class="sd">            `~greykite.common.features.timeseries_lags.build_autoreg_df`.</span>
<span class="sd">        seasonality_changepoints_dict : `dict` or None, optional, default `None`</span>
<span class="sd">            The parameter dictionary for seasonality change point detection. Parameters are in</span>
<span class="sd">            `~greykite.algo.changepoint.adalasso.changepoint_detector.ChangepointDetector.find_seasonality_changepoints`.</span>
<span class="sd">            Note ``df``, ``time_col``, ``value_col`` and ``trend_changepoints`` are auto populated,</span>
<span class="sd">            and do not need to be provided.</span>
<span class="sd">        min_admissible_value : `float` or None, optional, default `None`</span>
<span class="sd">            The minimum admissible value to return during prediction.</span>
<span class="sd">            If None, no limit is applied.</span>
<span class="sd">        max_admissible_value : `float` or None, optional, default `None`</span>
<span class="sd">            The maximum admissible value to return during prediction.</span>
<span class="sd">            If None, no limit is applied.</span>
<span class="sd">        uncertainty_dict : `dict` or None, optional, default `None`</span>
<span class="sd">            How to fit the uncertainty model. A dictionary with keys:</span>
<span class="sd">                ``&quot;uncertainty_method&quot;`` : `str`</span>
<span class="sd">                    The title of the method.</span>
<span class="sd">                    Only &quot;simple_conditional_residuals&quot; is implemented</span>
<span class="sd">                    in ``fit_prediction_model`` which calculates CIs using residuals</span>
<span class="sd">                ``&quot;params&quot;``: `dict`</span>
<span class="sd">                    A dictionary of parameters needed for</span>
<span class="sd">                    the requested ``uncertainty_method``. For example, for</span>
<span class="sd">                    ``uncertainty_method=&quot;simple_conditional_residuals&quot;``, see</span>
<span class="sd">                    parameters of `~greykite.algo.uncertainty.conditional.conf_interval.conf_interval`,</span>
<span class="sd">                    listed briefly here:</span>

<span class="sd">                        ``&quot;conditional_cols&quot;``</span>
<span class="sd">                        ``&quot;quantiles&quot;``</span>
<span class="sd">                        ``&quot;quantile_estimation_method&quot;``</span>
<span class="sd">                        ``&quot;sample_size_thresh&quot;``</span>
<span class="sd">                        ``&quot;small_sample_size_method&quot;``</span>
<span class="sd">                        ``&quot;small_sample_size_quantile&quot;``</span>

<span class="sd">            If None, no uncertainty intervals are calculated.</span>
<span class="sd">        growth_term : `str` or None, optional, default &quot;ct1&quot;</span>
<span class="sd">            How to model the growth. Valid options are</span>
<span class="sd">            {&quot;linear&quot;, &quot;quadratic&quot;, &quot;sqrt&quot;, &quot;cuberoot&quot;}.</span>
<span class="sd">        regressor_cols : `list` [`str`] or None, optional, default None</span>
<span class="sd">            The columns in ``df`` to use as regressors.</span>
<span class="sd">            These must be provided during prediction as well.</span>
<span class="sd">        feature_sets_enabled: `dict` [`str`, `bool` or &quot;auto&quot; or None] or `bool` or &quot;auto&quot; or None, default &quot;auto&quot;</span>
<span class="sd">            Whether to include interaction terms and categorical variables to increase model flexibility.</span>

<span class="sd">            If a `dict`, boolean values indicate whether include various sets of features in the model.</span>
<span class="sd">            The following keys are recognized</span>
<span class="sd">            (from `~greykite.algo.forecast.silverkite.constants.silverkite_column.SilverkiteColumn`):</span>

<span class="sd">                ``&quot;COLS_HOUR_OF_WEEK&quot;`` : `str`</span>
<span class="sd">                    Constant hour of week effect</span>
<span class="sd">                ``&quot;COLS_WEEKEND_SEAS&quot;`` : `str`</span>
<span class="sd">                    Daily seasonality interaction with is_weekend</span>
<span class="sd">                ``&quot;COLS_DAY_OF_WEEK_SEAS&quot;`` : `str`</span>
<span class="sd">                    Daily seasonality interaction with day of week</span>
<span class="sd">                ``&quot;COLS_TREND_DAILY_SEAS&quot;`` : `str`</span>
<span class="sd">                    Allow daily seasonality to change over time by is_weekend</span>
<span class="sd">                ``&quot;COLS_EVENT_SEAS&quot;`` : `str`</span>
<span class="sd">                    Allow sub-daily event effects</span>
<span class="sd">                ``&quot;COLS_EVENT_WEEKEND_SEAS&quot;`` : `str`</span>
<span class="sd">                    Allow sub-daily event effect to interact with is_weekend</span>
<span class="sd">                ``&quot;COLS_DAY_OF_WEEK&quot;`` : `str`</span>
<span class="sd">                    Constant day of week effect</span>
<span class="sd">                ``&quot;COLS_TREND_WEEKEND&quot;`` : `str`</span>
<span class="sd">                    Allow trend (growth, changepoints) to interact with is_weekend</span>
<span class="sd">                ``&quot;COLS_TREND_DAY_OF_WEEK&quot;`` : `str`</span>
<span class="sd">                    Allow trend to interact with day of week</span>
<span class="sd">                ``&quot;COLS_TREND_WEEKLY_SEAS&quot;`` : `str`</span>
<span class="sd">                    Allow weekly seasonality to change over time</span>

<span class="sd">            The following dictionary values are recognized:</span>

<span class="sd">                - True: include the feature set in the model</span>
<span class="sd">                - False: do not include the feature set in the model</span>
<span class="sd">                - None: do not include the feature set in the model</span>
<span class="sd">                - &quot;auto&quot; or not provided: use the default setting based on data frequency and size</span>

<span class="sd">            If not a `dict`:</span>

<span class="sd">                - if a boolean, equivalent to a dictionary with all values set to the boolean.</span>
<span class="sd">                - if None, equivalent to a dictionary with all values set to False.</span>
<span class="sd">                - if &quot;auto&quot;, equivalent to a dictionary with all values set to &quot;auto&quot;.</span>

<span class="sd">        extra_pred_cols : `list` [`str`] or None, optional, default `None`</span>
<span class="sd">            Columns to include in ``extra_pred_cols`` for ``SilverkiteForecast::forecast``.</span>
<span class="sd">            Other columns are added to ``extra_pred_cols`` by the other</span>
<span class="sd">            parameters of this function (i.e. ``holidays_*``, ``growth_term``,</span>
<span class="sd">            ``regressors``, ``feature_sets_enabled``).</span>
<span class="sd">            If `None`, treated is the same as [].</span>
<span class="sd">        regression_weight_col : `str` or None, default None</span>
<span class="sd">            The column name for the weights to be used in weighted regression version</span>
<span class="sd">            of applicable machine-learning models.</span>
<span class="sd">        simulation_based : `bool`, default False</span>
<span class="sd">            Boolean to specify if the future predictions are to be using simulations</span>
<span class="sd">            or not.</span>
<span class="sd">            Note that this is only used in deciding what parameters should be</span>
<span class="sd">            used for certain components e.g. autoregression, if automatic methods</span>
<span class="sd">            are requested. However, the auto-settings and the prediction settings</span>
<span class="sd">            regarding using simulations should match.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        parameters : `dict`</span>
<span class="sd">            Parameters to call :func:`~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regressor_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regressor_cols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">extra_pred_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extra_pred_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Does not modify the input list</span>
            <span class="n">extra_pred_cols</span> <span class="o">=</span> <span class="n">extra_pred_cols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">time_properties</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># ``df`` only contains the dates for training,</span>
            <span class="c1"># so we can use ``use_univariate_ts=False``.</span>
            <span class="c1"># ``forecast_horizon`` must be at least as large as</span>
            <span class="c1"># the actual size of the test set / forecast set</span>
            <span class="c1"># in order to pull all holidays</span>
            <span class="n">time_properties</span> <span class="o">=</span> <span class="n">get_forecast_time_properties</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">regressor_cols</span><span class="o">=</span><span class="n">regressor_cols</span><span class="p">,</span>
                <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">forecast_horizon</span> <span class="o">=</span> <span class="n">forecast_horizon</span> <span class="ow">or</span> <span class="n">time_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;forecast_horizon&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">origin_for_time_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin_for_time_vars</span> <span class="o">=</span> <span class="n">time_properties</span><span class="p">[</span><span class="s2">&quot;origin_for_time_vars&quot;</span><span class="p">]</span>

        <span class="c1"># Specifies seasonality (added to ``extra_pred_cols`` by `SilverkiteForecast::forecast`)</span>
        <span class="n">seasonality_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;yearly_seasonality&quot;</span><span class="p">:</span> <span class="n">yearly_seasonality</span><span class="p">,</span>
            <span class="s2">&quot;quarterly_seasonality&quot;</span><span class="p">:</span> <span class="n">quarterly_seasonality</span><span class="p">,</span>
            <span class="s2">&quot;monthly_seasonality&quot;</span><span class="p">:</span> <span class="n">monthly_seasonality</span><span class="p">,</span>
            <span class="s2">&quot;weekly_seasonality&quot;</span><span class="p">:</span> <span class="n">weekly_seasonality</span><span class="p">,</span>
            <span class="s2">&quot;daily_seasonality&quot;</span><span class="p">:</span> <span class="n">daily_seasonality</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">fs_components_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_silverkite_seasonality</span><span class="p">(</span>
            <span class="n">simple_freq</span><span class="o">=</span><span class="n">time_properties</span><span class="p">[</span><span class="s2">&quot;simple_freq&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">num_days</span><span class="o">=</span><span class="n">time_properties</span><span class="p">[</span><span class="s2">&quot;num_training_days&quot;</span><span class="p">],</span>
            <span class="n">seasonality</span><span class="o">=</span><span class="n">seasonality_dict</span><span class="p">)</span>

        <span class="c1"># Specifies growth (via ``extra_pred_cols``)</span>
        <span class="n">growth_term_formula</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">growth_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">growth_term_formula</span> <span class="o">=</span> <span class="n">GROWTH_COL_ALIAS</span><span class="p">[</span><span class="n">growth_term</span><span class="p">]</span>
            <span class="n">extra_pred_cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">growth_term_formula</span><span class="p">]</span>

        <span class="c1"># Specifies regressors (via ``extra_pred_cols``)</span>
        <span class="k">if</span> <span class="n">regressor_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extra_pred_cols</span> <span class="o">+=</span> <span class="n">regressor_cols</span>

        <span class="c1"># Specifies events (via ``daily_event_df_dict``, ``extra_pred_cols``).</span>
        <span class="c1"># Constant daily effect.</span>
        <span class="n">holiday_df_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_silverkite_holidays</span><span class="p">(</span>
            <span class="n">holiday_lookup_countries</span><span class="o">=</span><span class="n">holiday_lookup_countries</span><span class="p">,</span>
            <span class="n">holidays_to_model_separately</span><span class="o">=</span><span class="n">holidays_to_model_separately</span><span class="p">,</span>
            <span class="n">start_year</span><span class="o">=</span><span class="n">time_properties</span><span class="p">[</span><span class="s2">&quot;start_year&quot;</span><span class="p">],</span>
            <span class="n">end_year</span><span class="o">=</span><span class="n">time_properties</span><span class="p">[</span><span class="s2">&quot;end_year&quot;</span><span class="p">],</span>
            <span class="n">pre_num</span><span class="o">=</span><span class="n">holiday_pre_num_days</span><span class="p">,</span>
            <span class="n">post_num</span><span class="o">=</span><span class="n">holiday_post_num_days</span><span class="p">,</span>
            <span class="n">pre_post_num_dict</span><span class="o">=</span><span class="n">holiday_pre_post_num_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">holiday_df_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Adds holidays to the user-specified events,</span>
            <span class="c1"># giving preference to user events</span>
            <span class="c1"># if there are conflicts</span>
            <span class="n">daily_event_df_dict</span> <span class="o">=</span> <span class="n">update_dictionary</span><span class="p">(</span>
                <span class="n">holiday_df_dict</span><span class="p">,</span>
                <span class="n">overwrite_dict</span><span class="o">=</span><span class="n">daily_event_df_dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">daily_event_df_dict</span><span class="p">:</span>
            <span class="c1"># Sets empty dictionary to None</span>
            <span class="n">daily_event_df_dict</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">extra_pred_cols</span> <span class="o">+=</span> <span class="n">get_event_pred_cols</span><span class="p">(</span><span class="n">daily_event_df_dict</span><span class="p">)</span>

        <span class="c1"># Specifies ``extra_pred_cols`` (interactions and additional model terms).</span>
        <span class="c1"># Seasonality interaction order is limited by the available order and max requested.</span>
        <span class="n">daily_seas_interaction_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_seasonality_order_from_dataframe</span><span class="p">(</span>
            <span class="n">seasonality</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="o">.</span><span class="n">DAILY_SEASONALITY</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">fs</span><span class="o">=</span><span class="n">fs_components_df</span><span class="p">,</span>
            <span class="n">max_order</span><span class="o">=</span><span class="n">max_daily_seas_interaction_order</span>
        <span class="p">)</span>

        <span class="n">weekly_seas_interaction_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_seasonality_order_from_dataframe</span><span class="p">(</span>
            <span class="n">seasonality</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="o">.</span><span class="n">WEEKLY_SEASONALITY</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">fs</span><span class="o">=</span><span class="n">fs_components_df</span><span class="p">,</span>
            <span class="n">max_order</span><span class="o">=</span><span class="n">max_weekly_seas_interaction_order</span>
        <span class="p">)</span>

        <span class="c1"># updates `changepoints_dict`, unchanged if not &quot;method&quot; == &quot;auto&quot;</span>
        <span class="n">changepoints_dict</span><span class="p">,</span> <span class="n">changepoint_detector</span> <span class="o">=</span> <span class="n">get_changepoints_dict</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
            <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>
            <span class="n">changepoints_dict</span><span class="o">=</span><span class="n">changepoints_dict</span><span class="p">)</span>

        <span class="c1"># determines changepoint column names</span>
        <span class="k">if</span> <span class="n">changepoints_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">changepoints</span> <span class="o">=</span> <span class="n">get_changepoint_features_and_values_from_config</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>  <span class="c1"># the training dataset</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">changepoints_dict</span><span class="o">=</span><span class="n">changepoints_dict</span><span class="p">,</span>
                <span class="n">origin_for_time_vars</span><span class="o">=</span><span class="n">origin_for_time_vars</span><span class="p">)</span>
            <span class="n">changepoint_cols</span> <span class="o">=</span> <span class="n">changepoints</span><span class="p">[</span><span class="s2">&quot;changepoint_cols&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">changepoint_cols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">feature_sets_enabled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_feature_sets_enabled</span><span class="p">(</span>
            <span class="n">simple_freq</span><span class="o">=</span><span class="n">time_properties</span><span class="p">[</span><span class="s2">&quot;simple_freq&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">num_days</span><span class="o">=</span><span class="n">time_properties</span><span class="p">[</span><span class="s2">&quot;num_training_days&quot;</span><span class="p">],</span>
            <span class="n">feature_sets_enabled</span><span class="o">=</span><span class="n">feature_sets_enabled</span><span class="p">)</span>

        <span class="n">model_feature_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_feature_sets_terms</span><span class="p">(</span>
            <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="n">daily_event_df_dict</span><span class="p">,</span>
            <span class="n">daily_seas_interaction_order</span><span class="o">=</span><span class="n">daily_seas_interaction_order</span><span class="p">,</span>
            <span class="n">weekly_seas_interaction_order</span><span class="o">=</span><span class="n">weekly_seas_interaction_order</span><span class="p">,</span>
            <span class="n">growth_term</span><span class="o">=</span><span class="n">growth_term_formula</span><span class="p">,</span>
            <span class="n">changepoint_cols</span><span class="o">=</span><span class="n">changepoint_cols</span><span class="p">)</span>

        <span class="c1"># extends ``extra_pred_cols`` by the requested feature sets from ``feature_sets_enabled``</span>
        <span class="k">for</span> <span class="n">feature_set_name</span><span class="p">,</span> <span class="n">feature_set_terms</span> <span class="ow">in</span> <span class="n">model_feature_terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">feature_sets_enabled</span><span class="p">[</span><span class="n">feature_set_name</span><span class="p">]:</span>
                <span class="n">extra_pred_cols</span> <span class="o">+=</span> <span class="n">feature_set_terms</span>
        <span class="n">extra_pred_cols</span> <span class="o">=</span> <span class="n">unique_elements_in_list</span><span class="p">(</span><span class="n">extra_pred_cols</span><span class="p">)</span>

        <span class="c1"># the parameters to call ``SilverkiteForecast::forecast``</span>
        <span class="c1"># parameters that are directly passed through are noted below</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>                                                          <span class="c1"># pass-through</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>                                              <span class="c1"># pass-through</span>
            <span class="n">value_col</span><span class="o">=</span><span class="n">value_col</span><span class="p">,</span>                                            <span class="c1"># pass-through</span>
            <span class="n">origin_for_time_vars</span><span class="o">=</span><span class="n">origin_for_time_vars</span><span class="p">,</span>
            <span class="n">extra_pred_cols</span><span class="o">=</span><span class="n">extra_pred_cols</span><span class="p">,</span>
            <span class="n">train_test_thresh</span><span class="o">=</span><span class="n">train_test_thresh</span><span class="p">,</span>                            <span class="c1"># pass-through</span>
            <span class="n">training_fraction</span><span class="o">=</span><span class="n">training_fraction</span><span class="p">,</span>                            <span class="c1"># pass-through</span>
            <span class="n">fit_algorithm</span><span class="o">=</span><span class="n">fit_algorithm</span><span class="p">,</span>                                    <span class="c1"># pass-through</span>
            <span class="n">fit_algorithm_params</span><span class="o">=</span><span class="n">fit_algorithm_params</span><span class="p">,</span>                      <span class="c1"># pass-through</span>
            <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="n">daily_event_df_dict</span><span class="p">,</span>
            <span class="n">fs_components_df</span><span class="o">=</span><span class="n">fs_components_df</span><span class="p">,</span>
            <span class="n">autoreg_dict</span><span class="o">=</span><span class="n">autoreg_dict</span><span class="p">,</span>                                      <span class="c1"># pass-through</span>
            <span class="n">changepoints_dict</span><span class="o">=</span><span class="n">changepoints_dict</span><span class="p">,</span>                            <span class="c1"># pass-through</span>
            <span class="n">seasonality_changepoints_dict</span><span class="o">=</span><span class="n">seasonality_changepoints_dict</span><span class="p">,</span>    <span class="c1"># pass-through</span>
            <span class="n">changepoint_detector</span><span class="o">=</span><span class="n">changepoint_detector</span><span class="p">,</span>
            <span class="n">min_admissible_value</span><span class="o">=</span><span class="n">min_admissible_value</span><span class="p">,</span>                      <span class="c1"># pass-through</span>
            <span class="n">max_admissible_value</span><span class="o">=</span><span class="n">max_admissible_value</span><span class="p">,</span>                      <span class="c1"># pass-through</span>
            <span class="n">uncertainty_dict</span><span class="o">=</span><span class="n">uncertainty_dict</span><span class="p">,</span>                              <span class="c1"># pass-through</span>
            <span class="n">regression_weight_col</span><span class="o">=</span><span class="n">regression_weight_col</span><span class="p">,</span>                    <span class="c1"># pass-through</span>
            <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">,</span>                              <span class="c1"># pass-through</span>
            <span class="n">simulation_based</span><span class="o">=</span><span class="n">simulation_based</span>                               <span class="c1"># pass-through</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">parameters</span></div>

<div class="viewcode-block" id="SimpleSilverkiteForecast.forecast_simple"><a class="viewcode-back" href="../../../../../pages/autodoc/doc.html#greykite.algo.forecast.silverkite.forecast_simple_silverkite.SimpleSilverkiteForecast.forecast_simple">[docs]</a>    <span class="k">def</span> <span class="nf">forecast_simple</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A wrapper around ``SilverkiteForecast::forecast`` that simplifies some of the input parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : positional args</span>
<span class="sd">            Positional args to pass to</span>
<span class="sd">            :func:`~greykite.algo.forecast.silverkite.forecast_simple_silverkite.convert_simple_silverkite_params`.</span>
<span class="sd">            See that function for details.</span>

<span class="sd">        kwargs : keyword args</span>
<span class="sd">            Keyword args to pass to</span>
<span class="sd">            :func:`~greykite.algo.forecast.silverkite.forecast_simple_silverkite.convert_simple_silverkite_params`.</span>
<span class="sd">            See that function for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trained_model : `dict`</span>
<span class="sd">            The return value of :func:`~greykite.algo.forecast.silverkite.SilverkiteForecast.forecast`</span>
<span class="sd">            A dictionary that includes the fitted model from the function</span>
<span class="sd">            :func:`~greykite.algo.common.ml_models.fit_ml_model_with_evaluation`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_params</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">trained_model</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">forecast</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trained_model</span></div>

    <span class="k">def</span> <span class="nf">__get_requested_seasonality_order</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">requested_seasonality</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">default_order</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">is_enabled_auto</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns requested seasonality fourier series order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        requested_seasonality :  `str` or `bool` or `int`, default = &#39;auto&#39;</span>
<span class="sd">            The requested seasonality.</span>
<span class="sd">            &#39;auto&#39;, True, False, or a number for the Fourier order.</span>
<span class="sd">        default_order : `int`</span>
<span class="sd">            The default order to use for &#39;auto&#39; and True.</span>
<span class="sd">        is_enabled_auto : `bool`</span>
<span class="sd">            Whether the seasonality should be modeled for &#39;auto&#39; seasonality.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        order : `int`</span>
<span class="sd">            Seasonality fourier series order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">requested_seasonality</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="p">(</span><span class="n">requested_seasonality</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">and</span> <span class="n">is_enabled_auto</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">default_order</span>
        <span class="k">elif</span> <span class="n">requested_seasonality</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="p">(</span><span class="n">requested_seasonality</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_enabled_auto</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">requested_seasonality</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Requested seasonality order &#39;</span><span class="si">{</span><span class="n">requested_seasonality</span><span class="si">}</span><span class="s2">&#39; must be one of:&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; &#39;auto&#39;, True, False, integer&quot;</span><span class="p">,</span> <span class="n">LoggingLevelEnum</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">return</span> <span class="n">order</span>

    <span class="k">def</span> <span class="nf">__get_silverkite_seasonality</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">simple_freq</span><span class="o">=</span><span class="n">SimpleTimeFrequencyEnum</span><span class="o">.</span><span class="n">DAY</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">num_days</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
            <span class="n">seasonality</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates `fs_components_df` parameter for `forecast_silverkite`</span>
<span class="sd">        for modeling seasonality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simple_freq : `str`</span>
<span class="sd">            SimpleTimeFrequencyEnum member that best matches the input data frequency</span>
<span class="sd">            according to `get_simple_time_frequency_from_period`</span>
<span class="sd">        num_days : `int`</span>
<span class="sd">            Number of days of observations in the input data</span>
<span class="sd">        seasonality : `dict` or None</span>
<span class="sd">            Seasonality configuration dictionary, with the following optional keys.</span>
<span class="sd">            (keys are SilverkiteSeasonalityEnum members in lower case):</span>

<span class="sd">                - ``&quot;yearly_seasonality&quot;`` : `str` or `bool` or `int` or None, default = &#39;auto&#39;</span>
<span class="sd">                    Determines the yearly seasonality</span>
<span class="sd">                    &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">                ``&quot;quarterly_seasonality&quot;`` : `str` or `bool` or `int` or None, default = &#39;auto&#39;</span>
<span class="sd">                    Determines the quarterly seasonality</span>
<span class="sd">                    &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">                ``&quot;monthly_seasonality&quot;`` : `str` or `bool` or `int` or None, default = &#39;auto&#39;</span>
<span class="sd">                    Determines the monthly seasonality</span>
<span class="sd">                    &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">                ``&quot;weekly_seasonality&quot;`` : `str` or `bool` or `int` or None, default = &#39;auto&#39;</span>
<span class="sd">                    Determines the weekly seasonality</span>
<span class="sd">                    &#39;auto&#39;, True, False, or a number for the Fourier order</span>
<span class="sd">                ``&quot;daily_seasonality&quot;`` : `str` or `bool` or `int` or None, default = &#39;auto&#39;</span>
<span class="sd">                    Determines the daily seasonality</span>
<span class="sd">                    &#39;auto&#39;, True, False, or a number for the Fourier order</span>

<span class="sd">            None is equivalent to &#39;auto&#39;. If &#39;auto&#39;, seasonality components are based on input data</span>
<span class="sd">            (``num_days``, ``simple_freq``), according to</span>
<span class="sd">            `~greykite.algo.forecast.silverkite.constants.silverkite_seasonality.SilverkiteSeasonalityEnum`.</span>
<span class="sd">            and `~greykite.algo.forecast.silverkite.constants.silverkite_time_frequency.SilverkiteTimeFrequencyEnum`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fs_components_df : `pandas.DataFrame`</span>
<span class="sd">            Contains fourier series specification. Columns:</span>

<span class="sd">                - &quot;name&quot;</span>
<span class="sd">                - &quot;period&quot;</span>
<span class="sd">                - &quot;order&quot;</span>
<span class="sd">                - &quot;seas_names&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seasonality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seasonality</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># recognized seasonalities for silverkite</span>
        <span class="n">silverkite_seasonalities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="o">.</span><span class="n">__members__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">silverkite_seasonalities</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">silverkite_seasonalities</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># valid seasonalities based on input data frequency</span>
        <span class="n">freq_valid_seas_names</span> <span class="o">=</span> <span class="n">SimpleTimeFrequencyEnum</span><span class="p">[</span><span class="n">simple_freq</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">valid_seas</span>
        <span class="n">freq_auto_seas_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_time_frequency_enum</span><span class="p">[</span><span class="n">simple_freq</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">auto_fourier_seas</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">seasonality</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">silverkite_seasonalities</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> must be one of </span><span class="si">{</span><span class="n">silverkite_seasonalities</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">seasonalities</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># seasonalities to add to the model</span>
        <span class="k">for</span> <span class="n">seas</span> <span class="ow">in</span> <span class="n">silverkite_seasonalities</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># keys are SilverkiteSeasonalityEnum members in lower case</span>
            <span class="n">seas_input</span> <span class="o">=</span> <span class="n">seasonality</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">seas</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="s2">&quot;auto&quot;</span><span class="p">)</span>
            <span class="c1"># under auto configuration, seasonality is added if it&#39;s recommended for both</span>
            <span class="c1"># the input frequency and data size</span>
            <span class="n">is_enabled_auto</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">num_days</span> <span class="o">&gt;=</span> <span class="n">seas</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">default_min_days</span>
                    <span class="ow">and</span> <span class="n">seas</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">freq_auto_seas_names</span><span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_requested_seasonality_order</span><span class="p">(</span>
                <span class="n">requested_seasonality</span><span class="o">=</span><span class="n">seas_input</span><span class="p">,</span>
                <span class="n">default_order</span><span class="o">=</span><span class="n">seas</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">order</span><span class="p">,</span>
                <span class="n">is_enabled_auto</span><span class="o">=</span><span class="n">is_enabled_auto</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seas</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">freq_valid_seas_names</span><span class="p">:</span>
                    <span class="n">log_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">seas</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">&#39; is typically not valid for &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;data with &#39;</span><span class="si">{</span><span class="n">simple_freq</span><span class="si">}</span><span class="s2">&#39; frequency. Each seasonality period &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;should cover multiple observations in the data. To remove &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;these seasonality terms from the model, remove </span><span class="si">{</span><span class="n">seas</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">seas_input</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;or set it to &#39;auto&#39; or 0.&quot;</span><span class="p">,</span> <span class="n">LoggingLevelEnum</span><span class="o">.</span><span class="n">WARNING</span><span class="p">)</span>
                <span class="n">seasonalities</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">seas</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s2">&quot;period&quot;</span><span class="p">:</span> <span class="n">seas</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">period</span><span class="p">,</span>
                    <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="n">order</span><span class="p">,</span>  <span class="c1"># user is allowed to override default order</span>
                    <span class="s2">&quot;seas_names&quot;</span><span class="p">:</span> <span class="n">seas</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">seas_names</span>
                <span class="p">})</span>

        <span class="c1"># constructs dataframe where each seasonality is a row</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seasonalities</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">seasonalities</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;period&quot;</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">,</span> <span class="s2">&quot;seas_names&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">fs</span>

    <span class="k">def</span> <span class="nf">__get_seasonality_order_from_dataframe</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">seasonality</span><span class="p">,</span>
            <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns fourier series order from a `pandas.DataFrame`</span>
<span class="sd">        fourier series specification. Return value is capped by ``max_order``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seasonality : `SilverkiteSeasonalityEnum.Seasonality` namedtuple</span>
<span class="sd">            Which seasonality to extract from ``fs``.</span>
<span class="sd">            Has attributes ``name``, ``period``, ``order``, ``seas_names``</span>
<span class="sd">            Can be a `SilverkiteSeasonalityEnum` member value.</span>
<span class="sd">        fs : `pandas.DataFrame` or None, optional, default `None`</span>
<span class="sd">            Columns: &quot;name&quot;, &quot;period&quot;, &quot;order&quot;, &quot;seas_names&quot;</span>
<span class="sd">            Suitable for ``fs_components_df`` parameter for ``forecast_silverkite``</span>
<span class="sd">            for modeling seasonality.</span>
<span class="sd">            Could be returned by ``get_silverkite_seasonality``.</span>
<span class="sd">            Assumes that ``name`` and ``seas_names`` uniquely identify a row.</span>
<span class="sd">        max_order: `int` or None, optional, default `None`</span>
<span class="sd">            Upper limit on seasonality_order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fs_order : `int`</span>
<span class="sd">            The Fourier series order of the row with the given `name` and `seas_names`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_match</span> <span class="o">=</span> <span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">seasonality</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">seas_match</span> <span class="o">=</span> <span class="p">((</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;seas_names&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">seasonality</span><span class="o">.</span><span class="n">seas_names</span><span class="p">)</span>
                          <span class="k">if</span> <span class="n">seasonality</span><span class="o">.</span><span class="n">seas_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                          <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;seas_names&quot;</span><span class="p">]))</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">name_match</span> <span class="o">&amp;</span> <span class="n">seas_match</span><span class="p">):</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">name_match</span> <span class="o">&amp;</span> <span class="n">seas_match</span><span class="p">),</span> <span class="s2">&quot;order&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">max_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">max_order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">order</span>

    <span class="k">def</span> <span class="nf">__get_feature_sets_enabled</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">simple_freq</span><span class="o">=</span><span class="n">SimpleTimeFrequencyEnum</span><span class="o">.</span><span class="n">DAY</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">num_days</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
            <span class="n">feature_sets_enabled</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns default feature sets based on training data frequency and size.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simple_freq: `str`, default SimpleTimeFrequencyEnum.DAY.name</span>
<span class="sd">            SimpleTimeFrequencyEnum member that best matches the input data frequency</span>
<span class="sd">            according to `get_simple_time_frequency_from_period`</span>
<span class="sd">        num_days: `int`, default 1000</span>
<span class="sd">            Number of days of observations in the input data</span>
<span class="sd">        feature_sets_enabled: `dict` [`str`, `bool` or &quot;auto&quot; or None] or `bool` or &quot;auto&quot; or None, default &quot;auto&quot;</span>
<span class="sd">            Whether to include interaction terms and categorical variables to increase model flexibility.</span>

<span class="sd">            If a `dict`, boolean values indicate whether include various sets of features in the model.</span>
<span class="sd">            The following keys are recognized</span>
<span class="sd">            (from `~greykite.algo.forecast.silverkite.constants.silverkite_column.SilverkiteColumn`):</span>

<span class="sd">                ``&quot;COLS_HOUR_OF_WEEK&quot;`` : `str`</span>
<span class="sd">                    Constant hour of week effect</span>
<span class="sd">                ``&quot;COLS_WEEKEND_SEAS&quot;`` : `str`</span>
<span class="sd">                    Daily seasonality interaction with is_weekend</span>
<span class="sd">                ``&quot;COLS_DAY_OF_WEEK_SEAS&quot;`` : `str`</span>
<span class="sd">                    Daily seasonality interaction with day of week</span>
<span class="sd">                ``&quot;COLS_TREND_DAILY_SEAS&quot;`` : `str`</span>
<span class="sd">                    Allow daily seasonality to change over time by is_weekend</span>
<span class="sd">                ``&quot;COLS_EVENT_SEAS&quot;`` : `str`</span>
<span class="sd">                    Allow sub-daily event effects</span>
<span class="sd">                ``&quot;COLS_EVENT_WEEKEND_SEAS&quot;`` : `str`</span>
<span class="sd">                    Allow sub-daily event effect to interact with is_weekend</span>
<span class="sd">                ``&quot;COLS_DAY_OF_WEEK&quot;`` : `str`</span>
<span class="sd">                    Constant day of week effect</span>
<span class="sd">                ``&quot;COLS_TREND_WEEKEND&quot;`` : `str`</span>
<span class="sd">                    Allow trend (growth, changepoints) to interact with is_weekend</span>
<span class="sd">                ``&quot;COLS_TREND_DAY_OF_WEEK&quot;`` : `str`</span>
<span class="sd">                    Allow trend to interact with day of week</span>
<span class="sd">                ``&quot;COLS_TREND_WEEKLY_SEAS&quot;`` : `str`</span>
<span class="sd">                    Allow weekly seasonality to change over time</span>

<span class="sd">            The following dictionary values are recognized:</span>

<span class="sd">                - True: include the feature set in the model</span>
<span class="sd">                - False: do not include the feature set in the model</span>
<span class="sd">                - None: do not include the feature set in the model</span>
<span class="sd">                - &quot;auto&quot; or not provided: use the default setting based on data frequency and size</span>

<span class="sd">            If not a `dict`:</span>

<span class="sd">                - if a boolean, equivalent to a dictionary with all values set to the boolean.</span>
<span class="sd">                - if None, equivalent to a dictionary with all values set to False.</span>
<span class="sd">                - if &quot;auto&quot;, equivalent to a dictionary with all values set to &quot;auto&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        feature_sets_enabled : `dict` [`str`, `bool`]</span>
<span class="sd">            Indicates which feature sets will be added to the model. Feature sets are determined</span>
<span class="sd">            by `get_model_feature_terms` and may be empty (e.g. if there are no events,</span>
<span class="sd">            there is no event:seasonality interaction)</span>
<span class="sd">            Same valid options as `feature_sets_enabled` parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feature_sets_enabled_default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_HOUR_OF_WEEK</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_WEEKEND_SEAS</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_DAY_OF_WEEK_SEAS</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_DAILY_SEAS</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_EVENT_SEAS</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_EVENT_WEEKEND_SEAS</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_DAY_OF_WEEK</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_WEEKEND</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_DAY_OF_WEEK</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_WEEKLY_SEAS</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">frequency</span> <span class="o">=</span> <span class="n">SimpleTimeFrequencyEnum</span><span class="p">[</span><span class="n">simple_freq</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># for sub-daily data</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="n">frequency</span><span class="o">.</span><span class="n">seconds_per_observation</span>
                <span class="o">&lt;=</span> <span class="n">SimpleTimeFrequencyEnum</span><span class="o">.</span><span class="n">HOUR</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">seconds_per_observation</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num_days</span> <span class="o">&gt;=</span> <span class="n">TimeEnum</span><span class="o">.</span><span class="n">ONE_MONTH_IN_DAYS</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="c1"># hour of week offset, helps the fourier terms</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_HOUR_OF_WEEK</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># daily seasonality on weekday vs weekend</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_WEEKEND_SEAS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># daily seasonality by day of week</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_DAY_OF_WEEK_SEAS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># daily seasonality trend on weekday, weekend</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_DAILY_SEAS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">num_days</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">TimeEnum</span><span class="o">.</span><span class="n">ONE_YEAR_IN_DAYS</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="c1"># holiday daily seasonality</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_EVENT_SEAS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># holiday daily seasonality that depends on weekend/weekday</span>
                <span class="c1">#   By pigeonhole principle, with reasonable assumption that a holiday must fall on a different</span>
                <span class="c1">#   day of the week for any three consecutive years (or else always be on the same day of week),</span>
                <span class="c1">#   it takes at most 3 years of training data to observe all weekend/weekday possibilities.</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_EVENT_WEEKEND_SEAS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># for sub-weekly data</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="n">frequency</span><span class="o">.</span><span class="n">seconds_per_observation</span>
                <span class="o">&lt;=</span> <span class="n">SimpleTimeFrequencyEnum</span><span class="o">.</span><span class="n">DAY</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">seconds_per_observation</span><span class="p">):</span>
            <span class="c1"># day of week offset, helps the fourier terms</span>
            <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_DAY_OF_WEEK</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># allows different trend on weekday vs weekend</span>
            <span class="k">if</span> <span class="n">num_days</span> <span class="o">&gt;=</span> <span class="n">TimeEnum</span><span class="o">.</span><span class="n">ONE_MONTH_IN_DAYS</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_WEEKEND</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># allows trend interaction with day of week</span>
            <span class="k">if</span> <span class="n">num_days</span> <span class="o">&gt;=</span> <span class="n">TimeEnum</span><span class="o">.</span><span class="n">ONE_QUARTER_IN_DAYS</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_DAY_OF_WEEK</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">num_days</span> <span class="o">&gt;=</span> <span class="n">TimeEnum</span><span class="o">.</span><span class="n">ONE_YEAR_IN_DAYS</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="c1"># weekly seasonality trend over time</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_WEEKLY_SEAS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># None is treated the same as False.</span>
        <span class="c1"># Intuitively, feature_sets_enabled=None should</span>
        <span class="c1">#   mean no feature sets are enabled.</span>
        <span class="k">if</span> <span class="n">feature_sets_enabled</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">feature_sets_enabled</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Overrides defaults with user provided dictionary</span>
        <span class="k">if</span> <span class="n">feature_sets_enabled</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># uses the automatic defaults directly</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feature_sets_enabled</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="c1"># All values are set to the provided boolean value</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">feature_sets_enabled_default</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_sets_enabled</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feature_sets_enabled</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Uses the boolean values in `feature_sets_enabled` to override `feature_sets_enabled_default`</span>
            <span class="k">for</span> <span class="n">setting</span><span class="p">,</span> <span class="n">is_enabled</span> <span class="ow">in</span> <span class="n">feature_sets_enabled</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">setting</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_sets_enabled_default</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized feature set: &#39;</span><span class="si">{</span><span class="n">setting</span><span class="si">}</span><span class="s2">&#39;. Value feature sets are &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">feature_sets_enabled_default</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">is_enabled</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                    <span class="c1"># &quot;auto&quot; values are considered not set by the user and fall back to the default</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">is_enabled</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1"># User explicitly turned on this feature set.</span>
                    <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="n">setting</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">is_enabled</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">is_enabled</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># User explicitly turned off this feature set.</span>
                    <span class="c1"># None values are treated the same as False.</span>
                    <span class="n">feature_sets_enabled_default</span><span class="p">[</span><span class="n">setting</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unrecognized `feature_sets_enabled` dictionary value for key </span><span class="si">{</span><span class="n">setting</span><span class="si">}</span><span class="s2">: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;expected bool or &#39;auto&#39; or None. Found: </span><span class="si">{</span><span class="n">is_enabled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unrecognized type for `feature_sets_enabled`: expected bool, dict, &#39;auto&#39;, or None. Found: </span><span class="si">{</span><span class="n">feature_sets_enabled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">feature_sets_enabled_default</span>

    <span class="k">def</span> <span class="nf">__get_feature_sets_terms</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">daily_event_df_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">daily_seas_interaction_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">weekly_seas_interaction_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">growth_term</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">changepoint_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Defines features sets for use in the `extra_pred_cols` parameter</span>
<span class="sd">        to `forecast_silverkite`.</span>
<span class="sd">        Derived from events, seasonality, and trend (growth + changepoints).</span>

<span class="sd">        :param daily_event_df_dict: Optional[Dict[str, pd.DataFrame(&quot;date&quot;, &quot;event&quot;)]]</span>
<span class="sd">            suitable for use as `daily_event_df_dict` parameter in `forecast_silverkite`</span>
<span class="sd">            Each event is modeled as its own effect</span>
<span class="sd">        :param daily_seas_interaction_order: int</span>
<span class="sd">            Order on interaction terms with daily seasonality</span>
<span class="sd">        :param weekly_seas_interaction_order: int</span>
<span class="sd">            Order on interaction terms with weekly seasonality</span>
<span class="sd">        :param growth_term: Optional[str]</span>
<span class="sd">            How to model the growth. Valid options are &quot;linear&quot;, &quot;quadratic&quot;, &quot;sqrt&quot;, &quot;cubic&quot;, &quot;cuberoot&quot;</span>
<span class="sd">        :param changepoint_cols: Optional[List[str]]</span>
<span class="sd">            Names of the changepoint feature columns to be generated by `build_silverkite_features`</span>
<span class="sd">        :return: Dict[str, List[str]]</span>
<span class="sd">            The patsy model terms for each feature set</span>
<span class="sd">            key: feature set name</span>
<span class="sd">            value: list of patsy model terms</span>
<span class="sd">                If there are no valid patsy model terms according to the input configuration,</span>
<span class="sd">                the list is empty.</span>
<span class="sd">                For example, if there are no events, the event related effects will be empty</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># enumerates all possible keys</span>
        <span class="n">extra_pred_cols_grouped</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_HOUR_OF_WEEK</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_WEEKEND_SEAS</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_DAY_OF_WEEK_SEAS</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_DAILY_SEAS</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_EVENT_SEAS</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_EVENT_WEEKEND_SEAS</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_DAY_OF_WEEK</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_WEEKEND</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_DAY_OF_WEEK</span><span class="p">:</span> <span class="p">[],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_WEEKLY_SEAS</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="c1"># the columns which constitute the trend</span>
        <span class="k">if</span> <span class="n">changepoint_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">changepoint_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">growth_col</span> <span class="o">=</span> <span class="p">[</span><span class="n">growth_term</span><span class="p">]</span> <span class="k">if</span> <span class="n">growth_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">trend_cols</span> <span class="o">=</span> <span class="n">growth_col</span> <span class="o">+</span> <span class="n">changepoint_cols</span>

        <span class="c1"># all possible values of `dow` and `dow_hr` from `build_time_features_df`</span>
        <span class="n">dow_levels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;1-Mon&quot;</span><span class="p">,</span> <span class="s2">&quot;2-Tue&quot;</span><span class="p">,</span> <span class="s2">&quot;3-Wed&quot;</span><span class="p">,</span> <span class="s2">&quot;4-Thu&quot;</span><span class="p">,</span> <span class="s2">&quot;5-Fri&quot;</span><span class="p">,</span> <span class="s2">&quot;6-Sat&quot;</span><span class="p">,</span> <span class="s2">&quot;7-Sun&quot;</span><span class="p">]</span>
        <span class="n">dow_hr_levels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">day</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">hour</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">24</span><span class="p">)]</span>
        <span class="n">day_of_week</span> <span class="o">=</span> <span class="n">patsy_categorical_term</span><span class="p">(</span><span class="n">term</span><span class="o">=</span><span class="s2">&quot;str_dow&quot;</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">dow_levels</span><span class="p">)</span>
        <span class="n">hour_of_week</span> <span class="o">=</span> <span class="n">patsy_categorical_term</span><span class="p">(</span><span class="n">term</span><span class="o">=</span><span class="s2">&quot;dow_hr&quot;</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">dow_hr_levels</span><span class="p">)</span>

        <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_DAY_OF_WEEK</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">day_of_week</span><span class="p">]</span>
        <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_HOUR_OF_WEEK</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">hour_of_week</span><span class="p">]</span>
        <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_WEEKEND</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;is_weekend:</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">trend_cols</span><span class="p">]</span>
        <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_DAY_OF_WEEK</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">day_of_week</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">trend_cols</span><span class="p">]</span>

        <span class="c1"># allows major holidays to have different daily seasonality</span>
        <span class="c1"># interact with fourier series terms up to fs_daily_interaction_order</span>
        <span class="n">daily_seasonality</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="o">.</span><span class="n">DAILY_SEASONALITY</span><span class="o">.</span><span class="n">value</span>
        <span class="n">weekly_seasonality</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_seasonality_enum</span><span class="o">.</span><span class="n">WEEKLY_SEASONALITY</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="n">daily_seas_interaction_order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">holiday</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_holiday</span><span class="o">.</span><span class="n">HOLIDAYS_TO_INTERACT</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">daily_event_df_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">holiday</span> <span class="ow">in</span> <span class="n">daily_event_df_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">event_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">cst</span><span class="o">.</span><span class="n">EVENT_DEFAULT</span><span class="p">]</span>  <span class="c1"># reference level for non-event days, added by `add_daily_events`</span>
                    <span class="c1"># This event&#39;s levels</span>
                    <span class="n">event_levels</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">daily_event_df_dict</span><span class="p">[</span><span class="n">holiday</span><span class="p">][</span><span class="n">cst</span><span class="o">.</span><span class="n">EVENT_DF_LABEL_COL</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

                    <span class="c1"># `term` matches new_col in `add_daily_events`</span>
                    <span class="n">term</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cst</span><span class="o">.</span><span class="n">EVENT_PREFIX</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">holiday</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_EVENT_SEAS</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cols_interact</span><span class="p">(</span>
                        <span class="n">static_col</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">patsy_categorical_term</span><span class="p">(</span><span class="n">term</span><span class="o">=</span><span class="n">term</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">event_levels</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">fs_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">fs_order</span><span class="o">=</span><span class="n">daily_seas_interaction_order</span><span class="p">,</span>
                        <span class="n">fs_seas_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">seas_names</span><span class="p">)</span>

                    <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_EVENT_WEEKEND_SEAS</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cols_interact</span><span class="p">(</span>
                        <span class="n">static_col</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;is_weekend:</span><span class="si">{</span><span class="n">patsy_categorical_term</span><span class="p">(</span><span class="n">term</span><span class="o">=</span><span class="n">term</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">event_levels</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">fs_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">fs_order</span><span class="o">=</span><span class="n">daily_seas_interaction_order</span><span class="p">,</span>
                        <span class="n">fs_seas_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">seas_names</span><span class="p">)</span>

            <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_WEEKEND_SEAS</span><span class="p">]</span> <span class="o">=</span> <span class="n">cols_interact</span><span class="p">(</span>
                <span class="n">static_col</span><span class="o">=</span><span class="s2">&quot;is_weekend&quot;</span><span class="p">,</span>
                <span class="n">fs_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">fs_order</span><span class="o">=</span><span class="n">daily_seas_interaction_order</span><span class="p">,</span>
                <span class="n">fs_seas_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">seas_names</span><span class="p">)</span>

            <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_DAY_OF_WEEK_SEAS</span><span class="p">]</span> <span class="o">=</span> <span class="n">cols_interact</span><span class="p">(</span>
                <span class="n">static_col</span><span class="o">=</span><span class="n">day_of_week</span><span class="p">,</span>
                <span class="n">fs_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">fs_order</span><span class="o">=</span><span class="n">daily_seas_interaction_order</span><span class="p">,</span>
                <span class="n">fs_seas_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">seas_names</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">trend_cols</span><span class="p">:</span>
                <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_DAILY_SEAS</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cols_interact</span><span class="p">(</span>
                    <span class="n">static_col</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;is_weekend:</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">fs_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">fs_order</span><span class="o">=</span><span class="n">daily_seas_interaction_order</span><span class="p">,</span>
                    <span class="n">fs_seas_name</span><span class="o">=</span><span class="n">daily_seasonality</span><span class="o">.</span><span class="n">seas_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weekly_seas_interaction_order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">trend_cols</span><span class="p">:</span>
                <span class="n">extra_pred_cols_grouped</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_column</span><span class="o">.</span><span class="n">COLS_TREND_WEEKLY_SEAS</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cols_interact</span><span class="p">(</span>
                    <span class="n">static_col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                    <span class="n">fs_name</span><span class="o">=</span><span class="n">weekly_seasonality</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">fs_order</span><span class="o">=</span><span class="n">weekly_seas_interaction_order</span><span class="p">,</span>
                    <span class="n">fs_seas_name</span><span class="o">=</span><span class="n">weekly_seasonality</span><span class="o">.</span><span class="n">seas_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">extra_pred_cols_grouped</span>

    <span class="k">def</span> <span class="nf">__get_silverkite_holidays</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">holiday_lookup_countries</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">holidays_to_model_separately</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">start_year</span><span class="o">=</span><span class="mi">2015</span><span class="p">,</span>
            <span class="n">end_year</span><span class="o">=</span><span class="mi">2030</span><span class="p">,</span>
            <span class="n">pre_num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">post_num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">pre_post_num_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates holidays dictionary for input to daily_event_df_dict parameter of silverkite model.</span>
<span class="sd">        The main purpose is to provide reasonable defaults for the holiday names and countries</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        holiday_lookup_countries : `list` [`str`] or &quot;auto&quot; or None, optional, default &quot;auto&quot;</span>
<span class="sd">            The countries that contain the holidays you intend to model</span>
<span class="sd">            (``holidays_to_model_separately``).</span>

<span class="sd">            * If &quot;auto&quot;, uses a default list of countries</span>
<span class="sd">              that contain the default ``holidays_to_model_separately``.</span>
<span class="sd">              See `~greykite.algo.forecast.silverkite.constants.silverkite_holiday.SilverkiteHoliday.HOLIDAY_LOOKUP_COUNTRIES_AUTO`.</span>
<span class="sd">            * If a list, must be a list of country names.</span>
<span class="sd">            * If None or an empty list, no holidays are modeled.</span>

<span class="sd">        holidays_to_model_separately : `list` [`str`] or &quot;auto&quot; or `~greykite.algo.forecast.silverkite.constants.silverkite_holiday.SilverkiteHoliday.ALL_HOLIDAYS_IN_COUNTRIES` or None, optional, default &quot;auto&quot;  # noqa: E501</span>
<span class="sd">            Which holidays to include in the model.</span>
<span class="sd">            The model creates a separate key, value for each item in ``holidays_to_model_separately``.</span>
<span class="sd">            The other holidays in the countries are grouped together as a single effect.</span>

<span class="sd">            * If &quot;auto&quot;, uses a default list of important holidays.</span>
<span class="sd">              See `~greykite.algo.forecast.silverkite.constants.silverkite_holiday.SilverkiteHoliday.HOLIDAYS_TO_MODEL_SEPARATELY_AUTO`.</span>
<span class="sd">            * If `~greykite.algo.forecast.silverkite.constants.silverkite_holiday.SilverkiteHoliday.ALL_HOLIDAYS_IN_COUNTRIES`,</span>
<span class="sd">              uses all available holidays in ``holiday_lookup_countries``. This can often</span>
<span class="sd">              create a model that has too many parameters, and should typically be avoided.</span>
<span class="sd">            * If a list, must be a list of holiday names.</span>
<span class="sd">            * If None or an empty list, all holidays in ``holiday_lookup_countries`` are grouped together</span>
<span class="sd">              as a single effect.</span>

<span class="sd">            Use ``holiday_lookup_countries`` to provide a list of countries where these holiday occur.</span>
<span class="sd">        start_year : `int`</span>
<span class="sd">            Year of first training data point, used to generate holiday events.</span>
<span class="sd">        end_year : `int`</span>
<span class="sd">            Year of last forecast data point, used to generate holiday events.</span>
<span class="sd">        pre_num : `int`</span>
<span class="sd">            Model holiday effects for ``pre_num`` days before the holiday.</span>
<span class="sd">        post_num : `int`</span>
<span class="sd">            Model holiday effects for ``post_num`` days after the holiday.</span>
<span class="sd">        pre_post_num_dict : `dict` [`str`, (`int`, `int`)] or None, default None</span>
<span class="sd">            Overrides ``pre_num`` and ``post_num`` for each holiday in</span>
<span class="sd">            ``holidays_to_model_separately``.</span>
<span class="sd">            For example, if ``holidays_to_model_separately`` contains &quot;Thanksgiving&quot; and &quot;Labor Day&quot;,</span>
<span class="sd">            this parameter can be set to ``{&quot;Thanksgiving&quot;: [1, 3], &quot;Labor Day&quot;: [1, 2]}``,</span>
<span class="sd">            denoting that the &quot;Thanksgiving&quot; ``pre_num`` is 1 and ``post_num`` is 3, and &quot;Labor Day&quot;</span>
<span class="sd">            ``pre_num`` is 1 and ``post_num`` is 2.</span>
<span class="sd">            Holidays not specified use the default given by ``pre_num`` and ``post_num``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        daily_event_df_dict : `dict` [`str`, `pandas.DataFrame` [EVENT_DF_DATE_COL, EVENT_DF_LABEL_COL]]</span>
<span class="sd">            Suitable for use as `daily_event_df_dict` parameter in `forecast_silverkite`.</span>
<span class="sd">            Each holiday is modeled as its own effect (not specific to each country).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `~greykite.common.features.timeseries_features.get_available_holiday_lookup_countries`</span>
<span class="sd">        to list available countries for modeling.</span>

<span class="sd">        `~greykite.common.features.timeseries_features.get_available_holidays_across_countries`</span>
<span class="sd">        to see available holidays in those countries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">holiday_lookup_countries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># `None` will not model any holidays</span>
            <span class="n">holiday_lookup_countries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">holiday_lookup_countries</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="c1"># countries that contain the default `holidays_to_model_separately`</span>
            <span class="n">holiday_lookup_countries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_holiday</span><span class="o">.</span><span class="n">HOLIDAY_LOOKUP_COUNTRIES_AUTO</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">holiday_lookup_countries</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`holiday_lookup_countries` should be a list, found </span><span class="si">{</span><span class="n">holiday_lookup_countries</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">holidays_to_model_separately</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">holidays_to_model_separately</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">holidays_to_model_separately</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="c1"># important holidays</span>
            <span class="n">holidays_to_model_separately</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_holiday</span><span class="o">.</span><span class="n">HOLIDAYS_TO_MODEL_SEPARATELY_AUTO</span>
        <span class="k">elif</span> <span class="n">holidays_to_model_separately</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_silverkite_holiday</span><span class="o">.</span><span class="n">ALL_HOLIDAYS_IN_COUNTRIES</span><span class="p">:</span>
            <span class="n">holidays_to_model_separately</span> <span class="o">=</span> <span class="n">get_available_holidays_across_countries</span><span class="p">(</span>
                <span class="n">countries</span><span class="o">=</span><span class="n">holiday_lookup_countries</span><span class="p">,</span>
                <span class="n">year_start</span><span class="o">=</span><span class="n">start_year</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">year_end</span><span class="o">=</span><span class="n">end_year</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">holidays_to_model_separately</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`holidays_to_model_separately` should be a list, found </span><span class="si">{</span><span class="n">holidays_to_model_separately</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">generate_holiday_events</span><span class="p">(</span>
            <span class="n">countries</span><span class="o">=</span><span class="n">holiday_lookup_countries</span><span class="p">,</span>
            <span class="n">holidays_to_model_separately</span><span class="o">=</span><span class="n">holidays_to_model_separately</span><span class="p">,</span>
            <span class="n">year_start</span><span class="o">=</span><span class="n">start_year</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># subtract 1 just in case, to ensure coverage of all holidays</span>
            <span class="n">year_end</span><span class="o">=</span><span class="n">end_year</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># add 1 just in case, to ensure coverage of all holidays</span>
            <span class="n">pre_num</span><span class="o">=</span><span class="n">pre_num</span><span class="p">,</span>
            <span class="n">post_num</span><span class="o">=</span><span class="n">post_num</span><span class="p">,</span>
            <span class="n">pre_post_num_dict</span><span class="o">=</span><span class="n">pre_post_num_dict</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, LinkedIn

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>